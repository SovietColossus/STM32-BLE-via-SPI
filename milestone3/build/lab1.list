
build/lab1.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4826      	ldr	r0, [pc, #152]	; (800029c <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	2002      	movs	r0, #2
 800020a:	f380 8814 	msr	CONTROL, r0
 800020e:	f3bf 8f6f 	isb	sy
 8000212:	f004 fc95 	bl	8004b40 <__core_init>
 8000216:	f002 f943 	bl	80024a0 <__early_init>
 800021a:	4821      	ldr	r0, [pc, #132]	; (80002a0 <endfiniloop+0x8>)
 800021c:	4921      	ldr	r1, [pc, #132]	; (80002a4 <endfiniloop+0xc>)
 800021e:	4a22      	ldr	r2, [pc, #136]	; (80002a8 <endfiniloop+0x10>)

08000220 <msloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	f7ff bffa 	bcc.w	8000220 <msloop>
 800022c:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x14>)
 800022e:	4a1b      	ldr	r2, [pc, #108]	; (800029c <endfiniloop+0x4>)

08000230 <psloop>:
 8000230:	4291      	cmp	r1, r2
 8000232:	bf3c      	itt	cc
 8000234:	f841 0b04 	strcc.w	r0, [r1], #4
 8000238:	f7ff bffa 	bcc.w	8000230 <psloop>
 800023c:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x18>)
 800023e:	4a1d      	ldr	r2, [pc, #116]	; (80002b4 <endfiniloop+0x1c>)
 8000240:	4b1d      	ldr	r3, [pc, #116]	; (80002b8 <endfiniloop+0x20>)

08000242 <dloop>:
 8000242:	429a      	cmp	r2, r3
 8000244:	bf3e      	ittt	cc
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
 800024e:	f7ff bff8 	bcc.w	8000242 <dloop>
 8000252:	2000      	movs	r0, #0
 8000254:	4919      	ldr	r1, [pc, #100]	; (80002bc <endfiniloop+0x24>)
 8000256:	4a1a      	ldr	r2, [pc, #104]	; (80002c0 <endfiniloop+0x28>)

08000258 <bloop>:
 8000258:	4291      	cmp	r1, r2
 800025a:	bf3c      	itt	cc
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000260:	f7ff bffa 	bcc.w	8000258 <bloop>
 8000264:	f004 fc84 	bl	8004b70 <__init_ram_areas>
 8000268:	f004 fc72 	bl	8004b50 <__late_init>
 800026c:	4c15      	ldr	r4, [pc, #84]	; (80002c4 <endfiniloop+0x2c>)
 800026e:	4d16      	ldr	r5, [pc, #88]	; (80002c8 <endfiniloop+0x30>)

08000270 <initloop>:
 8000270:	42ac      	cmp	r4, r5
 8000272:	f280 8005 	bge.w	8000280 <endinitloop>
 8000276:	f854 1b04 	ldr.w	r1, [r4], #4
 800027a:	4788      	blx	r1
 800027c:	f7ff bff8 	b.w	8000270 <initloop>

08000280 <endinitloop>:
 8000280:	f000 fd8e 	bl	8000da0 <main>
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x34>)
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x38>)

08000288 <finiloop>:
 8000288:	42ac      	cmp	r4, r5
 800028a:	f280 8005 	bge.w	8000298 <endfiniloop>
 800028e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000292:	4788      	blx	r1
 8000294:	f7ff bff8 	b.w	8000288 <finiloop>

08000298 <endfiniloop>:
 8000298:	f004 bc62 	b.w	8004b60 <__default_exit>
 800029c:	20000800 	.word	0x20000800
 80002a0:	55555555 	.word	0x55555555
 80002a4:	20000000 	.word	0x20000000
 80002a8:	20000400 	.word	0x20000400
 80002ac:	20000400 	.word	0x20000400
 80002b0:	08006ab8 	.word	0x08006ab8
 80002b4:	20000800 	.word	0x20000800
 80002b8:	20000954 	.word	0x20000954
 80002bc:	20000958 	.word	0x20000958
 80002c0:	20001f58 	.word	0x20001f58
 80002c4:	08000200 	.word	0x08000200
 80002c8:	08000200 	.word	0x08000200
 80002cc:	08000200 	.word	0x08000200
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002e8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
 80002f0:	2300      	movs	r3, #0
 80002f2:	f383 8811 	msr	BASEPRI, r3
 80002f6:	4628      	mov	r0, r5
 80002f8:	47a0      	blx	r4
 80002fa:	2000      	movs	r0, #0
 80002fc:	f005 fb38 	bl	8005970 <chThdExit>

08000300 <_port_switch_from_isr>:
 8000300:	f005 f9b6 	bl	8005670 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
 8000304:	df00      	svc	0
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <strcmp>:
 8000310:	ea40 0c01 	orr.w	ip, r0, r1
 8000314:	f01c 0f07 	tst.w	ip, #7
 8000318:	d123      	bne.n	8000362 <strcmp+0x52>
 800031a:	f1bd 0d10 	subs.w	sp, sp, #16
 800031e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8000322:	e9cd 6700 	strd	r6, r7, [sp]
 8000326:	f06f 0600 	mvn.w	r6, #0
 800032a:	f04f 0700 	mov.w	r7, #0
 800032e:	bf00      	nop
 8000330:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8000334:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8000338:	42a2      	cmp	r2, r4
 800033a:	fa82 fc46 	uadd8	ip, r2, r6
 800033e:	faa7 fc86 	sel	ip, r7, r6
 8000342:	bf08      	it	eq
 8000344:	f1bc 0f00 	cmpeq.w	ip, #0
 8000348:	f040 80d7 	bne.w	80004fa <strcmp+0x1ea>
 800034c:	42ab      	cmp	r3, r5
 800034e:	fa83 fc46 	uadd8	ip, r3, r6
 8000352:	faa7 fc86 	sel	ip, r7, r6
 8000356:	bf08      	it	eq
 8000358:	f1bc 0f00 	cmpeq.w	ip, #0
 800035c:	f040 80ca 	bne.w	80004f4 <strcmp+0x1e4>
 8000360:	e7e6      	b.n	8000330 <strcmp+0x20>
 8000362:	f010 0c03 	ands.w	ip, r0, #3
 8000366:	d021      	beq.n	80003ac <strcmp+0x9c>
 8000368:	f020 0003 	bic.w	r0, r0, #3
 800036c:	f850 2b04 	ldr.w	r2, [r0], #4
 8000370:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 8000374:	d008      	beq.n	8000388 <strcmp+0x78>
 8000376:	d20f      	bcs.n	8000398 <strcmp+0x88>
 8000378:	f811 cb01 	ldrb.w	ip, [r1], #1
 800037c:	fa5f f392 	uxtb.w	r3, r2, ror #8
 8000380:	ebb3 0c0c 	subs.w	ip, r3, ip
 8000384:	d110      	bne.n	80003a8 <strcmp+0x98>
 8000386:	b17b      	cbz	r3, 80003a8 <strcmp+0x98>
 8000388:	f811 cb01 	ldrb.w	ip, [r1], #1
 800038c:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 8000390:	ebb3 0c0c 	subs.w	ip, r3, ip
 8000394:	d108      	bne.n	80003a8 <strcmp+0x98>
 8000396:	b13b      	cbz	r3, 80003a8 <strcmp+0x98>
 8000398:	f811 cb01 	ldrb.w	ip, [r1], #1
 800039c:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 80003a0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80003a4:	d100      	bne.n	80003a8 <strcmp+0x98>
 80003a6:	b90b      	cbnz	r3, 80003ac <strcmp+0x9c>
 80003a8:	4660      	mov	r0, ip
 80003aa:	4770      	bx	lr
 80003ac:	f1bd 0d10 	subs.w	sp, sp, #16
 80003b0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80003b4:	e9cd 6700 	strd	r6, r7, [sp]
 80003b8:	f06f 0600 	mvn.w	r6, #0
 80003bc:	f04f 0700 	mov.w	r7, #0
 80003c0:	f011 0c03 	ands.w	ip, r1, #3
 80003c4:	d12d      	bne.n	8000422 <strcmp+0x112>
 80003c6:	f010 0f04 	tst.w	r0, #4
 80003ca:	d00d      	beq.n	80003e8 <strcmp+0xd8>
 80003cc:	f850 2b04 	ldr.w	r2, [r0], #4
 80003d0:	f851 4b04 	ldr.w	r4, [r1], #4
 80003d4:	42a2      	cmp	r2, r4
 80003d6:	fa82 fc46 	uadd8	ip, r2, r6
 80003da:	faa7 fc86 	sel	ip, r7, r6
 80003de:	bf08      	it	eq
 80003e0:	f1bc 0f00 	cmpeq.w	ip, #0
 80003e4:	f040 8089 	bne.w	80004fa <strcmp+0x1ea>
 80003e8:	f011 0f04 	tst.w	r1, #4
 80003ec:	d09f      	beq.n	800032e <strcmp+0x1e>
 80003ee:	f851 5b04 	ldr.w	r5, [r1], #4
 80003f2:	bf00      	nop
 80003f4:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 80003f8:	42aa      	cmp	r2, r5
 80003fa:	fa82 fc46 	uadd8	ip, r2, r6
 80003fe:	faa7 fc86 	sel	ip, r7, r6
 8000402:	bf08      	it	eq
 8000404:	f1bc 0f00 	cmpeq.w	ip, #0
 8000408:	d171      	bne.n	80004ee <strcmp+0x1de>
 800040a:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 800040e:	42a3      	cmp	r3, r4
 8000410:	fa83 fc46 	uadd8	ip, r3, r6
 8000414:	faa7 fc86 	sel	ip, r7, r6
 8000418:	bf08      	it	eq
 800041a:	f1bc 0f00 	cmpeq.w	ip, #0
 800041e:	d163      	bne.n	80004e8 <strcmp+0x1d8>
 8000420:	e7e8      	b.n	80003f4 <strcmp+0xe4>
 8000422:	f021 0103 	bic.w	r1, r1, #3
 8000426:	f1bc 0f02 	cmp.w	ip, #2
 800042a:	d01e      	beq.n	800046a <strcmp+0x15a>
 800042c:	da3b      	bge.n	80004a6 <strcmp+0x196>
 800042e:	f851 5b04 	ldr.w	r5, [r1], #4
 8000432:	bf00      	nop
 8000434:	f850 3b04 	ldr.w	r3, [r0], #4
 8000438:	ea4f 2515 	mov.w	r5, r5, lsr #8
 800043c:	fa83 fc46 	uadd8	ip, r3, r6
 8000440:	faa7 fc86 	sel	ip, r7, r6
 8000444:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 8000448:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 800044c:	bf08      	it	eq
 800044e:	42aa      	cmpeq	r2, r5
 8000450:	d14d      	bne.n	80004ee <strcmp+0x1de>
 8000452:	f851 5b04 	ldr.w	r5, [r1], #4
 8000456:	f1bc 0f00 	cmp.w	ip, #0
 800045a:	ea82 0303 	eor.w	r3, r2, r3
 800045e:	ea4f 6205 	mov.w	r2, r5, lsl #24
 8000462:	bf08      	it	eq
 8000464:	4293      	cmpeq	r3, r2
 8000466:	d13c      	bne.n	80004e2 <strcmp+0x1d2>
 8000468:	e7e4      	b.n	8000434 <strcmp+0x124>
 800046a:	f851 5b04 	ldr.w	r5, [r1], #4
 800046e:	bf00      	nop
 8000470:	f850 3b04 	ldr.w	r3, [r0], #4
 8000474:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8000478:	fa83 fc46 	uadd8	ip, r3, r6
 800047c:	faa7 fc86 	sel	ip, r7, r6
 8000480:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 8000484:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 8000488:	bf08      	it	eq
 800048a:	42aa      	cmpeq	r2, r5
 800048c:	d12f      	bne.n	80004ee <strcmp+0x1de>
 800048e:	f851 5b04 	ldr.w	r5, [r1], #4
 8000492:	f1bc 0f00 	cmp.w	ip, #0
 8000496:	ea82 0303 	eor.w	r3, r2, r3
 800049a:	ea4f 4205 	mov.w	r2, r5, lsl #16
 800049e:	bf08      	it	eq
 80004a0:	4293      	cmpeq	r3, r2
 80004a2:	d11e      	bne.n	80004e2 <strcmp+0x1d2>
 80004a4:	e7e4      	b.n	8000470 <strcmp+0x160>
 80004a6:	f851 5b04 	ldr.w	r5, [r1], #4
 80004aa:	bf00      	nop
 80004ac:	f850 3b04 	ldr.w	r3, [r0], #4
 80004b0:	ea4f 6515 	mov.w	r5, r5, lsr #24
 80004b4:	fa83 fc46 	uadd8	ip, r3, r6
 80004b8:	faa7 fc86 	sel	ip, r7, r6
 80004bc:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 80004c0:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 80004c4:	bf08      	it	eq
 80004c6:	42aa      	cmpeq	r2, r5
 80004c8:	d111      	bne.n	80004ee <strcmp+0x1de>
 80004ca:	f851 5b04 	ldr.w	r5, [r1], #4
 80004ce:	f1bc 0f00 	cmp.w	ip, #0
 80004d2:	ea82 0303 	eor.w	r3, r2, r3
 80004d6:	ea4f 2205 	mov.w	r2, r5, lsl #8
 80004da:	bf08      	it	eq
 80004dc:	4293      	cmpeq	r3, r2
 80004de:	d100      	bne.n	80004e2 <strcmp+0x1d2>
 80004e0:	e7e4      	b.n	80004ac <strcmp+0x19c>
 80004e2:	ba19      	rev	r1, r3
 80004e4:	ba12      	rev	r2, r2
 80004e6:	e00a      	b.n	80004fe <strcmp+0x1ee>
 80004e8:	ba19      	rev	r1, r3
 80004ea:	ba22      	rev	r2, r4
 80004ec:	e007      	b.n	80004fe <strcmp+0x1ee>
 80004ee:	ba11      	rev	r1, r2
 80004f0:	ba2a      	rev	r2, r5
 80004f2:	e004      	b.n	80004fe <strcmp+0x1ee>
 80004f4:	ba19      	rev	r1, r3
 80004f6:	ba2a      	rev	r2, r5
 80004f8:	e001      	b.n	80004fe <strcmp+0x1ee>
 80004fa:	ba11      	rev	r1, r2
 80004fc:	ba22      	rev	r2, r4
 80004fe:	fa9c f08c 	rev.w	r0, ip
 8000502:	e9dd 6700 	ldrd	r6, r7, [sp]
 8000506:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 800050a:	f11d 0d10 	adds.w	sp, sp, #16
 800050e:	b138      	cbz	r0, 8000520 <strcmp+0x210>
 8000510:	fab0 f080 	clz	r0, r0
 8000514:	f1c0 0018 	rsb	r0, r0, #24
 8000518:	fa21 f100 	lsr.w	r1, r1, r0
 800051c:	fa22 f200 	lsr.w	r2, r2, r0
 8000520:	2001      	movs	r0, #1
 8000522:	4291      	cmp	r1, r2
 8000524:	bf98      	it	ls
 8000526:	4180      	sbcls	r0, r0
 8000528:	4770      	bx	lr
 800052a:	bf00      	nop
 800052c:	0000      	movs	r0, r0
	...

08000530 <chThdTerminatedX.13354.4157>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 8000530:	b082      	sub	sp, #8
 8000532:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 8000534:	9b01      	ldr	r3, [sp, #4]
 8000536:	f893 3020 	ldrb.w	r3, [r3, #32]
 800053a:	2b0f      	cmp	r3, #15
 800053c:	bf14      	ite	ne
 800053e:	2300      	movne	r3, #0
 8000540:	2301      	moveq	r3, #1
 8000542:	b2db      	uxtb	r3, r3
}
 8000544:	4618      	mov	r0, r3
 8000546:	b002      	add	sp, #8
 8000548:	4770      	bx	lr
 800054a:	bf00      	nop
 800054c:	f3af 8000 	nop.w

08000550 <chEvtRegisterMask.13455.4152>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 8000550:	b500      	push	{lr}
 8000552:	b085      	sub	sp, #20
 8000554:	9003      	str	r0, [sp, #12]
 8000556:	9102      	str	r1, [sp, #8]
 8000558:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800055a:	9803      	ldr	r0, [sp, #12]
 800055c:	9902      	ldr	r1, [sp, #8]
 800055e:	9a01      	ldr	r2, [sp, #4]
 8000560:	f04f 33ff 	mov.w	r3, #4294967295
 8000564:	f004 fa0c 	bl	8004980 <chEvtRegisterMaskWithFlags>
}
 8000568:	b005      	add	sp, #20
 800056a:	f85d fb04 	ldr.w	pc, [sp], #4
 800056e:	bf00      	nop

08000570 <chEvtRegister.13471.4068>:
 *
 * @api
 */
static inline void chEvtRegister(event_source_t *esp,
                                 event_listener_t *elp,
                                 eventid_t event) {
 8000570:	b500      	push	{lr}
 8000572:	b085      	sub	sp, #20
 8000574:	9003      	str	r0, [sp, #12]
 8000576:	9102      	str	r1, [sp, #8]
 8000578:	9201      	str	r2, [sp, #4]

  chEvtRegisterMask(esp, elp, EVENT_MASK(event));
 800057a:	2201      	movs	r2, #1
 800057c:	9b01      	ldr	r3, [sp, #4]
 800057e:	fa02 f303 	lsl.w	r3, r2, r3
 8000582:	9803      	ldr	r0, [sp, #12]
 8000584:	9902      	ldr	r1, [sp, #8]
 8000586:	461a      	mov	r2, r3
 8000588:	f7ff ffe2 	bl	8000550 <chEvtRegisterMask.13455.4152>
}
 800058c:	b005      	add	sp, #20
 800058e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000592:	bf00      	nop
 8000594:	f3af 8000 	nop.w
 8000598:	f3af 8000 	nop.w
 800059c:	f3af 8000 	nop.w

080005a0 <WriteReadWrapper.4061>:
- Set the device name, so that our future app looks for the name automatically.
- Turn off LEDS
*/


void WriteReadWrapper(uint8_t *send_data, uint32_t size) {
 80005a0:	b500      	push	{lr}
 80005a2:	b085      	sub	sp, #20
 80005a4:	9001      	str	r0, [sp, #4]
 80005a6:	9100      	str	r1, [sp, #0]
  uint32_t i = 0;
 80005a8:	2300      	movs	r3, #0
 80005aa:	9303      	str	r3, [sp, #12]
 80005ac:	e061      	b.n	8000672 <WriteReadWrapper.4061+0xd2>
  while (size > 0) {
    if(size > 191) {
 80005ae:	9b00      	ldr	r3, [sp, #0]
 80005b0:	2bbf      	cmp	r3, #191	; 0xbf
 80005b2:	d925      	bls.n	8000600 <WriteReadWrapper.4061+0x60>
      for (i = 17; i < 208; i++) {
 80005b4:	2311      	movs	r3, #17
 80005b6:	9303      	str	r3, [sp, #12]
 80005b8:	e00b      	b.n	80005d2 <WriteReadWrapper.4061+0x32>
        tx_data_plus[i] = send_data[i - 17];
 80005ba:	9b03      	ldr	r3, [sp, #12]
 80005bc:	3b11      	subs	r3, #17
 80005be:	9a01      	ldr	r2, [sp, #4]
 80005c0:	4413      	add	r3, r2
 80005c2:	781a      	ldrb	r2, [r3, #0]
 80005c4:	492e      	ldr	r1, [pc, #184]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 80005c6:	9b03      	ldr	r3, [sp, #12]
 80005c8:	440b      	add	r3, r1
 80005ca:	701a      	strb	r2, [r3, #0]

void WriteReadWrapper(uint8_t *send_data, uint32_t size) {
  uint32_t i = 0;
  while (size > 0) {
    if(size > 191) {
      for (i = 17; i < 208; i++) {
 80005cc:	9b03      	ldr	r3, [sp, #12]
 80005ce:	3301      	adds	r3, #1
 80005d0:	9303      	str	r3, [sp, #12]
 80005d2:	9b03      	ldr	r3, [sp, #12]
 80005d4:	2bcf      	cmp	r3, #207	; 0xcf
 80005d6:	d9f0      	bls.n	80005ba <WriteReadWrapper.4061+0x1a>
        tx_data_plus[i] = send_data[i - 17];
      }
      chThdSleepMilliseconds(100);
 80005d8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80005dc:	f005 f9b8 	bl	8005950 <chThdSleep>
      WriteRead(tx_data_plus, 208, rdata);
 80005e0:	4827      	ldr	r0, [pc, #156]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 80005e2:	21d0      	movs	r1, #208	; 0xd0
 80005e4:	4a27      	ldr	r2, [pc, #156]	; (8000684 <WriteReadWrapper.4061+0xe4>)
 80005e6:	f000 f853 	bl	8000690 <WriteRead.4056>
      chThdSleepMilliseconds(100);
 80005ea:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80005ee:	f005 f9af 	bl	8005950 <chThdSleep>
      send_data += 191;
 80005f2:	9b01      	ldr	r3, [sp, #4]
 80005f4:	33bf      	adds	r3, #191	; 0xbf
 80005f6:	9301      	str	r3, [sp, #4]
      size -= 191;
 80005f8:	9b00      	ldr	r3, [sp, #0]
 80005fa:	3bbf      	subs	r3, #191	; 0xbf
 80005fc:	9300      	str	r3, [sp, #0]
 80005fe:	e038      	b.n	8000672 <WriteReadWrapper.4061+0xd2>
    } 
    else {
      if(size > 3) {
 8000600:	9b00      	ldr	r3, [sp, #0]
 8000602:	2b03      	cmp	r3, #3
 8000604:	d909      	bls.n	800061a <WriteReadWrapper.4061+0x7a>
        tx_data_plus[3] = (uint8_t) (0x80 | (size + 13));
 8000606:	9b00      	ldr	r3, [sp, #0]
 8000608:	b2db      	uxtb	r3, r3
 800060a:	330d      	adds	r3, #13
 800060c:	b2db      	uxtb	r3, r3
 800060e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8000612:	b2da      	uxtb	r2, r3
 8000614:	4b1a      	ldr	r3, [pc, #104]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 8000616:	70da      	strb	r2, [r3, #3]
 8000618:	e005      	b.n	8000626 <WriteReadWrapper.4061+0x86>
      }
      else {
        tx_data_plus[3] = (uint8_t) size + 13;
 800061a:	9b00      	ldr	r3, [sp, #0]
 800061c:	b2db      	uxtb	r3, r3
 800061e:	330d      	adds	r3, #13
 8000620:	b2da      	uxtb	r2, r3
 8000622:	4b17      	ldr	r3, [pc, #92]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 8000624:	70da      	strb	r2, [r3, #3]
      }
      for (i = 17; i < size+17; i++) {
 8000626:	2311      	movs	r3, #17
 8000628:	9303      	str	r3, [sp, #12]
 800062a:	e00b      	b.n	8000644 <WriteReadWrapper.4061+0xa4>
        tx_data_plus[i] = send_data[i - 17];
 800062c:	9b03      	ldr	r3, [sp, #12]
 800062e:	3b11      	subs	r3, #17
 8000630:	9a01      	ldr	r2, [sp, #4]
 8000632:	4413      	add	r3, r2
 8000634:	781a      	ldrb	r2, [r3, #0]
 8000636:	4912      	ldr	r1, [pc, #72]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 8000638:	9b03      	ldr	r3, [sp, #12]
 800063a:	440b      	add	r3, r1
 800063c:	701a      	strb	r2, [r3, #0]
        tx_data_plus[3] = (uint8_t) (0x80 | (size + 13));
      }
      else {
        tx_data_plus[3] = (uint8_t) size + 13;
      }
      for (i = 17; i < size+17; i++) {
 800063e:	9b03      	ldr	r3, [sp, #12]
 8000640:	3301      	adds	r3, #1
 8000642:	9303      	str	r3, [sp, #12]
 8000644:	9b00      	ldr	r3, [sp, #0]
 8000646:	f103 0211 	add.w	r2, r3, #17
 800064a:	9b03      	ldr	r3, [sp, #12]
 800064c:	429a      	cmp	r2, r3
 800064e:	d8ed      	bhi.n	800062c <WriteReadWrapper.4061+0x8c>
        tx_data_plus[i] = send_data[i - 17];
      }
      //tx_data_plus[3] = (uint8_t) size;
      chThdSleepMilliseconds(100);
 8000650:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000654:	f005 f97c 	bl	8005950 <chThdSleep>
      WriteRead(tx_data_plus, size + 17, rdata);
 8000658:	9b00      	ldr	r3, [sp, #0]
 800065a:	3311      	adds	r3, #17
 800065c:	4808      	ldr	r0, [pc, #32]	; (8000680 <WriteReadWrapper.4061+0xe0>)
 800065e:	4619      	mov	r1, r3
 8000660:	4a08      	ldr	r2, [pc, #32]	; (8000684 <WriteReadWrapper.4061+0xe4>)
 8000662:	f000 f815 	bl	8000690 <WriteRead.4056>
      chThdSleepMilliseconds(100);
 8000666:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800066a:	f005 f971 	bl	8005950 <chThdSleep>
      size = 0;
 800066e:	2300      	movs	r3, #0
 8000670:	9300      	str	r3, [sp, #0]
*/


void WriteReadWrapper(uint8_t *send_data, uint32_t size) {
  uint32_t i = 0;
  while (size > 0) {
 8000672:	9b00      	ldr	r3, [sp, #0]
 8000674:	2b00      	cmp	r3, #0
 8000676:	d19a      	bne.n	80005ae <WriteReadWrapper.4061+0xe>
      WriteRead(tx_data_plus, size + 17, rdata);
      chThdSleepMilliseconds(100);
      size = 0;
    }
  }
}
 8000678:	b005      	add	sp, #20
 800067a:	f85d fb04 	ldr.w	pc, [sp], #4
 800067e:	bf00      	nop
 8000680:	20000870 	.word	0x20000870
 8000684:	20000c2c 	.word	0x20000c2c
 8000688:	f3af 8000 	nop.w
 800068c:	f3af 8000 	nop.w

08000690 <WriteRead.4056>:

void WriteRead(uint8_t *send_data, uint8_t size, uint8_t *receive_data) {
 8000690:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000694:	b095      	sub	sp, #84	; 0x54
 8000696:	af00      	add	r7, sp, #0
 8000698:	60f8      	str	r0, [r7, #12]
 800069a:	460b      	mov	r3, r1
 800069c:	607a      	str	r2, [r7, #4]
 800069e:	72fb      	strb	r3, [r7, #11]
  spiAcquireBus(&SPID1);               /* Acquire ownership of the bus.    */
 80006a0:	48ac      	ldr	r0, [pc, #688]	; (8000954 <WriteRead.4056+0x2c4>)
 80006a2:	f003 f945 	bl	8003930 <spiAcquireBus>
  spiStart(&SPID1, &bluefruit_config);     /* Setup transfer parameters.       */
 80006a6:	48ab      	ldr	r0, [pc, #684]	; (8000954 <WriteRead.4056+0x2c4>)
 80006a8:	49ab      	ldr	r1, [pc, #684]	; (8000958 <WriteRead.4056+0x2c8>)
 80006aa:	f003 f8a9 	bl	8003800 <spiStart>
  spiSelect(&SPID1);                   /* Slave Select assertion.          */
 80006ae:	48a9      	ldr	r0, [pc, #676]	; (8000954 <WriteRead.4056+0x2c4>)
 80006b0:	f003 f8be 	bl	8003830 <spiSelect>

  int i = size - 4;
 80006b4:	7afb      	ldrb	r3, [r7, #11]
 80006b6:	3b04      	subs	r3, #4
 80006b8:	64fb      	str	r3, [r7, #76]	; 0x4c
  int k = 1;
 80006ba:	2301      	movs	r3, #1
 80006bc:	64bb      	str	r3, [r7, #72]	; 0x48
  int m = 0;
 80006be:	2300      	movs	r3, #0
 80006c0:	647b      	str	r3, [r7, #68]	; 0x44
  int sdpointer = 0;
 80006c2:	2300      	movs	r3, #0
 80006c4:	643b      	str	r3, [r7, #64]	; 0x40
 80006c6:	e0f6      	b.n	80008b6 <WriteRead.4056+0x226>

  /* Split the message if possible */
  while (i > 0) {
    if (i > 16) { 
 80006c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80006ca:	2b10      	cmp	r3, #16
 80006cc:	dd69      	ble.n	80007a2 <WriteRead.4056+0x112>
      uint8_t tx_data[20];
      uint8_t temp;
      uint8_t rec_temp = 0xFE;
 80006ce:	23fe      	movs	r3, #254	; 0xfe
 80006d0:	74bb      	strb	r3, [r7, #18]
      i = i - 16;
 80006d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80006d4:	3b10      	subs	r3, #16
 80006d6:	64fb      	str	r3, [r7, #76]	; 0x4c
      tx_data[0] = 0x10;
 80006d8:	2310      	movs	r3, #16
 80006da:	753b      	strb	r3, [r7, #20]
 80006dc:	e018      	b.n	8000710 <WriteRead.4056+0x80>
      while(rec_temp == 0xFE) {
        temp = tx_data[0];
 80006de:	7d3b      	ldrb	r3, [r7, #20]
 80006e0:	74fb      	strb	r3, [r7, #19]
        spiExchange(&SPID1, 1, &temp, &rec_temp);
 80006e2:	f107 0213 	add.w	r2, r7, #19
 80006e6:	f107 0312 	add.w	r3, r7, #18
 80006ea:	489a      	ldr	r0, [pc, #616]	; (8000954 <WriteRead.4056+0x2c4>)
 80006ec:	2101      	movs	r1, #1
 80006ee:	f003 f8bf 	bl	8003870 <spiExchange>
        //spiSend(&SPID1, 1, &temp);
        //spiReceive(&SPID1, 1, &rec_temp);
        if(rec_temp == 0xFE) {
 80006f2:	7cbb      	ldrb	r3, [r7, #18]
 80006f4:	2bfe      	cmp	r3, #254	; 0xfe
 80006f6:	d00e      	beq.n	8000716 <WriteRead.4056+0x86>
          break;
        } else {
        chThdSleepMicroseconds(10);
 80006f8:	2001      	movs	r0, #1
 80006fa:	f005 f929 	bl	8005950 <chThdSleep>
        spiUnselect(&SPID1);                 /* Slave Select de-assertion. */
 80006fe:	4895      	ldr	r0, [pc, #596]	; (8000954 <WriteRead.4056+0x2c4>)
 8000700:	f003 f8a6 	bl	8003850 <spiUnselect>
        chThdSleepMicroseconds(100);
 8000704:	2001      	movs	r0, #1
 8000706:	f005 f923 	bl	8005950 <chThdSleep>
        spiSelect(&SPID1);
 800070a:	4892      	ldr	r0, [pc, #584]	; (8000954 <WriteRead.4056+0x2c4>)
 800070c:	f003 f890 	bl	8003830 <spiSelect>
      uint8_t tx_data[20];
      uint8_t temp;
      uint8_t rec_temp = 0xFE;
      i = i - 16;
      tx_data[0] = 0x10;
      while(rec_temp == 0xFE) {
 8000710:	7cbb      	ldrb	r3, [r7, #18]
 8000712:	2bfe      	cmp	r3, #254	; 0xfe
 8000714:	d0e3      	beq.n	80006de <WriteRead.4056+0x4e>
        spiUnselect(&SPID1);                 /* Slave Select de-assertion. */
        chThdSleepMicroseconds(100);
        spiSelect(&SPID1);
        }
      }
      tx_data[1] = 0x00;
 8000716:	2300      	movs	r3, #0
 8000718:	757b      	strb	r3, [r7, #21]
      tx_data[2] = 0x0A;
 800071a:	230a      	movs	r3, #10
 800071c:	75bb      	strb	r3, [r7, #22]
      tx_data[3] = (16|0x80);
 800071e:	2390      	movs	r3, #144	; 0x90
 8000720:	75fb      	strb	r3, [r7, #23]
      int thresh = sdpointer; //current sdpointer for counting purposes.
 8000722:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000724:	63bb      	str	r3, [r7, #56]	; 0x38
 8000726:	e011      	b.n	800074c <WriteRead.4056+0xbc>
      while (sdpointer < thresh + 16) {
        tx_data[m+4] = send_data[sdpointer+4];
 8000728:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800072a:	3304      	adds	r3, #4
 800072c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800072e:	3204      	adds	r2, #4
 8000730:	68f9      	ldr	r1, [r7, #12]
 8000732:	440a      	add	r2, r1
 8000734:	7812      	ldrb	r2, [r2, #0]
 8000736:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800073a:	440b      	add	r3, r1
 800073c:	f803 2c3c 	strb.w	r2, [r3, #-60]
        m++;
 8000740:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8000742:	3301      	adds	r3, #1
 8000744:	647b      	str	r3, [r7, #68]	; 0x44
        sdpointer++;
 8000746:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000748:	3301      	adds	r3, #1
 800074a:	643b      	str	r3, [r7, #64]	; 0x40
      }
      tx_data[1] = 0x00;
      tx_data[2] = 0x0A;
      tx_data[3] = (16|0x80);
      int thresh = sdpointer; //current sdpointer for counting purposes.
      while (sdpointer < thresh + 16) {
 800074c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800074e:	f103 0210 	add.w	r2, r3, #16
 8000752:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000754:	429a      	cmp	r2, r3
 8000756:	dce7      	bgt.n	8000728 <WriteRead.4056+0x98>
 8000758:	e00f      	b.n	800077a <WriteRead.4056+0xea>
        tx_data[m+4] = send_data[sdpointer+4];
        m++;
        sdpointer++;
      }
      while(k < 20) {
        temp = tx_data[k];
 800075a:	f107 0214 	add.w	r2, r7, #20
 800075e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000760:	4413      	add	r3, r2
 8000762:	781b      	ldrb	r3, [r3, #0]
 8000764:	74fb      	strb	r3, [r7, #19]
        spiSend(&SPID1, 1, &temp);
 8000766:	f107 0313 	add.w	r3, r7, #19
 800076a:	487a      	ldr	r0, [pc, #488]	; (8000954 <WriteRead.4056+0x2c4>)
 800076c:	2101      	movs	r1, #1
 800076e:	461a      	mov	r2, r3
 8000770:	f003 f89e 	bl	80038b0 <spiSend>
        k++;    
 8000774:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000776:	3301      	adds	r3, #1
 8000778:	64bb      	str	r3, [r7, #72]	; 0x48
      while (sdpointer < thresh + 16) {
        tx_data[m+4] = send_data[sdpointer+4];
        m++;
        sdpointer++;
      }
      while(k < 20) {
 800077a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800077c:	2b13      	cmp	r3, #19
 800077e:	ddec      	ble.n	800075a <WriteRead.4056+0xca>
        temp = tx_data[k];
        spiSend(&SPID1, 1, &temp);
        k++;    
      }
      k = 1;
 8000780:	2301      	movs	r3, #1
 8000782:	64bb      	str	r3, [r7, #72]	; 0x48
      m = 0;
 8000784:	2300      	movs	r3, #0
 8000786:	647b      	str	r3, [r7, #68]	; 0x44
      chThdSleepMicroseconds(20);
 8000788:	2001      	movs	r0, #1
 800078a:	f005 f8e1 	bl	8005950 <chThdSleep>
      spiUnselect(&SPID1);                 /* Slave Select de-assertion. */
 800078e:	4871      	ldr	r0, [pc, #452]	; (8000954 <WriteRead.4056+0x2c4>)
 8000790:	f003 f85e 	bl	8003850 <spiUnselect>
      chThdSleepMilliseconds(3);
 8000794:	201e      	movs	r0, #30
 8000796:	f005 f8db 	bl	8005950 <chThdSleep>
      spiSelect(&SPID1);
 800079a:	486e      	ldr	r0, [pc, #440]	; (8000954 <WriteRead.4056+0x2c4>)
 800079c:	f003 f848 	bl	8003830 <spiSelect>
 80007a0:	e089      	b.n	80008b6 <WriteRead.4056+0x226>
 80007a2:	466b      	mov	r3, sp
 80007a4:	461e      	mov	r6, r3
    } else {
      uint8_t tx_data[i+4];
 80007a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80007a8:	1d19      	adds	r1, r3, #4
 80007aa:	1e4b      	subs	r3, r1, #1
 80007ac:	637b      	str	r3, [r7, #52]	; 0x34
 80007ae:	460b      	mov	r3, r1
 80007b0:	461a      	mov	r2, r3
 80007b2:	f04f 0300 	mov.w	r3, #0
 80007b6:	00dd      	lsls	r5, r3, #3
 80007b8:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 80007bc:	00d4      	lsls	r4, r2, #3
 80007be:	460b      	mov	r3, r1
 80007c0:	461a      	mov	r2, r3
 80007c2:	f04f 0300 	mov.w	r3, #0
 80007c6:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 80007ca:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
 80007ce:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 80007d2:	460b      	mov	r3, r1
 80007d4:	3307      	adds	r3, #7
 80007d6:	08db      	lsrs	r3, r3, #3
 80007d8:	00db      	lsls	r3, r3, #3
 80007da:	ebad 0d03 	sub.w	sp, sp, r3
 80007de:	466b      	mov	r3, sp
 80007e0:	3300      	adds	r3, #0
 80007e2:	633b      	str	r3, [r7, #48]	; 0x30
      uint8_t temp;
      uint8_t rec_temp = 0xFE;
 80007e4:	23fe      	movs	r3, #254	; 0xfe
 80007e6:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
      tx_data[0] = 0x10;
 80007ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80007ec:	2210      	movs	r2, #16
 80007ee:	701a      	strb	r2, [r3, #0]
 80007f0:	e01b      	b.n	800082a <WriteRead.4056+0x19a>
      while(rec_temp == 0xFE) {
        temp = tx_data[0];
 80007f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80007f4:	781b      	ldrb	r3, [r3, #0]
 80007f6:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        spiExchange(&SPID1, 1, &temp, &rec_temp);
 80007fa:	f107 022a 	add.w	r2, r7, #42	; 0x2a
 80007fe:	f107 0329 	add.w	r3, r7, #41	; 0x29
 8000802:	4854      	ldr	r0, [pc, #336]	; (8000954 <WriteRead.4056+0x2c4>)
 8000804:	2101      	movs	r1, #1
 8000806:	f003 f833 	bl	8003870 <spiExchange>
        //spiSend(&SPID1, 1, &temp);
        //spiReceive(&SPID1, 1, &rec_temp);
        if(rec_temp == 0xFE) {
 800080a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800080e:	2bfe      	cmp	r3, #254	; 0xfe
 8000810:	d00f      	beq.n	8000832 <WriteRead.4056+0x1a2>
          break;
        } else {
          chThdSleepMicroseconds(10);
 8000812:	2001      	movs	r0, #1
 8000814:	f005 f89c 	bl	8005950 <chThdSleep>
          spiUnselect(&SPID1);                 /* Slave Select de-assertion. */
 8000818:	484e      	ldr	r0, [pc, #312]	; (8000954 <WriteRead.4056+0x2c4>)
 800081a:	f003 f819 	bl	8003850 <spiUnselect>
          chThdSleepMicroseconds(100);
 800081e:	2001      	movs	r0, #1
 8000820:	f005 f896 	bl	8005950 <chThdSleep>
          spiSelect(&SPID1);
 8000824:	484b      	ldr	r0, [pc, #300]	; (8000954 <WriteRead.4056+0x2c4>)
 8000826:	f003 f803 	bl	8003830 <spiSelect>
    } else {
      uint8_t tx_data[i+4];
      uint8_t temp;
      uint8_t rec_temp = 0xFE;
      tx_data[0] = 0x10;
      while(rec_temp == 0xFE) {
 800082a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800082e:	2bfe      	cmp	r3, #254	; 0xfe
 8000830:	d0df      	beq.n	80007f2 <WriteRead.4056+0x162>
          spiUnselect(&SPID1);                 /* Slave Select de-assertion. */
          chThdSleepMicroseconds(100);
          spiSelect(&SPID1);
        }
      }
      tx_data[1] = 0x00;
 8000832:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000834:	2200      	movs	r2, #0
 8000836:	705a      	strb	r2, [r3, #1]
      tx_data[2] = 0x0A;
 8000838:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800083a:	220a      	movs	r2, #10
 800083c:	709a      	strb	r2, [r3, #2]
      tx_data[3] = i;
 800083e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8000840:	b2da      	uxtb	r2, r3
 8000842:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000844:	70da      	strb	r2, [r3, #3]
      int thresh = sdpointer;
 8000846:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000848:	62fb      	str	r3, [r7, #44]	; 0x2c
 800084a:	e00e      	b.n	800086a <WriteRead.4056+0x1da>

      while (sdpointer < thresh + i) {
        tx_data[m+4] = send_data[sdpointer+4];
 800084c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800084e:	3304      	adds	r3, #4
 8000850:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8000852:	3204      	adds	r2, #4
 8000854:	68f9      	ldr	r1, [r7, #12]
 8000856:	440a      	add	r2, r1
 8000858:	7811      	ldrb	r1, [r2, #0]
 800085a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800085c:	54d1      	strb	r1, [r2, r3]
        m++;
 800085e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8000860:	3301      	adds	r3, #1
 8000862:	647b      	str	r3, [r7, #68]	; 0x44
        sdpointer++;
 8000864:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000866:	3301      	adds	r3, #1
 8000868:	643b      	str	r3, [r7, #64]	; 0x40
      tx_data[1] = 0x00;
      tx_data[2] = 0x0A;
      tx_data[3] = i;
      int thresh = sdpointer;

      while (sdpointer < thresh + i) {
 800086a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800086c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800086e:	441a      	add	r2, r3
 8000870:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000872:	429a      	cmp	r2, r3
 8000874:	dcea      	bgt.n	800084c <WriteRead.4056+0x1bc>
 8000876:	e00f      	b.n	8000898 <WriteRead.4056+0x208>
        m++;
        sdpointer++;
      }

      while(k < i+4) {
        temp = tx_data[k];
 8000878:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800087a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800087c:	4413      	add	r3, r2
 800087e:	781b      	ldrb	r3, [r3, #0]
 8000880:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        spiSend(&SPID1, 1, &temp);
 8000884:	f107 032a 	add.w	r3, r7, #42	; 0x2a
 8000888:	4832      	ldr	r0, [pc, #200]	; (8000954 <WriteRead.4056+0x2c4>)
 800088a:	2101      	movs	r1, #1
 800088c:	461a      	mov	r2, r3
 800088e:	f003 f80f 	bl	80038b0 <spiSend>
        k++;
 8000892:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000894:	3301      	adds	r3, #1
 8000896:	64bb      	str	r3, [r7, #72]	; 0x48
        tx_data[m+4] = send_data[sdpointer+4];
        m++;
        sdpointer++;
      }

      while(k < i+4) {
 8000898:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800089a:	1d1a      	adds	r2, r3, #4
 800089c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800089e:	429a      	cmp	r2, r3
 80008a0:	dcea      	bgt.n	8000878 <WriteRead.4056+0x1e8>
        temp = tx_data[k];
        spiSend(&SPID1, 1, &temp);
        k++;
      }
      k = 1;
 80008a2:	2301      	movs	r3, #1
 80008a4:	64bb      	str	r3, [r7, #72]	; 0x48
      m = 0;
 80008a6:	2300      	movs	r3, #0
 80008a8:	647b      	str	r3, [r7, #68]	; 0x44
      sdpointer = 0;
 80008aa:	2300      	movs	r3, #0
 80008ac:	643b      	str	r3, [r7, #64]	; 0x40
      i = -2;
 80008ae:	f06f 0301 	mvn.w	r3, #1
 80008b2:	64fb      	str	r3, [r7, #76]	; 0x4c
 80008b4:	46b5      	mov	sp, r6
  int k = 1;
  int m = 0;
  int sdpointer = 0;

  /* Split the message if possible */
  while (i > 0) {
 80008b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80008b8:	2b00      	cmp	r3, #0
 80008ba:	f73f af05 	bgt.w	80006c8 <WriteRead.4056+0x38>
      sdpointer = 0;
      i = -2;
    }
  }

  spiUnselect(&SPID1);                 /* Slave Select de-assertion.       */
 80008be:	4825      	ldr	r0, [pc, #148]	; (8000954 <WriteRead.4056+0x2c4>)
 80008c0:	f002 ffc6 	bl	8003850 <spiUnselect>

  chThdSleepMilliseconds(3);
 80008c4:	201e      	movs	r0, #30
 80008c6:	f005 f843 	bl	8005950 <chThdSleep>
  
  spiSelect(&SPID1);                  /* Slave Select assertion.          */
 80008ca:	4822      	ldr	r0, [pc, #136]	; (8000954 <WriteRead.4056+0x2c4>)
 80008cc:	f002 ffb0 	bl	8003830 <spiSelect>

  int j = 0;
 80008d0:	2300      	movs	r3, #0
 80008d2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80008d4:	e019      	b.n	800090a <WriteRead.4056+0x27a>
  uint8_t recSize;
  while(j == 0) {
    spiReceive(&SPID1, 1, receive_data);
 80008d6:	481f      	ldr	r0, [pc, #124]	; (8000954 <WriteRead.4056+0x2c4>)
 80008d8:	2101      	movs	r1, #1
 80008da:	687a      	ldr	r2, [r7, #4]
 80008dc:	f003 f808 	bl	80038f0 <spiReceive>
    if (((receive_data[0] == 0x10) ||
 80008e0:	687b      	ldr	r3, [r7, #4]
 80008e2:	781b      	ldrb	r3, [r3, #0]
 80008e4:	2b10      	cmp	r3, #16
 80008e6:	d00b      	beq.n	8000900 <WriteRead.4056+0x270>
      (receive_data[0] == 0x20) ||
 80008e8:	687b      	ldr	r3, [r7, #4]
 80008ea:	781b      	ldrb	r3, [r3, #0]

  int j = 0;
  uint8_t recSize;
  while(j == 0) {
    spiReceive(&SPID1, 1, receive_data);
    if (((receive_data[0] == 0x10) ||
 80008ec:	2b20      	cmp	r3, #32
 80008ee:	d007      	beq.n	8000900 <WriteRead.4056+0x270>
      (receive_data[0] == 0x20) ||
      (receive_data[0] == 0x40) ||
 80008f0:	687b      	ldr	r3, [r7, #4]
 80008f2:	781b      	ldrb	r3, [r3, #0]
  int j = 0;
  uint8_t recSize;
  while(j == 0) {
    spiReceive(&SPID1, 1, receive_data);
    if (((receive_data[0] == 0x10) ||
      (receive_data[0] == 0x20) ||
 80008f4:	2b40      	cmp	r3, #64	; 0x40
 80008f6:	d003      	beq.n	8000900 <WriteRead.4056+0x270>
      (receive_data[0] == 0x40) ||
      (receive_data[0] == 0x80))) {
 80008f8:	687b      	ldr	r3, [r7, #4]
 80008fa:	781b      	ldrb	r3, [r3, #0]
  uint8_t recSize;
  while(j == 0) {
    spiReceive(&SPID1, 1, receive_data);
    if (((receive_data[0] == 0x10) ||
      (receive_data[0] == 0x20) ||
      (receive_data[0] == 0x40) ||
 80008fc:	2b80      	cmp	r3, #128	; 0x80
 80008fe:	d104      	bne.n	800090a <WriteRead.4056+0x27a>
      (receive_data[0] == 0x80))) {
        receive_data++;
 8000900:	687b      	ldr	r3, [r7, #4]
 8000902:	3301      	adds	r3, #1
 8000904:	607b      	str	r3, [r7, #4]
        j = 1;
 8000906:	2301      	movs	r3, #1
 8000908:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  spiSelect(&SPID1);                  /* Slave Select assertion.          */

  int j = 0;
  uint8_t recSize;
  while(j == 0) {
 800090a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800090c:	2b00      	cmp	r3, #0
 800090e:	d0e2      	beq.n	80008d6 <WriteRead.4056+0x246>
      (receive_data[0] == 0x80))) {
        receive_data++;
        j = 1;
      } 
  }
  spiReceive(&SPID1, 1, receive_data);
 8000910:	4810      	ldr	r0, [pc, #64]	; (8000954 <WriteRead.4056+0x2c4>)
 8000912:	2101      	movs	r1, #1
 8000914:	687a      	ldr	r2, [r7, #4]
 8000916:	f002 ffeb 	bl	80038f0 <spiReceive>
  receive_data++;
 800091a:	687b      	ldr	r3, [r7, #4]
 800091c:	3301      	adds	r3, #1
 800091e:	607b      	str	r3, [r7, #4]
  spiReceive(&SPID1, 1, receive_data);
 8000920:	480c      	ldr	r0, [pc, #48]	; (8000954 <WriteRead.4056+0x2c4>)
 8000922:	2101      	movs	r1, #1
 8000924:	687a      	ldr	r2, [r7, #4]
 8000926:	f002 ffe3 	bl	80038f0 <spiReceive>
  receive_data++;
 800092a:	687b      	ldr	r3, [r7, #4]
 800092c:	3301      	adds	r3, #1
 800092e:	607b      	str	r3, [r7, #4]
  spiReceive(&SPID1, 1, &recSize);
 8000930:	f107 032b 	add.w	r3, r7, #43	; 0x2b
 8000934:	4807      	ldr	r0, [pc, #28]	; (8000954 <WriteRead.4056+0x2c4>)
 8000936:	2101      	movs	r1, #1
 8000938:	461a      	mov	r2, r3
 800093a:	f002 ffd9 	bl	80038f0 <spiReceive>
  receive_data[3] = recSize;
 800093e:	687b      	ldr	r3, [r7, #4]
 8000940:	3303      	adds	r3, #3
 8000942:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8000946:	701a      	strb	r2, [r3, #0]
  receive_data++;
 8000948:	687b      	ldr	r3, [r7, #4]
 800094a:	3301      	adds	r3, #1
 800094c:	607b      	str	r3, [r7, #4]
  i = 0;
 800094e:	2300      	movs	r3, #0
 8000950:	64fb      	str	r3, [r7, #76]	; 0x4c
 8000952:	e00e      	b.n	8000972 <WriteRead.4056+0x2e2>
 8000954:	20000b3c 	.word	0x20000b3c
 8000958:	20000940 	.word	0x20000940
  while(i < recSize) {
    spiReceive(&SPID1, 1, receive_data);
 800095c:	480d      	ldr	r0, [pc, #52]	; (8000994 <WriteRead.4056+0x304>)
 800095e:	2101      	movs	r1, #1
 8000960:	687a      	ldr	r2, [r7, #4]
 8000962:	f002 ffc5 	bl	80038f0 <spiReceive>
    receive_data++;
 8000966:	687b      	ldr	r3, [r7, #4]
 8000968:	3301      	adds	r3, #1
 800096a:	607b      	str	r3, [r7, #4]
    i++;
 800096c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800096e:	3301      	adds	r3, #1
 8000970:	64fb      	str	r3, [r7, #76]	; 0x4c
  receive_data++;
  spiReceive(&SPID1, 1, &recSize);
  receive_data[3] = recSize;
  receive_data++;
  i = 0;
  while(i < recSize) {
 8000972:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8000976:	461a      	mov	r2, r3
 8000978:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800097a:	429a      	cmp	r2, r3
 800097c:	dcee      	bgt.n	800095c <WriteRead.4056+0x2cc>
    spiReceive(&SPID1, 1, receive_data);
    receive_data++;
    i++;
  }
  spiUnselect(&SPID1);                 /* Slave Select de-assertion.       */
 800097e:	4805      	ldr	r0, [pc, #20]	; (8000994 <WriteRead.4056+0x304>)
 8000980:	f002 ff66 	bl	8003850 <spiUnselect>
  spiReleaseBus(&SPID1);               /* Ownership release.               */
 8000984:	4803      	ldr	r0, [pc, #12]	; (8000994 <WriteRead.4056+0x304>)
 8000986:	f002 ffe3 	bl	8003950 <spiReleaseBus>
}
 800098a:	3754      	adds	r7, #84	; 0x54
 800098c:	46bd      	mov	sp, r7
 800098e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000992:	bf00      	nop
 8000994:	20000b3c 	.word	0x20000b3c
 8000998:	f3af 8000 	nop.w
 800099c:	f3af 8000 	nop.w

080009a0 <counterThread.13434.4019>:

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 80009a0:	b500      	push	{lr}
 80009a2:	b083      	sub	sp, #12
 80009a4:	9001      	str	r0, [sp, #4]
   UNUSED(arg);
   while (TRUE) {
     palSetPad(GPIOE, GPIOE_LED3_RED);
 80009a6:	4b08      	ldr	r3, [pc, #32]	; (80009c8 <counterThread.13434.4019+0x28>)
 80009a8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80009ac:	831a      	strh	r2, [r3, #24]
     chThdSleepMilliseconds(500);
 80009ae:	f241 3088 	movw	r0, #5000	; 0x1388
 80009b2:	f004 ffcd 	bl	8005950 <chThdSleep>
     palClearPad(GPIOE, GPIOE_LED3_RED);
 80009b6:	4b04      	ldr	r3, [pc, #16]	; (80009c8 <counterThread.13434.4019+0x28>)
 80009b8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80009bc:	835a      	strh	r2, [r3, #26]
     chThdSleepMilliseconds(500);
 80009be:	f241 3088 	movw	r0, #5000	; 0x1388
 80009c2:	f004 ffc5 	bl	8005950 <chThdSleep>
 80009c6:	e7ee      	b.n	80009a6 <counterThread.13434.4019+0x6>
 80009c8:	48001000 	.word	0x48001000
 80009cc:	f3af 8000 	nop.w

080009d0 <bigDataThread.13485.4016>:
//   }
// }


static THD_WORKING_AREA(waBigDataThread,256);
static THD_FUNCTION(bigDataThread,arg) {
 80009d0:	b500      	push	{lr}
 80009d2:	b093      	sub	sp, #76	; 0x4c
 80009d4:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chThdSleepMicroseconds(1);
 80009d6:	2001      	movs	r0, #1
 80009d8:	f004 ffba 	bl	8005950 <chThdSleep>
 80009dc:	e037      	b.n	8000a4e <bigDataThread.13485.4016+0x7e>
  uint8_t tmp_data[20];
  // chprintf((BaseSequentialStream*)&SD1, "bigDataThreadNowRunning\r\n");

  while(TRUE) {
    while (!connectedFLAG) {
      chThdSleepMilliseconds(500);
 80009de:	f241 3088 	movw	r0, #5000	; 0x1388
 80009e2:	f004 ffb5 	bl	8005950 <chThdSleep>
      WriteRead(tx_advstart, 22, tmp_data);
 80009e6:	ab03      	add	r3, sp, #12
 80009e8:	482d      	ldr	r0, [pc, #180]	; (8000aa0 <bigDataThread.13485.4016+0xd0>)
 80009ea:	2116      	movs	r1, #22
 80009ec:	461a      	mov	r2, r3
 80009ee:	f7ff fe4f 	bl	8000690 <WriteRead.4056>
      chprintf((BaseSequentialStream*)&SD1, "Advertising Started\r\n");
 80009f2:	482c      	ldr	r0, [pc, #176]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 80009f4:	492c      	ldr	r1, [pc, #176]	; (8000aa8 <bigDataThread.13485.4016+0xd8>)
 80009f6:	f000 fd0b 	bl	8001410 <chprintf>
      chThdSleepMilliseconds(10000);
 80009fa:	482c      	ldr	r0, [pc, #176]	; (8000aac <bigDataThread.13485.4016+0xdc>)
 80009fc:	f004 ffa8 	bl	8005950 <chThdSleep>
      WriteRead(tx_getconn, 21, rx_data);
 8000a00:	ab08      	add	r3, sp, #32
 8000a02:	482b      	ldr	r0, [pc, #172]	; (8000ab0 <bigDataThread.13485.4016+0xe0>)
 8000a04:	2115      	movs	r1, #21
 8000a06:	461a      	mov	r2, r3
 8000a08:	f7ff fe42 	bl	8000690 <WriteRead.4056>
      if (rx_data[4] == '1') { //Pump Data if we're here
 8000a0c:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 8000a10:	2b31      	cmp	r3, #49	; 0x31
 8000a12:	d107      	bne.n	8000a24 <bigDataThread.13485.4016+0x54>
        chprintf((BaseSequentialStream*)&SD1, "Connected\r\n");
 8000a14:	4823      	ldr	r0, [pc, #140]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 8000a16:	4927      	ldr	r1, [pc, #156]	; (8000ab4 <bigDataThread.13485.4016+0xe4>)
 8000a18:	f000 fcfa 	bl	8001410 <chprintf>
        connectedFLAG = 1;
 8000a1c:	4b26      	ldr	r3, [pc, #152]	; (8000ab8 <bigDataThread.13485.4016+0xe8>)
 8000a1e:	2201      	movs	r2, #1
 8000a20:	601a      	str	r2, [r3, #0]
 8000a22:	e018      	b.n	8000a56 <bigDataThread.13485.4016+0x86>
        break;
      } else {
        chprintf((BaseSequentialStream*)&SD1, "No connection, Advertising Stopped\r\n");
 8000a24:	481f      	ldr	r0, [pc, #124]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 8000a26:	4925      	ldr	r1, [pc, #148]	; (8000abc <bigDataThread.13485.4016+0xec>)
 8000a28:	f000 fcf2 	bl	8001410 <chprintf>
        WriteRead(tx_advstop, 21, tmp_data);
 8000a2c:	ab03      	add	r3, sp, #12
 8000a2e:	4824      	ldr	r0, [pc, #144]	; (8000ac0 <bigDataThread.13485.4016+0xf0>)
 8000a30:	2115      	movs	r1, #21
 8000a32:	461a      	mov	r2, r3
 8000a34:	f7ff fe2c 	bl	8000690 <WriteRead.4056>
        connectedFLAG = 0;
 8000a38:	4b1f      	ldr	r3, [pc, #124]	; (8000ab8 <bigDataThread.13485.4016+0xe8>)
 8000a3a:	2200      	movs	r2, #0
 8000a3c:	601a      	str	r2, [r3, #0]
      }
      chprintf((BaseSequentialStream*)&SD1, "Shutting off\r\n");
 8000a3e:	4819      	ldr	r0, [pc, #100]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 8000a40:	4920      	ldr	r1, [pc, #128]	; (8000ac4 <bigDataThread.13485.4016+0xf4>)
 8000a42:	f000 fce5 	bl	8001410 <chprintf>
      chThdSleepMilliseconds(5000);
 8000a46:	f24c 3050 	movw	r0, #50000	; 0xc350
 8000a4a:	f004 ff81 	bl	8005950 <chThdSleep>
  uint8_t rx_data[20];
  uint8_t tmp_data[20];
  // chprintf((BaseSequentialStream*)&SD1, "bigDataThreadNowRunning\r\n");

  while(TRUE) {
    while (!connectedFLAG) {
 8000a4e:	4b1a      	ldr	r3, [pc, #104]	; (8000ab8 <bigDataThread.13485.4016+0xe8>)
 8000a50:	681b      	ldr	r3, [r3, #0]
 8000a52:	2b00      	cmp	r3, #0
 8000a54:	d0c3      	beq.n	80009de <bigDataThread.13485.4016+0xe>
        connectedFLAG = 0;
      }
      chprintf((BaseSequentialStream*)&SD1, "Shutting off\r\n");
      chThdSleepMilliseconds(5000);
    }
    if (connectedFLAG) {
 8000a56:	4b18      	ldr	r3, [pc, #96]	; (8000ab8 <bigDataThread.13485.4016+0xe8>)
 8000a58:	681b      	ldr	r3, [r3, #0]
 8000a5a:	2b00      	cmp	r3, #0
 8000a5c:	d01b      	beq.n	8000a96 <bigDataThread.13485.4016+0xc6>
      WriteReadWrapper(bigData, 4096);
 8000a5e:	481a      	ldr	r0, [pc, #104]	; (8000ac8 <bigDataThread.13485.4016+0xf8>)
 8000a60:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000a64:	f7ff fd9c 	bl	80005a0 <WriteReadWrapper.4061>
      chprintf((BaseSequentialStream*)&SD1, "BigData Sent\r\n");
 8000a68:	480e      	ldr	r0, [pc, #56]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 8000a6a:	4918      	ldr	r1, [pc, #96]	; (8000acc <bigDataThread.13485.4016+0xfc>)
 8000a6c:	f000 fcd0 	bl	8001410 <chprintf>
      chThdSleepMilliseconds(20000);
 8000a70:	4817      	ldr	r0, [pc, #92]	; (8000ad0 <bigDataThread.13485.4016+0x100>)
 8000a72:	f004 ff6d 	bl	8005950 <chThdSleep>
      WriteRead(tx_disconnect, 20, rx_tmp_data);
 8000a76:	ab0d      	add	r3, sp, #52	; 0x34
 8000a78:	4816      	ldr	r0, [pc, #88]	; (8000ad4 <bigDataThread.13485.4016+0x104>)
 8000a7a:	2114      	movs	r1, #20
 8000a7c:	461a      	mov	r2, r3
 8000a7e:	f7ff fe07 	bl	8000690 <WriteRead.4056>
      chprintf((BaseSequentialStream*)&SD1, "Disconnect Sent\r\n");
 8000a82:	4808      	ldr	r0, [pc, #32]	; (8000aa4 <bigDataThread.13485.4016+0xd4>)
 8000a84:	4914      	ldr	r1, [pc, #80]	; (8000ad8 <bigDataThread.13485.4016+0x108>)
 8000a86:	f000 fcc3 	bl	8001410 <chprintf>
      connectedFLAG = 0;
 8000a8a:	4b0b      	ldr	r3, [pc, #44]	; (8000ab8 <bigDataThread.13485.4016+0xe8>)
 8000a8c:	2200      	movs	r2, #0
 8000a8e:	601a      	str	r2, [r3, #0]
      chThdSleepMilliseconds(10000);
 8000a90:	4806      	ldr	r0, [pc, #24]	; (8000aac <bigDataThread.13485.4016+0xdc>)
 8000a92:	f004 ff5d 	bl	8005950 <chThdSleep>
    }
    chThdSleepMilliseconds(1000);
 8000a96:	f242 7010 	movw	r0, #10000	; 0x2710
 8000a9a:	f004 ff59 	bl	8005950 <chThdSleep>
 8000a9e:	e7d6      	b.n	8000a4e <bigDataThread.13485.4016+0x7e>
 8000aa0:	20000820 	.word	0x20000820
 8000aa4:	20000ba8 	.word	0x20000ba8
 8000aa8:	08006150 	.word	0x08006150
 8000aac:	000186a0 	.word	0x000186a0
 8000ab0:	20000848 	.word	0x20000848
 8000ab4:	08006168 	.word	0x08006168
 8000ab8:	20001c40 	.word	0x20001c40
 8000abc:	08006174 	.word	0x08006174
 8000ac0:	20000834 	.word	0x20000834
 8000ac4:	0800619c 	.word	0x0800619c
 8000ac8:	20000c40 	.word	0x20000c40
 8000acc:	080061ac 	.word	0x080061ac
 8000ad0:	00030d40 	.word	0x00030d40
 8000ad4:	2000085c 	.word	0x2000085c
 8000ad8:	080061bc 	.word	0x080061bc
 8000adc:	f3af 8000 	nop.w

08000ae0 <cmd_bluefruit.13488.4051>:
  }
  chThdSleepMilliseconds(100);
}

static void cmd_bluefruit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8000ae0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000ae4:	b095      	sub	sp, #84	; 0x54
 8000ae6:	af00      	add	r7, sp, #0
 8000ae8:	6178      	str	r0, [r7, #20]
 8000aea:	6139      	str	r1, [r7, #16]
 8000aec:	60fa      	str	r2, [r7, #12]
  UNUSED(argc);
  if(!strcmp("cmd", argv[0])) {
 8000aee:	68fb      	ldr	r3, [r7, #12]
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	4878      	ldr	r0, [pc, #480]	; (8000cd4 <cmd_bluefruit.13488.4051+0x1f4>)
 8000af4:	4619      	mov	r1, r3
 8000af6:	f7ff fc0b 	bl	8000310 <strcmp>
 8000afa:	4603      	mov	r3, r0
 8000afc:	2b00      	cmp	r3, #0
 8000afe:	f040 80e4 	bne.w	8000cca <cmd_bluefruit.13488.4051+0x1ea>
    uint16_t payloadSize = 0;
 8000b02:	2300      	movs	r3, #0
 8000b04:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    
    uint8_t n = 0;
 8000b08:	2300      	movs	r3, #0
 8000b0a:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
 8000b0e:	e004      	b.n	8000b1a <cmd_bluefruit.13488.4051+0x3a>

    /* Scan the message, gather size, and fill the message payload */
    while (argv[1][payloadSize] != '\0') {
      payloadSize++;
 8000b10:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8000b14:	3301      	adds	r3, #1
 8000b16:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    uint16_t payloadSize = 0;
    
    uint8_t n = 0;

    /* Scan the message, gather size, and fill the message payload */
    while (argv[1][payloadSize] != '\0') {
 8000b1a:	68fb      	ldr	r3, [r7, #12]
 8000b1c:	3304      	adds	r3, #4
 8000b1e:	681a      	ldr	r2, [r3, #0]
 8000b20:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8000b24:	4413      	add	r3, r2
 8000b26:	781b      	ldrb	r3, [r3, #0]
 8000b28:	2b00      	cmp	r3, #0
 8000b2a:	d1f1      	bne.n	8000b10 <cmd_bluefruit.13488.4051+0x30>
      payloadSize++;
    }

    uint8_t payload[payloadSize];
 8000b2c:	f8b7 104e 	ldrh.w	r1, [r7, #78]	; 0x4e
 8000b30:	466b      	mov	r3, sp
 8000b32:	461e      	mov	r6, r3
 8000b34:	460b      	mov	r3, r1
 8000b36:	3b01      	subs	r3, #1
 8000b38:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000b3a:	b28a      	uxth	r2, r1
 8000b3c:	f04f 0300 	mov.w	r3, #0
 8000b40:	00d8      	lsls	r0, r3, #3
 8000b42:	6078      	str	r0, [r7, #4]
 8000b44:	6878      	ldr	r0, [r7, #4]
 8000b46:	ea40 7052 	orr.w	r0, r0, r2, lsr #29
 8000b4a:	6078      	str	r0, [r7, #4]
 8000b4c:	00d0      	lsls	r0, r2, #3
 8000b4e:	b28a      	uxth	r2, r1
 8000b50:	f04f 0300 	mov.w	r3, #0
 8000b54:	ea4f 0bc3 	mov.w	fp, r3, lsl #3
 8000b58:	ea4b 7b52 	orr.w	fp, fp, r2, lsr #29
 8000b5c:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 8000b60:	460b      	mov	r3, r1
 8000b62:	3307      	adds	r3, #7
 8000b64:	08db      	lsrs	r3, r3, #3
 8000b66:	00db      	lsls	r3, r3, #3
 8000b68:	ebad 0d03 	sub.w	sp, sp, r3
 8000b6c:	466b      	mov	r3, sp
 8000b6e:	3300      	adds	r3, #0
 8000b70:	63bb      	str	r3, [r7, #56]	; 0x38

    for(n = 0; n < payloadSize; n++) {
 8000b72:	2300      	movs	r3, #0
 8000b74:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
 8000b78:	e00f      	b.n	8000b9a <cmd_bluefruit.13488.4051+0xba>
      payload[n] = (uint8_t)argv[1][n];
 8000b7a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 8000b7e:	68fa      	ldr	r2, [r7, #12]
 8000b80:	3204      	adds	r2, #4
 8000b82:	6811      	ldr	r1, [r2, #0]
 8000b84:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 8000b88:	440a      	add	r2, r1
 8000b8a:	7811      	ldrb	r1, [r2, #0]
 8000b8c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8000b8e:	54d1      	strb	r1, [r2, r3]
      payloadSize++;
    }

    uint8_t payload[payloadSize];

    for(n = 0; n < payloadSize; n++) {
 8000b90:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 8000b94:	3301      	adds	r3, #1
 8000b96:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
 8000b9a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 8000b9e:	b29b      	uxth	r3, r3
 8000ba0:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8000ba4:	429a      	cmp	r2, r3
 8000ba6:	d8e8      	bhi.n	8000b7a <cmd_bluefruit.13488.4051+0x9a>
      payload[n] = (uint8_t)argv[1][n];
    }

    /* Initialize send/receive messages */
    uint8_t messageSize = payloadSize + headerSize + 1;
 8000ba8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8000bac:	b2da      	uxtb	r2, r3
 8000bae:	4b4a      	ldr	r3, [pc, #296]	; (8000cd8 <cmd_bluefruit.13488.4051+0x1f8>)
 8000bb0:	781b      	ldrb	r3, [r3, #0]
 8000bb2:	4413      	add	r3, r2
 8000bb4:	b2db      	uxtb	r3, r3
 8000bb6:	3301      	adds	r3, #1
 8000bb8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint8_t tx_data[messageSize];
 8000bbc:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 8000bc0:	466b      	mov	r3, sp
 8000bc2:	469a      	mov	sl, r3
 8000bc4:	460b      	mov	r3, r1
 8000bc6:	3b01      	subs	r3, #1
 8000bc8:	633b      	str	r3, [r7, #48]	; 0x30
 8000bca:	b2ca      	uxtb	r2, r1
 8000bcc:	f04f 0300 	mov.w	r3, #0
 8000bd0:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8000bd4:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
 8000bd8:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 8000bdc:	b2ca      	uxtb	r2, r1
 8000bde:	f04f 0300 	mov.w	r3, #0
 8000be2:	00dd      	lsls	r5, r3, #3
 8000be4:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 8000be8:	00d4      	lsls	r4, r2, #3
 8000bea:	460b      	mov	r3, r1
 8000bec:	3307      	adds	r3, #7
 8000bee:	08db      	lsrs	r3, r3, #3
 8000bf0:	00db      	lsls	r3, r3, #3
 8000bf2:	ebad 0d03 	sub.w	sp, sp, r3
 8000bf6:	466b      	mov	r3, sp
 8000bf8:	3300      	adds	r3, #0
 8000bfa:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint8_t rx_data[20];

    /* Begin creating message */
    int messageIndex = 0;
 8000bfc:	2300      	movs	r3, #0
 8000bfe:	64bb      	str	r3, [r7, #72]	; 0x48
    int payloadIndex = 0;
 8000c00:	2300      	movs	r3, #0
 8000c02:	647b      	str	r3, [r7, #68]	; 0x44
 8000c04:	e00a      	b.n	8000c1c <cmd_bluefruit.13488.4051+0x13c>

    /* Header */
    while (messageIndex < headerSize) { 
      tx_data[messageIndex] = header[messageIndex];
 8000c06:	4a35      	ldr	r2, [pc, #212]	; (8000cdc <cmd_bluefruit.13488.4051+0x1fc>)
 8000c08:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c0a:	4413      	add	r3, r2
 8000c0c:	781a      	ldrb	r2, [r3, #0]
 8000c0e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8000c10:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c12:	440b      	add	r3, r1
 8000c14:	701a      	strb	r2, [r3, #0]
      messageIndex++;
 8000c16:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c18:	3301      	adds	r3, #1
 8000c1a:	64bb      	str	r3, [r7, #72]	; 0x48
    /* Begin creating message */
    int messageIndex = 0;
    int payloadIndex = 0;

    /* Header */
    while (messageIndex < headerSize) { 
 8000c1c:	4b2e      	ldr	r3, [pc, #184]	; (8000cd8 <cmd_bluefruit.13488.4051+0x1f8>)
 8000c1e:	781b      	ldrb	r3, [r3, #0]
 8000c20:	461a      	mov	r2, r3
 8000c22:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c24:	429a      	cmp	r2, r3
 8000c26:	dcee      	bgt.n	8000c06 <cmd_bluefruit.13488.4051+0x126>
      tx_data[messageIndex] = header[messageIndex];
      messageIndex++;
    }

    /* Payload Size */
    tx_data[messageIndex] = payloadSize;
 8000c28:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8000c2c:	b2da      	uxtb	r2, r3
 8000c2e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8000c30:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c32:	440b      	add	r3, r1
 8000c34:	701a      	strb	r2, [r3, #0]
    messageIndex++;
 8000c36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c38:	3301      	adds	r3, #1
 8000c3a:	64bb      	str	r3, [r7, #72]	; 0x48
 8000c3c:	e00d      	b.n	8000c5a <cmd_bluefruit.13488.4051+0x17a>
    
    /* Payload */
    while (messageIndex < messageSize) {
      tx_data[messageIndex] = payload[payloadIndex];
 8000c3e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8000c40:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8000c42:	4413      	add	r3, r2
 8000c44:	781a      	ldrb	r2, [r3, #0]
 8000c46:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8000c48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c4a:	440b      	add	r3, r1
 8000c4c:	701a      	strb	r2, [r3, #0]
      messageIndex++; payloadIndex++;
 8000c4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c50:	3301      	adds	r3, #1
 8000c52:	64bb      	str	r3, [r7, #72]	; 0x48
 8000c54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8000c56:	3301      	adds	r3, #1
 8000c58:	647b      	str	r3, [r7, #68]	; 0x44
    /* Payload Size */
    tx_data[messageIndex] = payloadSize;
    messageIndex++;
    
    /* Payload */
    while (messageIndex < messageSize) {
 8000c5a:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 8000c5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000c60:	429a      	cmp	r2, r3
 8000c62:	dcec      	bgt.n	8000c3e <cmd_bluefruit.13488.4051+0x15e>
      tx_data[messageIndex] = payload[payloadIndex];
      messageIndex++; payloadIndex++;
    }
    
    chprintf(chp, "Sent: %d %x \n\r", payloadSize, tx_data);
 8000c64:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8000c68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000c6a:	6978      	ldr	r0, [r7, #20]
 8000c6c:	491c      	ldr	r1, [pc, #112]	; (8000ce0 <cmd_bluefruit.13488.4051+0x200>)
 8000c6e:	f000 fbcf 	bl	8001410 <chprintf>

    WriteRead(tx_data, messageSize, rx_data);
 8000c72:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8000c74:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 8000c78:	f107 0318 	add.w	r3, r7, #24
 8000c7c:	4608      	mov	r0, r1
 8000c7e:	4611      	mov	r1, r2
 8000c80:	461a      	mov	r2, r3
 8000c82:	f7ff fd05 	bl	8000690 <WriteRead.4056>

    /* Everything below is the same */
    int i = headerSize + 1;
 8000c86:	4b14      	ldr	r3, [pc, #80]	; (8000cd8 <cmd_bluefruit.13488.4051+0x1f8>)
 8000c88:	781b      	ldrb	r3, [r3, #0]
 8000c8a:	3301      	adds	r3, #1
 8000c8c:	643b      	str	r3, [r7, #64]	; 0x40
    //int size = 20;
    chprintf(chp, "Received:");
 8000c8e:	6978      	ldr	r0, [r7, #20]
 8000c90:	4914      	ldr	r1, [pc, #80]	; (8000ce4 <cmd_bluefruit.13488.4051+0x204>)
 8000c92:	f000 fbbd 	bl	8001410 <chprintf>
 8000c96:	e00c      	b.n	8000cb2 <cmd_bluefruit.13488.4051+0x1d2>
    while(i < 20) {
      chprintf(chp, " %c", rx_data[i]);  
 8000c98:	f107 0218 	add.w	r2, r7, #24
 8000c9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000c9e:	4413      	add	r3, r2
 8000ca0:	781b      	ldrb	r3, [r3, #0]
 8000ca2:	6978      	ldr	r0, [r7, #20]
 8000ca4:	4910      	ldr	r1, [pc, #64]	; (8000ce8 <cmd_bluefruit.13488.4051+0x208>)
 8000ca6:	461a      	mov	r2, r3
 8000ca8:	f000 fbb2 	bl	8001410 <chprintf>
      i++;
 8000cac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000cae:	3301      	adds	r3, #1
 8000cb0:	643b      	str	r3, [r7, #64]	; 0x40

    /* Everything below is the same */
    int i = headerSize + 1;
    //int size = 20;
    chprintf(chp, "Received:");
    while(i < 20) {
 8000cb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000cb4:	2b13      	cmp	r3, #19
 8000cb6:	ddef      	ble.n	8000c98 <cmd_bluefruit.13488.4051+0x1b8>
      chprintf(chp, " %c", rx_data[i]);  
      i++;
    }
    chprintf(chp, "\n\r");
 8000cb8:	6978      	ldr	r0, [r7, #20]
 8000cba:	490c      	ldr	r1, [pc, #48]	; (8000cec <cmd_bluefruit.13488.4051+0x20c>)
 8000cbc:	f000 fba8 	bl	8001410 <chprintf>
    chThdSleepMilliseconds(3);
 8000cc0:	201e      	movs	r0, #30
 8000cc2:	f004 fe45 	bl	8005950 <chThdSleep>
 8000cc6:	46d5      	mov	sp, sl
 8000cc8:	46b5      	mov	sp, r6
  }
}
 8000cca:	3754      	adds	r7, #84	; 0x54
 8000ccc:	46bd      	mov	sp, r7
 8000cce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000cd2:	bf00      	nop
 8000cd4:	080061d0 	.word	0x080061d0
 8000cd8:	2000081c 	.word	0x2000081c
 8000cdc:	20000818 	.word	0x20000818
 8000ce0:	080061d4 	.word	0x080061d4
 8000ce4:	080061e4 	.word	0x080061e4
 8000ce8:	080061f0 	.word	0x080061f0
 8000cec:	080061f4 	.word	0x080061f4

08000cf0 <cmd_myecho.13437.4030>:

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8000cf0:	b500      	push	{lr}
 8000cf2:	b087      	sub	sp, #28
 8000cf4:	9003      	str	r0, [sp, #12]
 8000cf6:	9102      	str	r1, [sp, #8]
 8000cf8:	9201      	str	r2, [sp, #4]
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 8000cfa:	2300      	movs	r3, #0
 8000cfc:	9305      	str	r3, [sp, #20]
 8000cfe:	e00c      	b.n	8000d1a <cmd_myecho.13437.4030+0x2a>
    chprintf(chp, "%s\n\r", argv[i]);
 8000d00:	9b05      	ldr	r3, [sp, #20]
 8000d02:	009b      	lsls	r3, r3, #2
 8000d04:	9a01      	ldr	r2, [sp, #4]
 8000d06:	4413      	add	r3, r2
 8000d08:	681b      	ldr	r3, [r3, #0]
 8000d0a:	9803      	ldr	r0, [sp, #12]
 8000d0c:	4906      	ldr	r1, [pc, #24]	; (8000d28 <cmd_myecho.13437.4030+0x38>)
 8000d0e:	461a      	mov	r2, r3
 8000d10:	f000 fb7e 	bl	8001410 <chprintf>
}

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 8000d14:	9b05      	ldr	r3, [sp, #20]
 8000d16:	3301      	adds	r3, #1
 8000d18:	9305      	str	r3, [sp, #20]
 8000d1a:	9a05      	ldr	r2, [sp, #20]
 8000d1c:	9b02      	ldr	r3, [sp, #8]
 8000d1e:	429a      	cmp	r2, r3
 8000d20:	dbee      	blt.n	8000d00 <cmd_myecho.13437.4030+0x10>
    chprintf(chp, "%s\n\r", argv[i]);
  }
}
 8000d22:	b007      	add	sp, #28
 8000d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d28:	080061f8 	.word	0x080061f8
 8000d2c:	f3af 8000 	nop.w

08000d30 <termination_handler.13451.4022>:
static const ShellConfig shell_cfg1 = {
  (BaseSequentialStream *)&SD1,
  commands
};

static void termination_handler(eventid_t id) {
 8000d30:	b500      	push	{lr}
 8000d32:	b083      	sub	sp, #12
 8000d34:	9001      	str	r0, [sp, #4]

  (void)id;
  chprintf((BaseSequentialStream*)&SD1, "Shell Died\n\r");
 8000d36:	4814      	ldr	r0, [pc, #80]	; (8000d88 <termination_handler.13451.4022+0x58>)
 8000d38:	4914      	ldr	r1, [pc, #80]	; (8000d8c <termination_handler.13451.4022+0x5c>)
 8000d3a:	f000 fb69 	bl	8001410 <chprintf>

  if (shelltp1 && chThdTerminatedX(shelltp1)) {
 8000d3e:	4b14      	ldr	r3, [pc, #80]	; (8000d90 <termination_handler.13451.4022+0x60>)
 8000d40:	681b      	ldr	r3, [r3, #0]
 8000d42:	2b00      	cmp	r3, #0
 8000d44:	d01d      	beq.n	8000d82 <termination_handler.13451.4022+0x52>
 8000d46:	4b12      	ldr	r3, [pc, #72]	; (8000d90 <termination_handler.13451.4022+0x60>)
 8000d48:	681b      	ldr	r3, [r3, #0]
 8000d4a:	4618      	mov	r0, r3
 8000d4c:	f7ff fbf0 	bl	8000530 <chThdTerminatedX.13354.4157>
 8000d50:	4603      	mov	r3, r0
 8000d52:	2b00      	cmp	r3, #0
 8000d54:	d015      	beq.n	8000d82 <termination_handler.13451.4022+0x52>
    chThdWait(shelltp1);
 8000d56:	4b0e      	ldr	r3, [pc, #56]	; (8000d90 <termination_handler.13451.4022+0x60>)
 8000d58:	681b      	ldr	r3, [r3, #0]
 8000d5a:	4618      	mov	r0, r3
 8000d5c:	f004 fe50 	bl	8005a00 <chThdWait>
    chprintf((BaseSequentialStream*)&SD1, "Restarting from termination handler\n\r");
 8000d60:	4809      	ldr	r0, [pc, #36]	; (8000d88 <termination_handler.13451.4022+0x58>)
 8000d62:	490c      	ldr	r1, [pc, #48]	; (8000d94 <termination_handler.13451.4022+0x64>)
 8000d64:	f000 fb54 	bl	8001410 <chprintf>
    chThdSleepMilliseconds(100);
 8000d68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d6c:	f004 fdf0 	bl	8005950 <chThdSleep>
    shelltp1 = shellCreate(&shell_cfg1, sizeof(waShell), NORMALPRIO);
 8000d70:	4809      	ldr	r0, [pc, #36]	; (8000d98 <termination_handler.13451.4022+0x68>)
 8000d72:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8000d76:	2240      	movs	r2, #64	; 0x40
 8000d78:	f000 fdca 	bl	8001910 <shellCreate>
 8000d7c:	4602      	mov	r2, r0
 8000d7e:	4b04      	ldr	r3, [pc, #16]	; (8000d90 <termination_handler.13451.4022+0x60>)
 8000d80:	601a      	str	r2, [r3, #0]
  }
}
 8000d82:	b003      	add	sp, #12
 8000d84:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d88:	20000ba8 	.word	0x20000ba8
 8000d8c:	0800620c 	.word	0x0800620c
 8000d90:	20000c28 	.word	0x20000c28
 8000d94:	0800621c 	.word	0x0800621c
 8000d98:	08006ab0 	.word	0x08006ab0
 8000d9c:	f3af 8000 	nop.w

08000da0 <main>:

/*
 * Application entry point.
 */

int main(void) {
 8000da0:	b500      	push	{lr}
 8000da2:	b089      	sub	sp, #36	; 0x24
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000da4:	f003 fb14 	bl	80043d0 <halInit>
  chSysInit();
 8000da8:	f004 f89a 	bl	8004ee0 <chSysInit>
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PC4(RX) and PC5(TX). The default baud rate is 9600.
   */

  sdStart(&SD1, NULL);
 8000dac:	4845      	ldr	r0, [pc, #276]	; (8000ec4 <main+0x124>)
 8000dae:	2100      	movs	r1, #0
 8000db0:	f002 fc4e 	bl	8003650 <sdStart>
  palSetPadMode(GPIOC, 4, PAL_MODE_ALTERNATE(7));
 8000db4:	4844      	ldr	r0, [pc, #272]	; (8000ec8 <main+0x128>)
 8000db6:	2110      	movs	r1, #16
 8000db8:	f240 3282 	movw	r2, #898	; 0x382
 8000dbc:	f000 fe78 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 5, PAL_MODE_ALTERNATE(7));
 8000dc0:	4841      	ldr	r0, [pc, #260]	; (8000ec8 <main+0x128>)
 8000dc2:	2120      	movs	r1, #32
 8000dc4:	f240 3282 	movw	r2, #898	; 0x382
 8000dc8:	f000 fe72 	bl	8001ab0 <_pal_lld_setgroupmode>

  //Setup the pins for the spi link on the GPIOA. This link connects to the pressure sensor and the gyro.  
  palSetPadMode(GPIOA, 5, PAL_MODE_ALTERNATE(5));     /* SCK. */
 8000dcc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dd0:	2120      	movs	r1, #32
 8000dd2:	f240 2282 	movw	r2, #642	; 0x282
 8000dd6:	f000 fe6b 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 6, PAL_MODE_ALTERNATE(5));     /* MISO.*/
 8000dda:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dde:	2140      	movs	r1, #64	; 0x40
 8000de0:	f240 2282 	movw	r2, #642	; 0x282
 8000de4:	f000 fe64 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 7, PAL_MODE_ALTERNATE(5));     /* MOSI.*/
 8000de8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dec:	2180      	movs	r1, #128	; 0x80
 8000dee:	f240 2282 	movw	r2, #642	; 0x282
 8000df2:	f000 fe5d 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 8, PAL_MODE_OUTPUT_PUSHPULL);  /* pressure sensor chip select */
 8000df6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dfa:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000dfe:	2201      	movs	r2, #1
 8000e00:	f000 fe56 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOE, 3, PAL_MODE_OUTPUT_PUSHPULL);  /* gyro chip select */
 8000e04:	4831      	ldr	r0, [pc, #196]	; (8000ecc <main+0x12c>)
 8000e06:	2108      	movs	r1, #8
 8000e08:	2201      	movs	r2, #1
 8000e0a:	f000 fe51 	bl	8001ab0 <_pal_lld_setgroupmode>
  palSetPad(GPIOA, 8);                                /* Deassert the bluetooth sensor chip select */
 8000e0e:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8000e12:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000e16:	831a      	strh	r2, [r3, #24]
  palSetPadMode(GPIOC, GPIOC_PIN3, PAL_MODE_INPUT_PULLUP); /* IRQ pin */
 8000e18:	482b      	ldr	r0, [pc, #172]	; (8000ec8 <main+0x128>)
 8000e1a:	2108      	movs	r1, #8
 8000e1c:	2220      	movs	r2, #32
 8000e1e:	f000 fe47 	bl	8001ab0 <_pal_lld_setgroupmode>

  chprintf((BaseSequentialStream*)&SD1, "\n\rUp and Running\n\r");
 8000e22:	4828      	ldr	r0, [pc, #160]	; (8000ec4 <main+0x124>)
 8000e24:	492a      	ldr	r1, [pc, #168]	; (8000ed0 <main+0x130>)
 8000e26:	f000 faf3 	bl	8001410 <chprintf>
  /* Initialize the command shell */ 
  shellInit();
 8000e2a:	f000 fd59 	bl	80018e0 <shellInit>


  uint32_t i;

  for (i = 0; i < 4096; i++) {
 8000e2e:	2300      	movs	r3, #0
 8000e30:	9307      	str	r3, [sp, #28]
 8000e32:	e018      	b.n	8000e66 <main+0xc6>
    if (i % 5 == 0) {
 8000e34:	9907      	ldr	r1, [sp, #28]
 8000e36:	4b27      	ldr	r3, [pc, #156]	; (8000ed4 <main+0x134>)
 8000e38:	fba3 2301 	umull	r2, r3, r3, r1
 8000e3c:	089a      	lsrs	r2, r3, #2
 8000e3e:	4613      	mov	r3, r2
 8000e40:	009b      	lsls	r3, r3, #2
 8000e42:	4413      	add	r3, r2
 8000e44:	1aca      	subs	r2, r1, r3
 8000e46:	2a00      	cmp	r2, #0
 8000e48:	d105      	bne.n	8000e56 <main+0xb6>
      bigData[i] = '1';
 8000e4a:	4a23      	ldr	r2, [pc, #140]	; (8000ed8 <main+0x138>)
 8000e4c:	9b07      	ldr	r3, [sp, #28]
 8000e4e:	4413      	add	r3, r2
 8000e50:	2231      	movs	r2, #49	; 0x31
 8000e52:	701a      	strb	r2, [r3, #0]
 8000e54:	e004      	b.n	8000e60 <main+0xc0>
    }
    else {
      bigData[i] = '0';
 8000e56:	4a20      	ldr	r2, [pc, #128]	; (8000ed8 <main+0x138>)
 8000e58:	9b07      	ldr	r3, [sp, #28]
 8000e5a:	4413      	add	r3, r2
 8000e5c:	2230      	movs	r2, #48	; 0x30
 8000e5e:	701a      	strb	r2, [r3, #0]
  shellInit();


  uint32_t i;

  for (i = 0; i < 4096; i++) {
 8000e60:	9b07      	ldr	r3, [sp, #28]
 8000e62:	3301      	adds	r3, #1
 8000e64:	9307      	str	r3, [sp, #28]
 8000e66:	9b07      	ldr	r3, [sp, #28]
 8000e68:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000e6c:	d3e2      	bcc.n	8000e34 <main+0x94>
    else {
      bigData[i] = '0';
    }
  }
  //setup to listen for the shell_terminated event. This setup will be stored in the tel  * event listner structure in item 0
  chEvtRegister(&shell_terminated, &tel, 0);
 8000e6e:	ab02      	add	r3, sp, #8
 8000e70:	481a      	ldr	r0, [pc, #104]	; (8000edc <main+0x13c>)
 8000e72:	4619      	mov	r1, r3
 8000e74:	2200      	movs	r2, #0
 8000e76:	f7ff fb7b 	bl	8000570 <chEvtRegister.13471.4068>

  shelltp1 = shellCreate(&shell_cfg1, sizeof(waShell), NORMALPRIO);
 8000e7a:	4819      	ldr	r0, [pc, #100]	; (8000ee0 <main+0x140>)
 8000e7c:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8000e80:	2240      	movs	r2, #64	; 0x40
 8000e82:	f000 fd45 	bl	8001910 <shellCreate>
 8000e86:	4602      	mov	r2, r0
 8000e88:	4b16      	ldr	r3, [pc, #88]	; (8000ee4 <main+0x144>)
 8000e8a:	601a      	str	r2, [r3, #0]
  chThdCreateStatic(waBigDataThread, sizeof(waBigDataThread), NORMALPRIO+2, bigDataThread, NULL);
 8000e8c:	2300      	movs	r3, #0
 8000e8e:	9300      	str	r3, [sp, #0]
 8000e90:	4815      	ldr	r0, [pc, #84]	; (8000ee8 <main+0x148>)
 8000e92:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8000e96:	2242      	movs	r2, #66	; 0x42
 8000e98:	4b14      	ldr	r3, [pc, #80]	; (8000eec <main+0x14c>)
 8000e9a:	f004 fd39 	bl	8005910 <chThdCreateStatic>
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 8000e9e:	2300      	movs	r3, #0
 8000ea0:	9300      	str	r3, [sp, #0]
 8000ea2:	4813      	ldr	r0, [pc, #76]	; (8000ef0 <main+0x150>)
 8000ea4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000ea8:	2241      	movs	r2, #65	; 0x41
 8000eaa:	4b12      	ldr	r3, [pc, #72]	; (8000ef4 <main+0x154>)
 8000eac:	f004 fd30 	bl	8005910 <chThdCreateStatic>
  //chThdCreateStatic(waMessageThread, sizeof(waMessageThread), NORMALPRIO+1, messageThread, NULL);
  //chThdCreateStatic(waAdvertisingThread, sizeof(waAdvertisingThread), NORMALPRIO+1, advertisingThread, NULL);
  while (TRUE) {
    chEvtDispatch(fhandlers, chEvtWaitOne(ALL_EVENTS));
 8000eb0:	f04f 30ff 	mov.w	r0, #4294967295
 8000eb4:	f003 fe14 	bl	8004ae0 <chEvtWaitOne>
 8000eb8:	4603      	mov	r3, r0
 8000eba:	480f      	ldr	r0, [pc, #60]	; (8000ef8 <main+0x158>)
 8000ebc:	4619      	mov	r1, r3
 8000ebe:	f003 fde7 	bl	8004a90 <chEvtDispatch>
 8000ec2:	e7f5      	b.n	8000eb0 <main+0x110>
 8000ec4:	20000ba8 	.word	0x20000ba8
 8000ec8:	48000800 	.word	0x48000800
 8000ecc:	48001000 	.word	0x48001000
 8000ed0:	08006244 	.word	0x08006244
 8000ed4:	cccccccd 	.word	0xcccccccd
 8000ed8:	20000c40 	.word	0x20000c40
 8000edc:	20000c24 	.word	0x20000c24
 8000ee0:	08006ab0 	.word	0x08006ab0
 8000ee4:	20000c28 	.word	0x20000c28
 8000ee8:	20001d90 	.word	0x20001d90
 8000eec:	080009d1 	.word	0x080009d1
 8000ef0:	20001c48 	.word	0x20001c48
 8000ef4:	080009a1 	.word	0x080009a1
 8000ef8:	20000950 	.word	0x20000950
 8000efc:	f3af 8000 	nop.w

08000f00 <long_to_string_with_divisor.12885.4368>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8000f00:	b088      	sub	sp, #32
 8000f02:	9003      	str	r0, [sp, #12]
 8000f04:	9102      	str	r1, [sp, #8]
 8000f06:	9201      	str	r2, [sp, #4]
 8000f08:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8000f0a:	9b02      	ldr	r3, [sp, #8]
 8000f0c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 8000f0e:	9b00      	ldr	r3, [sp, #0]
 8000f10:	2b00      	cmp	r3, #0
 8000f12:	d102      	bne.n	8000f1a <long_to_string_with_divisor.12885.4368+0x1a>
    ll = num;
 8000f14:	9b02      	ldr	r3, [sp, #8]
 8000f16:	9304      	str	r3, [sp, #16]
 8000f18:	e001      	b.n	8000f1e <long_to_string_with_divisor.12885.4368+0x1e>
  } else {
    ll = divisor;
 8000f1a:	9b00      	ldr	r3, [sp, #0]
 8000f1c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 8000f1e:	9b03      	ldr	r3, [sp, #12]
 8000f20:	330b      	adds	r3, #11
 8000f22:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8000f24:	9b05      	ldr	r3, [sp, #20]
 8000f26:	9a01      	ldr	r2, [sp, #4]
 8000f28:	fbb3 f2f2 	udiv	r2, r3, r2
 8000f2c:	9901      	ldr	r1, [sp, #4]
 8000f2e:	fb01 f202 	mul.w	r2, r1, r2
 8000f32:	1a9b      	subs	r3, r3, r2
 8000f34:	9307      	str	r3, [sp, #28]
    i += '0';
 8000f36:	9b07      	ldr	r3, [sp, #28]
 8000f38:	3330      	adds	r3, #48	; 0x30
 8000f3a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 8000f3c:	9b07      	ldr	r3, [sp, #28]
 8000f3e:	2b39      	cmp	r3, #57	; 0x39
 8000f40:	dd02      	ble.n	8000f48 <long_to_string_with_divisor.12885.4368+0x48>
      i += 'A' - '0' - 10;
 8000f42:	9b07      	ldr	r3, [sp, #28]
 8000f44:	3307      	adds	r3, #7
 8000f46:	9307      	str	r3, [sp, #28]
    *--q = i;
 8000f48:	9b06      	ldr	r3, [sp, #24]
 8000f4a:	3b01      	subs	r3, #1
 8000f4c:	9306      	str	r3, [sp, #24]
 8000f4e:	9b07      	ldr	r3, [sp, #28]
 8000f50:	b2da      	uxtb	r2, r3
 8000f52:	9b06      	ldr	r3, [sp, #24]
 8000f54:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8000f56:	9a05      	ldr	r2, [sp, #20]
 8000f58:	9b01      	ldr	r3, [sp, #4]
 8000f5a:	fbb2 f3f3 	udiv	r3, r2, r3
 8000f5e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8000f60:	9a04      	ldr	r2, [sp, #16]
 8000f62:	9b01      	ldr	r3, [sp, #4]
 8000f64:	fbb2 f3f3 	udiv	r3, r2, r3
 8000f68:	9304      	str	r3, [sp, #16]
 8000f6a:	9b04      	ldr	r3, [sp, #16]
 8000f6c:	2b00      	cmp	r3, #0
 8000f6e:	d1d9      	bne.n	8000f24 <long_to_string_with_divisor.12885.4368+0x24>

  i = (int)(p + MAX_FILLER - q);
 8000f70:	9b03      	ldr	r3, [sp, #12]
 8000f72:	330b      	adds	r3, #11
 8000f74:	461a      	mov	r2, r3
 8000f76:	9b06      	ldr	r3, [sp, #24]
 8000f78:	1ad3      	subs	r3, r2, r3
 8000f7a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 8000f7c:	9b03      	ldr	r3, [sp, #12]
 8000f7e:	1c5a      	adds	r2, r3, #1
 8000f80:	9203      	str	r2, [sp, #12]
 8000f82:	9a06      	ldr	r2, [sp, #24]
 8000f84:	1c51      	adds	r1, r2, #1
 8000f86:	9106      	str	r1, [sp, #24]
 8000f88:	7812      	ldrb	r2, [r2, #0]
 8000f8a:	701a      	strb	r2, [r3, #0]
  while (--i);
 8000f8c:	9b07      	ldr	r3, [sp, #28]
 8000f8e:	3b01      	subs	r3, #1
 8000f90:	9307      	str	r3, [sp, #28]
 8000f92:	9b07      	ldr	r3, [sp, #28]
 8000f94:	2b00      	cmp	r3, #0
 8000f96:	d1f1      	bne.n	8000f7c <long_to_string_with_divisor.12885.4368+0x7c>

  return p;
 8000f98:	9b03      	ldr	r3, [sp, #12]
}
 8000f9a:	4618      	mov	r0, r3
 8000f9c:	b008      	add	sp, #32
 8000f9e:	4770      	bx	lr

08000fa0 <ch_ltoa.12893.4363>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8000fa0:	b500      	push	{lr}
 8000fa2:	b085      	sub	sp, #20
 8000fa4:	9003      	str	r0, [sp, #12]
 8000fa6:	9102      	str	r1, [sp, #8]
 8000fa8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 8000faa:	9803      	ldr	r0, [sp, #12]
 8000fac:	9902      	ldr	r1, [sp, #8]
 8000fae:	9a01      	ldr	r2, [sp, #4]
 8000fb0:	2300      	movs	r3, #0
 8000fb2:	f7ff ffa5 	bl	8000f00 <long_to_string_with_divisor.12885.4368>
 8000fb6:	4603      	mov	r3, r0
}
 8000fb8:	4618      	mov	r0, r3
 8000fba:	b005      	add	sp, #20
 8000fbc:	f85d fb04 	ldr.w	pc, [sp], #4

08000fc0 <chvprintf.4355>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000fc0:	b500      	push	{lr}
 8000fc2:	b091      	sub	sp, #68	; 0x44
 8000fc4:	9003      	str	r0, [sp, #12]
 8000fc6:	9102      	str	r1, [sp, #8]
 8000fc8:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8000fca:	2300      	movs	r3, #0
 8000fcc:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000fce:	9b02      	ldr	r3, [sp, #8]
 8000fd0:	1c5a      	adds	r2, r3, #1
 8000fd2:	9202      	str	r2, [sp, #8]
 8000fd4:	781b      	ldrb	r3, [r3, #0]
 8000fd6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 8000fda:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000fde:	2b00      	cmp	r3, #0
 8000fe0:	d101      	bne.n	8000fe6 <chvprintf.4355+0x26>
      return n;
 8000fe2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000fe4:	e20d      	b.n	8001402 <chvprintf.4355+0x442>
    if (c != '%') {
 8000fe6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000fea:	2b25      	cmp	r3, #37	; 0x25
 8000fec:	d00b      	beq.n	8001006 <chvprintf.4355+0x46>
      streamPut(chp, (uint8_t)c);
 8000fee:	9b03      	ldr	r3, [sp, #12]
 8000ff0:	681b      	ldr	r3, [r3, #0]
 8000ff2:	689b      	ldr	r3, [r3, #8]
 8000ff4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8000ff8:	9803      	ldr	r0, [sp, #12]
 8000ffa:	4611      	mov	r1, r2
 8000ffc:	4798      	blx	r3
      n++;
 8000ffe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001000:	3301      	adds	r3, #1
 8001002:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001004:	e7e3      	b.n	8000fce <chvprintf.4355+0xe>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001006:	ab04      	add	r3, sp, #16
 8001008:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 800100a:	ab04      	add	r3, sp, #16
 800100c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 800100e:	2300      	movs	r3, #0
 8001010:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8001014:	9b02      	ldr	r3, [sp, #8]
 8001016:	781b      	ldrb	r3, [r3, #0]
 8001018:	2b2d      	cmp	r3, #45	; 0x2d
 800101a:	d105      	bne.n	8001028 <chvprintf.4355+0x68>
      fmt++;
 800101c:	9b02      	ldr	r3, [sp, #8]
 800101e:	3301      	adds	r3, #1
 8001020:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8001022:	2301      	movs	r3, #1
 8001024:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8001028:	2320      	movs	r3, #32
 800102a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 800102e:	9b02      	ldr	r3, [sp, #8]
 8001030:	781b      	ldrb	r3, [r3, #0]
 8001032:	2b30      	cmp	r3, #48	; 0x30
 8001034:	d105      	bne.n	8001042 <chvprintf.4355+0x82>
      fmt++;
 8001036:	9b02      	ldr	r3, [sp, #8]
 8001038:	3301      	adds	r3, #1
 800103a:	9302      	str	r3, [sp, #8]
      filler = '0';
 800103c:	2330      	movs	r3, #48	; 0x30
 800103e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8001042:	2300      	movs	r3, #0
 8001044:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8001046:	9b02      	ldr	r3, [sp, #8]
 8001048:	1c5a      	adds	r2, r3, #1
 800104a:	9202      	str	r2, [sp, #8]
 800104c:	781b      	ldrb	r3, [r3, #0]
 800104e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8001052:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001056:	2b2f      	cmp	r3, #47	; 0x2f
 8001058:	d909      	bls.n	800106e <chvprintf.4355+0xae>
 800105a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800105e:	2b39      	cmp	r3, #57	; 0x39
 8001060:	d805      	bhi.n	800106e <chvprintf.4355+0xae>
        c -= '0';
 8001062:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001066:	3b30      	subs	r3, #48	; 0x30
 8001068:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800106c:	e009      	b.n	8001082 <chvprintf.4355+0xc2>
      else if (c == '*')
 800106e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001072:	2b2a      	cmp	r3, #42	; 0x2a
 8001074:	d110      	bne.n	8001098 <chvprintf.4355+0xd8>
        c = va_arg(ap, int);
 8001076:	9b01      	ldr	r3, [sp, #4]
 8001078:	1d1a      	adds	r2, r3, #4
 800107a:	9201      	str	r2, [sp, #4]
 800107c:	681b      	ldr	r3, [r3, #0]
 800107e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 8001082:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8001084:	4613      	mov	r3, r2
 8001086:	009b      	lsls	r3, r3, #2
 8001088:	4413      	add	r3, r2
 800108a:	005b      	lsls	r3, r3, #1
 800108c:	461a      	mov	r2, r3
 800108e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001092:	4413      	add	r3, r2
 8001094:	930a      	str	r3, [sp, #40]	; 0x28
 8001096:	e7d6      	b.n	8001046 <chvprintf.4355+0x86>
    }
    precision = 0;
 8001098:	2300      	movs	r3, #0
 800109a:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 800109c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010a0:	2b2e      	cmp	r3, #46	; 0x2e
 80010a2:	d129      	bne.n	80010f8 <chvprintf.4355+0x138>
      while (TRUE) {
        c = *fmt++;
 80010a4:	9b02      	ldr	r3, [sp, #8]
 80010a6:	1c5a      	adds	r2, r3, #1
 80010a8:	9202      	str	r2, [sp, #8]
 80010aa:	781b      	ldrb	r3, [r3, #0]
 80010ac:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 80010b0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010b4:	2b2f      	cmp	r3, #47	; 0x2f
 80010b6:	d909      	bls.n	80010cc <chvprintf.4355+0x10c>
 80010b8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010bc:	2b39      	cmp	r3, #57	; 0x39
 80010be:	d805      	bhi.n	80010cc <chvprintf.4355+0x10c>
          c -= '0';
 80010c0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010c4:	3b30      	subs	r3, #48	; 0x30
 80010c6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80010ca:	e009      	b.n	80010e0 <chvprintf.4355+0x120>
        else if (c == '*')
 80010cc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010d0:	2b2a      	cmp	r3, #42	; 0x2a
 80010d2:	d111      	bne.n	80010f8 <chvprintf.4355+0x138>
          c = va_arg(ap, int);
 80010d4:	9b01      	ldr	r3, [sp, #4]
 80010d6:	1d1a      	adds	r2, r3, #4
 80010d8:	9201      	str	r2, [sp, #4]
 80010da:	681b      	ldr	r3, [r3, #0]
 80010dc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 80010e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80010e2:	4613      	mov	r3, r2
 80010e4:	009b      	lsls	r3, r3, #2
 80010e6:	4413      	add	r3, r2
 80010e8:	005b      	lsls	r3, r3, #1
 80010ea:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80010ec:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010f0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80010f2:	4413      	add	r3, r2
 80010f4:	930b      	str	r3, [sp, #44]	; 0x2c
 80010f6:	e7d5      	b.n	80010a4 <chvprintf.4355+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80010f8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80010fc:	2b6c      	cmp	r3, #108	; 0x6c
 80010fe:	d003      	beq.n	8001108 <chvprintf.4355+0x148>
 8001100:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001104:	2b4c      	cmp	r3, #76	; 0x4c
 8001106:	d10d      	bne.n	8001124 <chvprintf.4355+0x164>
      is_long = TRUE;
 8001108:	2301      	movs	r3, #1
 800110a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 800110e:	9b02      	ldr	r3, [sp, #8]
 8001110:	781b      	ldrb	r3, [r3, #0]
 8001112:	2b00      	cmp	r3, #0
 8001114:	d01a      	beq.n	800114c <chvprintf.4355+0x18c>
        c = *fmt++;
 8001116:	9b02      	ldr	r3, [sp, #8]
 8001118:	1c5a      	adds	r2, r3, #1
 800111a:	9202      	str	r2, [sp, #8]
 800111c:	781b      	ldrb	r3, [r3, #0]
 800111e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8001122:	e014      	b.n	800114e <chvprintf.4355+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8001124:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001128:	2b40      	cmp	r3, #64	; 0x40
 800112a:	d905      	bls.n	8001138 <chvprintf.4355+0x178>
 800112c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001130:	2b5a      	cmp	r3, #90	; 0x5a
 8001132:	d801      	bhi.n	8001138 <chvprintf.4355+0x178>
 8001134:	2301      	movs	r3, #1
 8001136:	e000      	b.n	800113a <chvprintf.4355+0x17a>
 8001138:	2300      	movs	r3, #0
 800113a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800113e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8001142:	f003 0301 	and.w	r3, r3, #1
 8001146:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800114a:	e000      	b.n	800114e <chvprintf.4355+0x18e>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 800114c:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800114e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001152:	3b44      	subs	r3, #68	; 0x44
 8001154:	2b34      	cmp	r3, #52	; 0x34
 8001156:	f200 80e2 	bhi.w	800131e <chvprintf.4355+0x35e>
 800115a:	a201      	add	r2, pc, #4	; (adr r2, 8001160 <chvprintf.4355+0x1a0>)
 800115c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001160:	08001297 	.word	0x08001297
 8001164:	0800131f 	.word	0x0800131f
 8001168:	0800131f 	.word	0x0800131f
 800116c:	0800131f 	.word	0x0800131f
 8001170:	0800131f 	.word	0x0800131f
 8001174:	08001297 	.word	0x08001297
 8001178:	0800131f 	.word	0x0800131f
 800117c:	0800131f 	.word	0x0800131f
 8001180:	0800131f 	.word	0x0800131f
 8001184:	0800131f 	.word	0x0800131f
 8001188:	0800131f 	.word	0x0800131f
 800118c:	080012e9 	.word	0x080012e9
 8001190:	0800131f 	.word	0x0800131f
 8001194:	0800131f 	.word	0x0800131f
 8001198:	0800131f 	.word	0x0800131f
 800119c:	0800131f 	.word	0x0800131f
 80011a0:	0800131f 	.word	0x0800131f
 80011a4:	080012e1 	.word	0x080012e1
 80011a8:	0800131f 	.word	0x0800131f
 80011ac:	0800131f 	.word	0x0800131f
 80011b0:	080012d9 	.word	0x080012d9
 80011b4:	0800131f 	.word	0x0800131f
 80011b8:	0800131f 	.word	0x0800131f
 80011bc:	0800131f 	.word	0x0800131f
 80011c0:	0800131f 	.word	0x0800131f
 80011c4:	0800131f 	.word	0x0800131f
 80011c8:	0800131f 	.word	0x0800131f
 80011cc:	0800131f 	.word	0x0800131f
 80011d0:	0800131f 	.word	0x0800131f
 80011d4:	0800131f 	.word	0x0800131f
 80011d8:	0800131f 	.word	0x0800131f
 80011dc:	08001235 	.word	0x08001235
 80011e0:	08001297 	.word	0x08001297
 80011e4:	0800131f 	.word	0x0800131f
 80011e8:	0800131f 	.word	0x0800131f
 80011ec:	0800131f 	.word	0x0800131f
 80011f0:	0800131f 	.word	0x0800131f
 80011f4:	08001297 	.word	0x08001297
 80011f8:	0800131f 	.word	0x0800131f
 80011fc:	0800131f 	.word	0x0800131f
 8001200:	0800131f 	.word	0x0800131f
 8001204:	0800131f 	.word	0x0800131f
 8001208:	0800131f 	.word	0x0800131f
 800120c:	080012e9 	.word	0x080012e9
 8001210:	0800131f 	.word	0x0800131f
 8001214:	0800131f 	.word	0x0800131f
 8001218:	0800131f 	.word	0x0800131f
 800121c:	0800124f 	.word	0x0800124f
 8001220:	0800131f 	.word	0x0800131f
 8001224:	080012e1 	.word	0x080012e1
 8001228:	0800131f 	.word	0x0800131f
 800122c:	0800131f 	.word	0x0800131f
 8001230:	080012d9 	.word	0x080012d9
    case 'c':
      filler = ' ';
 8001234:	2320      	movs	r3, #32
 8001236:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 800123a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800123c:	1c5a      	adds	r2, r3, #1
 800123e:	920f      	str	r2, [sp, #60]	; 0x3c
 8001240:	9a01      	ldr	r2, [sp, #4]
 8001242:	1d11      	adds	r1, r2, #4
 8001244:	9101      	str	r1, [sp, #4]
 8001246:	6812      	ldr	r2, [r2, #0]
 8001248:	b2d2      	uxtb	r2, r2
 800124a:	701a      	strb	r2, [r3, #0]
 800124c:	e06d      	b.n	800132a <chvprintf.4355+0x36a>
      break;
    case 's':
      filler = ' ';
 800124e:	2320      	movs	r3, #32
 8001250:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 8001254:	9b01      	ldr	r3, [sp, #4]
 8001256:	1d1a      	adds	r2, r3, #4
 8001258:	9201      	str	r2, [sp, #4]
 800125a:	681b      	ldr	r3, [r3, #0]
 800125c:	930e      	str	r3, [sp, #56]	; 0x38
 800125e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001260:	2b00      	cmp	r3, #0
 8001262:	d101      	bne.n	8001268 <chvprintf.4355+0x2a8>
        s = "(null)";
 8001264:	4b69      	ldr	r3, [pc, #420]	; (800140c <chvprintf.4355+0x44c>)
 8001266:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8001268:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800126a:	2b00      	cmp	r3, #0
 800126c:	d102      	bne.n	8001274 <chvprintf.4355+0x2b4>
        precision = 32767;
 800126e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8001272:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8001274:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001276:	930f      	str	r3, [sp, #60]	; 0x3c
 8001278:	e002      	b.n	8001280 <chvprintf.4355+0x2c0>
 800127a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800127c:	3301      	adds	r3, #1
 800127e:	930f      	str	r3, [sp, #60]	; 0x3c
 8001280:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8001282:	781b      	ldrb	r3, [r3, #0]
 8001284:	2b00      	cmp	r3, #0
 8001286:	d050      	beq.n	800132a <chvprintf.4355+0x36a>
 8001288:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800128a:	3b01      	subs	r3, #1
 800128c:	930b      	str	r3, [sp, #44]	; 0x2c
 800128e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001290:	2b00      	cmp	r3, #0
 8001292:	daf2      	bge.n	800127a <chvprintf.4355+0x2ba>
 8001294:	e049      	b.n	800132a <chvprintf.4355+0x36a>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8001296:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800129a:	2b00      	cmp	r3, #0
 800129c:	d005      	beq.n	80012aa <chvprintf.4355+0x2ea>
        l = va_arg(ap, long);
 800129e:	9b01      	ldr	r3, [sp, #4]
 80012a0:	1d1a      	adds	r2, r3, #4
 80012a2:	9201      	str	r2, [sp, #4]
 80012a4:	681b      	ldr	r3, [r3, #0]
 80012a6:	9307      	str	r3, [sp, #28]
 80012a8:	e004      	b.n	80012b4 <chvprintf.4355+0x2f4>
      else
        l = va_arg(ap, int);
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	1d1a      	adds	r2, r3, #4
 80012ae:	9201      	str	r2, [sp, #4]
 80012b0:	681b      	ldr	r3, [r3, #0]
 80012b2:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 80012b4:	9b07      	ldr	r3, [sp, #28]
 80012b6:	2b00      	cmp	r3, #0
 80012b8:	da07      	bge.n	80012ca <chvprintf.4355+0x30a>
        *p++ = '-';
 80012ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80012bc:	1c5a      	adds	r2, r3, #1
 80012be:	920f      	str	r2, [sp, #60]	; 0x3c
 80012c0:	222d      	movs	r2, #45	; 0x2d
 80012c2:	701a      	strb	r2, [r3, #0]
        l = -l;
 80012c4:	9b07      	ldr	r3, [sp, #28]
 80012c6:	425b      	negs	r3, r3
 80012c8:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 80012ca:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80012cc:	9907      	ldr	r1, [sp, #28]
 80012ce:	220a      	movs	r2, #10
 80012d0:	f7ff fe66 	bl	8000fa0 <ch_ltoa.12893.4363>
 80012d4:	900f      	str	r0, [sp, #60]	; 0x3c
 80012d6:	e028      	b.n	800132a <chvprintf.4355+0x36a>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 80012d8:	2310      	movs	r3, #16
 80012da:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80012de:	e006      	b.n	80012ee <chvprintf.4355+0x32e>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 80012e0:	230a      	movs	r3, #10
 80012e2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80012e6:	e002      	b.n	80012ee <chvprintf.4355+0x32e>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 80012e8:	2308      	movs	r3, #8
 80012ea:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 80012ee:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	d005      	beq.n	8001302 <chvprintf.4355+0x342>
        l = va_arg(ap, unsigned long);
 80012f6:	9b01      	ldr	r3, [sp, #4]
 80012f8:	1d1a      	adds	r2, r3, #4
 80012fa:	9201      	str	r2, [sp, #4]
 80012fc:	681b      	ldr	r3, [r3, #0]
 80012fe:	9307      	str	r3, [sp, #28]
 8001300:	e004      	b.n	800130c <chvprintf.4355+0x34c>
      else
        l = va_arg(ap, unsigned int);
 8001302:	9b01      	ldr	r3, [sp, #4]
 8001304:	1d1a      	adds	r2, r3, #4
 8001306:	9201      	str	r2, [sp, #4]
 8001308:	681b      	ldr	r3, [r3, #0]
 800130a:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 800130c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8001310:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8001312:	9907      	ldr	r1, [sp, #28]
 8001314:	461a      	mov	r2, r3
 8001316:	f7ff fe43 	bl	8000fa0 <ch_ltoa.12893.4363>
 800131a:	900f      	str	r0, [sp, #60]	; 0x3c
 800131c:	e005      	b.n	800132a <chvprintf.4355+0x36a>
      break;
    default:
      *p++ = c;
 800131e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8001320:	1c5a      	adds	r2, r3, #1
 8001322:	920f      	str	r2, [sp, #60]	; 0x3c
 8001324:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8001328:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 800132a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800132c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800132e:	1ad3      	subs	r3, r2, r3
 8001330:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 8001332:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8001334:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001336:	1ad3      	subs	r3, r2, r3
 8001338:	930a      	str	r3, [sp, #40]	; 0x28
 800133a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800133c:	2b00      	cmp	r3, #0
 800133e:	da01      	bge.n	8001344 <chvprintf.4355+0x384>
      width = 0;
 8001340:	2300      	movs	r3, #0
 8001342:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 8001344:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8001348:	f083 0301 	eor.w	r3, r3, #1
 800134c:	b2db      	uxtb	r3, r3
 800134e:	2b00      	cmp	r3, #0
 8001350:	d002      	beq.n	8001358 <chvprintf.4355+0x398>
      width = -width;
 8001352:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001354:	425b      	negs	r3, r3
 8001356:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8001358:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800135a:	2b00      	cmp	r3, #0
 800135c:	da37      	bge.n	80013ce <chvprintf.4355+0x40e>
      if (*s == '-' && filler == '0') {
 800135e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001360:	781b      	ldrb	r3, [r3, #0]
 8001362:	2b2d      	cmp	r3, #45	; 0x2d
 8001364:	d113      	bne.n	800138e <chvprintf.4355+0x3ce>
 8001366:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800136a:	2b30      	cmp	r3, #48	; 0x30
 800136c:	d10f      	bne.n	800138e <chvprintf.4355+0x3ce>
        streamPut(chp, (uint8_t)*s++);
 800136e:	9b03      	ldr	r3, [sp, #12]
 8001370:	681b      	ldr	r3, [r3, #0]
 8001372:	689a      	ldr	r2, [r3, #8]
 8001374:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001376:	1c59      	adds	r1, r3, #1
 8001378:	910e      	str	r1, [sp, #56]	; 0x38
 800137a:	781b      	ldrb	r3, [r3, #0]
 800137c:	9803      	ldr	r0, [sp, #12]
 800137e:	4619      	mov	r1, r3
 8001380:	4790      	blx	r2
        n++;
 8001382:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001384:	3301      	adds	r3, #1
 8001386:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8001388:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800138a:	3b01      	subs	r3, #1
 800138c:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800138e:	9b03      	ldr	r3, [sp, #12]
 8001390:	681b      	ldr	r3, [r3, #0]
 8001392:	689b      	ldr	r3, [r3, #8]
 8001394:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8001398:	9803      	ldr	r0, [sp, #12]
 800139a:	4611      	mov	r1, r2
 800139c:	4798      	blx	r3
        n++;
 800139e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013a0:	3301      	adds	r3, #1
 80013a2:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 80013a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80013a6:	3301      	adds	r3, #1
 80013a8:	930a      	str	r3, [sp, #40]	; 0x28
 80013aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80013ac:	2b00      	cmp	r3, #0
 80013ae:	d1ee      	bne.n	800138e <chvprintf.4355+0x3ce>
 80013b0:	e00d      	b.n	80013ce <chvprintf.4355+0x40e>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 80013b2:	9b03      	ldr	r3, [sp, #12]
 80013b4:	681b      	ldr	r3, [r3, #0]
 80013b6:	689a      	ldr	r2, [r3, #8]
 80013b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80013ba:	1c59      	adds	r1, r3, #1
 80013bc:	910e      	str	r1, [sp, #56]	; 0x38
 80013be:	781b      	ldrb	r3, [r3, #0]
 80013c0:	9803      	ldr	r0, [sp, #12]
 80013c2:	4619      	mov	r1, r3
 80013c4:	4790      	blx	r2
      n++;
 80013c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013c8:	3301      	adds	r3, #1
 80013ca:	9309      	str	r3, [sp, #36]	; 0x24
 80013cc:	e000      	b.n	80013d0 <chvprintf.4355+0x410>
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
 80013ce:	bf00      	nop
    }
    while (--i >= 0) {
 80013d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80013d2:	3b01      	subs	r3, #1
 80013d4:	930c      	str	r3, [sp, #48]	; 0x30
 80013d6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80013d8:	2b00      	cmp	r3, #0
 80013da:	daea      	bge.n	80013b2 <chvprintf.4355+0x3f2>
 80013dc:	e00d      	b.n	80013fa <chvprintf.4355+0x43a>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 80013de:	9b03      	ldr	r3, [sp, #12]
 80013e0:	681b      	ldr	r3, [r3, #0]
 80013e2:	689b      	ldr	r3, [r3, #8]
 80013e4:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80013e8:	9803      	ldr	r0, [sp, #12]
 80013ea:	4611      	mov	r1, r2
 80013ec:	4798      	blx	r3
      n++;
 80013ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013f0:	3301      	adds	r3, #1
 80013f2:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80013f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80013f6:	3b01      	subs	r3, #1
 80013f8:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80013fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80013fc:	2b00      	cmp	r3, #0
 80013fe:	d1ee      	bne.n	80013de <chvprintf.4355+0x41e>
 8001400:	e5e5      	b.n	8000fce <chvprintf.4355+0xe>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8001402:	4618      	mov	r0, r3
 8001404:	b011      	add	sp, #68	; 0x44
 8001406:	f85d fb04 	ldr.w	pc, [sp], #4
 800140a:	bf00      	nop
 800140c:	08006260 	.word	0x08006260

08001410 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001410:	b40e      	push	{r1, r2, r3}
 8001412:	b500      	push	{lr}
 8001414:	b084      	sub	sp, #16
 8001416:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001418:	ab06      	add	r3, sp, #24
 800141a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800141c:	9801      	ldr	r0, [sp, #4]
 800141e:	9905      	ldr	r1, [sp, #20]
 8001420:	9a02      	ldr	r2, [sp, #8]
 8001422:	f7ff fdcd 	bl	8000fc0 <chvprintf.4355>
 8001426:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8001428:	9b03      	ldr	r3, [sp, #12]
}
 800142a:	4618      	mov	r0, r3
 800142c:	b004      	add	sp, #16
 800142e:	f85d eb04 	ldr.w	lr, [sp], #4
 8001432:	b003      	add	sp, #12
 8001434:	4770      	bx	lr
 8001436:	bf00      	nop
 8001438:	f3af 8000 	nop.w
 800143c:	f3af 8000 	nop.w

08001440 <port_lock.12183.4235>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001440:	b082      	sub	sp, #8
 8001442:	2320      	movs	r3, #32
 8001444:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001446:	9b01      	ldr	r3, [sp, #4]
 8001448:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800144c:	b002      	add	sp, #8
 800144e:	4770      	bx	lr

08001450 <port_unlock.12186.4233>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001450:	b082      	sub	sp, #8
 8001452:	2300      	movs	r3, #0
 8001454:	9301      	str	r3, [sp, #4]
 8001456:	9b01      	ldr	r3, [sp, #4]
 8001458:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800145c:	b002      	add	sp, #8
 800145e:	4770      	bx	lr

08001460 <st_lld_get_counter.12188.4231>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001460:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001464:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001466:	4618      	mov	r0, r3
 8001468:	4770      	bx	lr
 800146a:	bf00      	nop
 800146c:	f3af 8000 	nop.w

08001470 <port_timer_get_time.12193.4229>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001470:	b508      	push	{r3, lr}

  return stGetCounter();
 8001472:	f7ff fff5 	bl	8001460 <st_lld_get_counter.12188.4231>
 8001476:	4603      	mov	r3, r0
}
 8001478:	4618      	mov	r0, r3
 800147a:	bd08      	pop	{r3, pc}
 800147c:	f3af 8000 	nop.w

08001480 <chSysLock.12195.4227>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001480:	b508      	push	{r3, lr}

  port_lock();
 8001482:	f7ff ffdd 	bl	8001440 <port_lock.12183.4235>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001486:	bd08      	pop	{r3, pc}
 8001488:	f3af 8000 	nop.w
 800148c:	f3af 8000 	nop.w

08001490 <chSysUnlock.12197.4225>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001490:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001492:	f7ff ffdd 	bl	8001450 <port_unlock.12186.4233>
}
 8001496:	bd08      	pop	{r3, pc}
 8001498:	f3af 8000 	nop.w
 800149c:	f3af 8000 	nop.w

080014a0 <chVTGetSystemTimeX.12199.4223>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80014a0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80014a2:	f7ff ffe5 	bl	8001470 <port_timer_get_time.12193.4229>
 80014a6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80014a8:	4618      	mov	r0, r3
 80014aa:	bd08      	pop	{r3, pc}
 80014ac:	f3af 8000 	nop.w

080014b0 <chVTGetSystemTime.12201.4221>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 80014b0:	b500      	push	{lr}
 80014b2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 80014b4:	f7ff ffe4 	bl	8001480 <chSysLock.12195.4227>
  systime = chVTGetSystemTimeX();
 80014b8:	f7ff fff2 	bl	80014a0 <chVTGetSystemTimeX.12199.4223>
 80014bc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 80014be:	f7ff ffe7 	bl	8001490 <chSysUnlock.12197.4225>

  return systime;
 80014c2:	9b01      	ldr	r3, [sp, #4]
}
 80014c4:	4618      	mov	r0, r3
 80014c6:	b003      	add	sp, #12
 80014c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80014cc:	f3af 8000 	nop.w

080014d0 <chRegSetThreadName.12203.4218>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80014d0:	b082      	sub	sp, #8
 80014d2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80014d4:	4b02      	ldr	r3, [pc, #8]	; (80014e0 <chRegSetThreadName.12203.4218+0x10>)
 80014d6:	699b      	ldr	r3, [r3, #24]
 80014d8:	9a01      	ldr	r2, [sp, #4]
 80014da:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80014dc:	b002      	add	sp, #8
 80014de:	4770      	bx	lr
 80014e0:	20000958 	.word	0x20000958
 80014e4:	f3af 8000 	nop.w
 80014e8:	f3af 8000 	nop.w
 80014ec:	f3af 8000 	nop.w

080014f0 <chEvtObjectInit.12207.4215>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80014f0:	b082      	sub	sp, #8
 80014f2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80014f4:	9b01      	ldr	r3, [sp, #4]
 80014f6:	9a01      	ldr	r2, [sp, #4]
 80014f8:	601a      	str	r2, [r3, #0]
}
 80014fa:	b002      	add	sp, #8
 80014fc:	4770      	bx	lr
 80014fe:	bf00      	nop

08001500 <chEvtBroadcastI.12293.4200>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8001500:	b500      	push	{lr}
 8001502:	b083      	sub	sp, #12
 8001504:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8001506:	9801      	ldr	r0, [sp, #4]
 8001508:	2100      	movs	r1, #0
 800150a:	f003 fa61 	bl	80049d0 <chEvtBroadcastFlagsI>
}
 800150e:	b003      	add	sp, #12
 8001510:	f85d fb04 	ldr.w	pc, [sp], #4
 8001514:	f3af 8000 	nop.w
 8001518:	f3af 8000 	nop.w
 800151c:	f3af 8000 	nop.w

08001520 <_strtok.12296.4195>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8001520:	b500      	push	{lr}
 8001522:	b087      	sub	sp, #28
 8001524:	9003      	str	r0, [sp, #12]
 8001526:	9102      	str	r1, [sp, #8]
 8001528:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 800152a:	9b03      	ldr	r3, [sp, #12]
 800152c:	2b00      	cmp	r3, #0
 800152e:	d002      	beq.n	8001536 <_strtok.12296.4195+0x16>
    *saveptr = str;
 8001530:	9b01      	ldr	r3, [sp, #4]
 8001532:	9a03      	ldr	r2, [sp, #12]
 8001534:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 8001536:	9b01      	ldr	r3, [sp, #4]
 8001538:	681b      	ldr	r3, [r3, #0]
 800153a:	9305      	str	r3, [sp, #20]

  if (!token)
 800153c:	9b05      	ldr	r3, [sp, #20]
 800153e:	2b00      	cmp	r3, #0
 8001540:	d101      	bne.n	8001546 <_strtok.12296.4195+0x26>
    return NULL;
 8001542:	2300      	movs	r3, #0
 8001544:	e020      	b.n	8001588 <_strtok.12296.4195+0x68>

  token += strspn(token, delim);
 8001546:	9805      	ldr	r0, [sp, #20]
 8001548:	9902      	ldr	r1, [sp, #8]
 800154a:	f004 fb71 	bl	8005c30 <strspn>
 800154e:	4603      	mov	r3, r0
 8001550:	9a05      	ldr	r2, [sp, #20]
 8001552:	4413      	add	r3, r2
 8001554:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 8001556:	9805      	ldr	r0, [sp, #20]
 8001558:	9902      	ldr	r1, [sp, #8]
 800155a:	f004 fb41 	bl	8005be0 <strpbrk>
 800155e:	4602      	mov	r2, r0
 8001560:	9b01      	ldr	r3, [sp, #4]
 8001562:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 8001564:	9b01      	ldr	r3, [sp, #4]
 8001566:	681b      	ldr	r3, [r3, #0]
 8001568:	2b00      	cmp	r3, #0
 800156a:	d006      	beq.n	800157a <_strtok.12296.4195+0x5a>
    *(*saveptr)++ = '\0';
 800156c:	9b01      	ldr	r3, [sp, #4]
 800156e:	681b      	ldr	r3, [r3, #0]
 8001570:	1c59      	adds	r1, r3, #1
 8001572:	9a01      	ldr	r2, [sp, #4]
 8001574:	6011      	str	r1, [r2, #0]
 8001576:	2200      	movs	r2, #0
 8001578:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 800157a:	9b05      	ldr	r3, [sp, #20]
 800157c:	781b      	ldrb	r3, [r3, #0]
 800157e:	2b00      	cmp	r3, #0
 8001580:	d001      	beq.n	8001586 <_strtok.12296.4195+0x66>
 8001582:	9b05      	ldr	r3, [sp, #20]
 8001584:	e000      	b.n	8001588 <_strtok.12296.4195+0x68>
 8001586:	2300      	movs	r3, #0
}
 8001588:	4618      	mov	r0, r3
 800158a:	b007      	add	sp, #28
 800158c:	f85d fb04 	ldr.w	pc, [sp], #4

08001590 <usage.12301.4191>:

static void usage(BaseSequentialStream *chp, char *p) {
 8001590:	b500      	push	{lr}
 8001592:	b083      	sub	sp, #12
 8001594:	9001      	str	r0, [sp, #4]
 8001596:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 8001598:	9801      	ldr	r0, [sp, #4]
 800159a:	4903      	ldr	r1, [pc, #12]	; (80015a8 <usage.12301.4191+0x18>)
 800159c:	9a00      	ldr	r2, [sp, #0]
 800159e:	f7ff ff37 	bl	8001410 <chprintf>
}
 80015a2:	b003      	add	sp, #12
 80015a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80015a8:	08006398 	.word	0x08006398
 80015ac:	f3af 8000 	nop.w

080015b0 <list_commands.12324.4187>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 80015b0:	b500      	push	{lr}
 80015b2:	b083      	sub	sp, #12
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	9100      	str	r1, [sp, #0]
 80015b8:	e009      	b.n	80015ce <list_commands.12324.4187+0x1e>

  while (scp->sc_name != NULL) {
    chprintf(chp, "%s ", scp->sc_name);
 80015ba:	9b00      	ldr	r3, [sp, #0]
 80015bc:	681b      	ldr	r3, [r3, #0]
 80015be:	9801      	ldr	r0, [sp, #4]
 80015c0:	4906      	ldr	r1, [pc, #24]	; (80015dc <list_commands.12324.4187+0x2c>)
 80015c2:	461a      	mov	r2, r3
 80015c4:	f7ff ff24 	bl	8001410 <chprintf>
    scp++;
 80015c8:	9b00      	ldr	r3, [sp, #0]
 80015ca:	3308      	adds	r3, #8
 80015cc:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80015ce:	9b00      	ldr	r3, [sp, #0]
 80015d0:	681b      	ldr	r3, [r3, #0]
 80015d2:	2b00      	cmp	r3, #0
 80015d4:	d1f1      	bne.n	80015ba <list_commands.12324.4187+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 80015d6:	b003      	add	sp, #12
 80015d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80015dc:	080063a4 	.word	0x080063a4

080015e0 <cmd_info.12314>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 80015e0:	b500      	push	{lr}
 80015e2:	b087      	sub	sp, #28
 80015e4:	9005      	str	r0, [sp, #20]
 80015e6:	9104      	str	r1, [sp, #16]
 80015e8:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 80015ea:	9b04      	ldr	r3, [sp, #16]
 80015ec:	2b00      	cmp	r3, #0
 80015ee:	dd04      	ble.n	80015fa <cmd_info.12314+0x1a>
    usage(chp, "info");
 80015f0:	9805      	ldr	r0, [sp, #20]
 80015f2:	4919      	ldr	r1, [pc, #100]	; (8001658 <cmd_info.12314+0x78>)
 80015f4:	f7ff ffcc 	bl	8001590 <usage.12301.4191>
 80015f8:	e02a      	b.n	8001650 <cmd_info.12314+0x70>
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 80015fa:	9805      	ldr	r0, [sp, #20]
 80015fc:	4917      	ldr	r1, [pc, #92]	; (800165c <cmd_info.12314+0x7c>)
 80015fe:	4a18      	ldr	r2, [pc, #96]	; (8001660 <cmd_info.12314+0x80>)
 8001600:	f7ff ff06 	bl	8001410 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8001604:	9805      	ldr	r0, [sp, #20]
 8001606:	4917      	ldr	r1, [pc, #92]	; (8001664 <cmd_info.12314+0x84>)
 8001608:	4a17      	ldr	r2, [pc, #92]	; (8001668 <cmd_info.12314+0x88>)
 800160a:	f7ff ff01 	bl	8001410 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 800160e:	9805      	ldr	r0, [sp, #20]
 8001610:	4916      	ldr	r1, [pc, #88]	; (800166c <cmd_info.12314+0x8c>)
 8001612:	4a17      	ldr	r2, [pc, #92]	; (8001670 <cmd_info.12314+0x90>)
 8001614:	f7ff fefc 	bl	8001410 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8001618:	9805      	ldr	r0, [sp, #20]
 800161a:	4916      	ldr	r1, [pc, #88]	; (8001674 <cmd_info.12314+0x94>)
 800161c:	4a16      	ldr	r2, [pc, #88]	; (8001678 <cmd_info.12314+0x98>)
 800161e:	f7ff fef7 	bl	8001410 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8001622:	9805      	ldr	r0, [sp, #20]
 8001624:	4915      	ldr	r1, [pc, #84]	; (800167c <cmd_info.12314+0x9c>)
 8001626:	4a16      	ldr	r2, [pc, #88]	; (8001680 <cmd_info.12314+0xa0>)
 8001628:	f7ff fef2 	bl	8001410 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 800162c:	9805      	ldr	r0, [sp, #20]
 800162e:	4915      	ldr	r1, [pc, #84]	; (8001684 <cmd_info.12314+0xa4>)
 8001630:	4a15      	ldr	r2, [pc, #84]	; (8001688 <cmd_info.12314+0xa8>)
 8001632:	f7ff feed 	bl	8001410 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8001636:	9805      	ldr	r0, [sp, #20]
 8001638:	4914      	ldr	r1, [pc, #80]	; (800168c <cmd_info.12314+0xac>)
 800163a:	4a15      	ldr	r2, [pc, #84]	; (8001690 <cmd_info.12314+0xb0>)
 800163c:	f7ff fee8 	bl	8001410 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8001640:	4b14      	ldr	r3, [pc, #80]	; (8001694 <cmd_info.12314+0xb4>)
 8001642:	9300      	str	r3, [sp, #0]
 8001644:	9805      	ldr	r0, [sp, #20]
 8001646:	4914      	ldr	r1, [pc, #80]	; (8001698 <cmd_info.12314+0xb8>)
 8001648:	4a14      	ldr	r2, [pc, #80]	; (800169c <cmd_info.12314+0xbc>)
 800164a:	4b15      	ldr	r3, [pc, #84]	; (80016a0 <cmd_info.12314+0xc0>)
 800164c:	f7ff fee0 	bl	8001410 <chprintf>
#endif
#endif
}
 8001650:	b007      	add	sp, #28
 8001652:	f85d fb04 	ldr.w	pc, [sp], #4
 8001656:	bf00      	nop
 8001658:	080063a8 	.word	0x080063a8
 800165c:	080063b0 	.word	0x080063b0
 8001660:	080063c4 	.word	0x080063c4
 8001664:	080063cc 	.word	0x080063cc
 8001668:	080063e0 	.word	0x080063e0
 800166c:	08006428 	.word	0x08006428
 8001670:	0800643c 	.word	0x0800643c
 8001674:	08006448 	.word	0x08006448
 8001678:	0800645c 	.word	0x0800645c
 800167c:	08006468 	.word	0x08006468
 8001680:	0800647c 	.word	0x0800647c
 8001684:	08006494 	.word	0x08006494
 8001688:	080064a8 	.word	0x080064a8
 800168c:	080064c4 	.word	0x080064c4
 8001690:	080064d8 	.word	0x080064d8
 8001694:	08006528 	.word	0x08006528
 8001698:	08006500 	.word	0x08006500
 800169c:	08006518 	.word	0x08006518
 80016a0:	08006524 	.word	0x08006524
 80016a4:	f3af 8000 	nop.w
 80016a8:	f3af 8000 	nop.w
 80016ac:	f3af 8000 	nop.w

080016b0 <cmd_systime.12319>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 80016b0:	b500      	push	{lr}
 80016b2:	b085      	sub	sp, #20
 80016b4:	9003      	str	r0, [sp, #12]
 80016b6:	9102      	str	r1, [sp, #8]
 80016b8:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 80016ba:	9b02      	ldr	r3, [sp, #8]
 80016bc:	2b00      	cmp	r3, #0
 80016be:	dd04      	ble.n	80016ca <cmd_systime.12319+0x1a>
    usage(chp, "systime");
 80016c0:	9803      	ldr	r0, [sp, #12]
 80016c2:	4907      	ldr	r1, [pc, #28]	; (80016e0 <cmd_systime.12319+0x30>)
 80016c4:	f7ff ff64 	bl	8001590 <usage.12301.4191>
 80016c8:	e007      	b.n	80016da <cmd_systime.12319+0x2a>
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80016ca:	f7ff fef1 	bl	80014b0 <chVTGetSystemTime.12201.4221>
 80016ce:	4603      	mov	r3, r0
 80016d0:	9803      	ldr	r0, [sp, #12]
 80016d2:	4904      	ldr	r1, [pc, #16]	; (80016e4 <cmd_systime.12319+0x34>)
 80016d4:	461a      	mov	r2, r3
 80016d6:	f7ff fe9b 	bl	8001410 <chprintf>
}
 80016da:	b005      	add	sp, #20
 80016dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e0:	08006534 	.word	0x08006534
 80016e4:	0800653c 	.word	0x0800653c
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <cmdexec.12333.4170>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 80016f0:	b500      	push	{lr}
 80016f2:	b085      	sub	sp, #20
 80016f4:	9003      	str	r0, [sp, #12]
 80016f6:	9102      	str	r1, [sp, #8]
 80016f8:	9201      	str	r2, [sp, #4]
 80016fa:	9300      	str	r3, [sp, #0]
 80016fc:	e013      	b.n	8001726 <cmdexec.12333.4170+0x36>

  while (scp->sc_name != NULL) {
    if (strcmp(scp->sc_name, name) == 0) {
 80016fe:	9b03      	ldr	r3, [sp, #12]
 8001700:	681b      	ldr	r3, [r3, #0]
 8001702:	4618      	mov	r0, r3
 8001704:	9901      	ldr	r1, [sp, #4]
 8001706:	f7fe fe03 	bl	8000310 <strcmp>
 800170a:	4603      	mov	r3, r0
 800170c:	2b00      	cmp	r3, #0
 800170e:	d107      	bne.n	8001720 <cmdexec.12333.4170+0x30>
      scp->sc_function(chp, argc, argv);
 8001710:	9b03      	ldr	r3, [sp, #12]
 8001712:	685b      	ldr	r3, [r3, #4]
 8001714:	9802      	ldr	r0, [sp, #8]
 8001716:	9900      	ldr	r1, [sp, #0]
 8001718:	9a06      	ldr	r2, [sp, #24]
 800171a:	4798      	blx	r3
      return false;
 800171c:	2300      	movs	r3, #0
 800171e:	e007      	b.n	8001730 <cmdexec.12333.4170+0x40>
    }
    scp++;
 8001720:	9b03      	ldr	r3, [sp, #12]
 8001722:	3308      	adds	r3, #8
 8001724:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8001726:	9b03      	ldr	r3, [sp, #12]
 8001728:	681b      	ldr	r3, [r3, #0]
 800172a:	2b00      	cmp	r3, #0
 800172c:	d1e7      	bne.n	80016fe <cmdexec.12333.4170+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 800172e:	2301      	movs	r3, #1
}
 8001730:	4618      	mov	r0, r3
 8001732:	b005      	add	sp, #20
 8001734:	f85d fb04 	ldr.w	pc, [sp], #4
 8001738:	f3af 8000 	nop.w
 800173c:	f3af 8000 	nop.w

08001740 <shell_thread.12355.4157>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8001740:	b500      	push	{lr}
 8001742:	b0a1      	sub	sp, #132	; 0x84
 8001744:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8001746:	9b03      	ldr	r3, [sp, #12]
 8001748:	681b      	ldr	r3, [r3, #0]
 800174a:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 800174c:	9b03      	ldr	r3, [sp, #12]
 800174e:	685b      	ldr	r3, [r3, #4]
 8001750:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8001752:	4855      	ldr	r0, [pc, #340]	; (80018a8 <shell_thread.12355.4157+0x168>)
 8001754:	f7ff febc 	bl	80014d0 <chRegSetThreadName.12203.4218>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8001758:	981d      	ldr	r0, [sp, #116]	; 0x74
 800175a:	4954      	ldr	r1, [pc, #336]	; (80018ac <shell_thread.12355.4157+0x16c>)
 800175c:	f7ff fe58 	bl	8001410 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 8001760:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001762:	4953      	ldr	r1, [pc, #332]	; (80018b0 <shell_thread.12355.4157+0x170>)
 8001764:	f7ff fe54 	bl	8001410 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 8001768:	ab0a      	add	r3, sp, #40	; 0x28
 800176a:	981d      	ldr	r0, [sp, #116]	; 0x74
 800176c:	4619      	mov	r1, r3
 800176e:	2240      	movs	r2, #64	; 0x40
 8001770:	f000 f8e6 	bl	8001940 <shellGetLine.4050>
 8001774:	4603      	mov	r3, r0
 8001776:	2b00      	cmp	r3, #0
 8001778:	d004      	beq.n	8001784 <shell_thread.12355.4157+0x44>
      chprintf(chp, "\r\nlogout");
 800177a:	981d      	ldr	r0, [sp, #116]	; 0x74
 800177c:	494d      	ldr	r1, [pc, #308]	; (80018b4 <shell_thread.12355.4157+0x174>)
 800177e:	f7ff fe47 	bl	8001410 <chprintf>
 8001782:	e08a      	b.n	800189a <shell_thread.12355.4157+0x15a>
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8001784:	aa0a      	add	r2, sp, #40	; 0x28
 8001786:	ab1a      	add	r3, sp, #104	; 0x68
 8001788:	4610      	mov	r0, r2
 800178a:	494b      	ldr	r1, [pc, #300]	; (80018b8 <shell_thread.12355.4157+0x178>)
 800178c:	461a      	mov	r2, r3
 800178e:	f7ff fec7 	bl	8001520 <_strtok.12296.4195>
 8001792:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 8001794:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8001796:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 8001798:	2300      	movs	r3, #0
 800179a:	931f      	str	r3, [sp, #124]	; 0x7c
 800179c:	e012      	b.n	80017c4 <shell_thread.12355.4157+0x84>
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
 800179e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80017a0:	2b03      	cmp	r3, #3
 80017a2:	dd06      	ble.n	80017b2 <shell_thread.12355.4157+0x72>
        chprintf(chp, "too many arguments\r\n");
 80017a4:	981d      	ldr	r0, [sp, #116]	; 0x74
 80017a6:	4945      	ldr	r1, [pc, #276]	; (80018bc <shell_thread.12355.4157+0x17c>)
 80017a8:	f7ff fe32 	bl	8001410 <chprintf>
        cmd = NULL;
 80017ac:	2300      	movs	r3, #0
 80017ae:	931e      	str	r3, [sp, #120]	; 0x78
 80017b0:	e012      	b.n	80017d8 <shell_thread.12355.4157+0x98>
        break;
      }
      args[n++] = lp;
 80017b2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80017b4:	1c5a      	adds	r2, r3, #1
 80017b6:	921f      	str	r2, [sp, #124]	; 0x7c
 80017b8:	009b      	lsls	r3, r3, #2
 80017ba:	aa20      	add	r2, sp, #128	; 0x80
 80017bc:	4413      	add	r3, r2
 80017be:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80017c0:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80017c4:	ab1a      	add	r3, sp, #104	; 0x68
 80017c6:	2000      	movs	r0, #0
 80017c8:	493b      	ldr	r1, [pc, #236]	; (80018b8 <shell_thread.12355.4157+0x178>)
 80017ca:	461a      	mov	r2, r3
 80017cc:	f7ff fea8 	bl	8001520 <_strtok.12296.4195>
 80017d0:	901b      	str	r0, [sp, #108]	; 0x6c
 80017d2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80017d4:	2b00      	cmp	r3, #0
 80017d6:	d1e2      	bne.n	800179e <shell_thread.12355.4157+0x5e>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 80017d8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80017da:	009b      	lsls	r3, r3, #2
 80017dc:	aa20      	add	r2, sp, #128	; 0x80
 80017de:	4413      	add	r3, r2
 80017e0:	2200      	movs	r2, #0
 80017e2:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 80017e6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80017e8:	2b00      	cmp	r3, #0
 80017ea:	d0b9      	beq.n	8001760 <shell_thread.12355.4157+0x20>
      if (strcmp(cmd, "exit") == 0) {
 80017ec:	981e      	ldr	r0, [sp, #120]	; 0x78
 80017ee:	4934      	ldr	r1, [pc, #208]	; (80018c0 <shell_thread.12355.4157+0x180>)
 80017f0:	f7fe fd8e 	bl	8000310 <strcmp>
 80017f4:	4603      	mov	r3, r0
 80017f6:	2b00      	cmp	r3, #0
 80017f8:	d107      	bne.n	800180a <shell_thread.12355.4157+0xca>
        if (n > 0) {
 80017fa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80017fc:	2b00      	cmp	r3, #0
 80017fe:	dd4c      	ble.n	800189a <shell_thread.12355.4157+0x15a>
          usage(chp, "exit");
 8001800:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001802:	492f      	ldr	r1, [pc, #188]	; (80018c0 <shell_thread.12355.4157+0x180>)
 8001804:	f7ff fec4 	bl	8001590 <usage.12301.4191>
 8001808:	e7aa      	b.n	8001760 <shell_thread.12355.4157+0x20>
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
 800180a:	981e      	ldr	r0, [sp, #120]	; 0x78
 800180c:	492d      	ldr	r1, [pc, #180]	; (80018c4 <shell_thread.12355.4157+0x184>)
 800180e:	f7fe fd7f 	bl	8000310 <strcmp>
 8001812:	4603      	mov	r3, r0
 8001814:	2b00      	cmp	r3, #0
 8001816:	d11b      	bne.n	8001850 <shell_thread.12355.4157+0x110>
        if (n > 0) {
 8001818:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800181a:	2b00      	cmp	r3, #0
 800181c:	dd04      	ble.n	8001828 <shell_thread.12355.4157+0xe8>
          usage(chp, "help");
 800181e:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001820:	4928      	ldr	r1, [pc, #160]	; (80018c4 <shell_thread.12355.4157+0x184>)
 8001822:	f7ff feb5 	bl	8001590 <usage.12301.4191>
 8001826:	e79b      	b.n	8001760 <shell_thread.12355.4157+0x20>
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 8001828:	981d      	ldr	r0, [sp, #116]	; 0x74
 800182a:	4927      	ldr	r1, [pc, #156]	; (80018c8 <shell_thread.12355.4157+0x188>)
 800182c:	f7ff fdf0 	bl	8001410 <chprintf>
        list_commands(chp, local_commands);
 8001830:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001832:	4926      	ldr	r1, [pc, #152]	; (80018cc <shell_thread.12355.4157+0x18c>)
 8001834:	f7ff febc 	bl	80015b0 <list_commands.12324.4187>
        if (scp != NULL)
 8001838:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800183a:	2b00      	cmp	r3, #0
 800183c:	d003      	beq.n	8001846 <shell_thread.12355.4157+0x106>
          list_commands(chp, scp);
 800183e:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001840:	991c      	ldr	r1, [sp, #112]	; 0x70
 8001842:	f7ff feb5 	bl	80015b0 <list_commands.12324.4187>
        chprintf(chp, "\r\n");
 8001846:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001848:	4921      	ldr	r1, [pc, #132]	; (80018d0 <shell_thread.12355.4157+0x190>)
 800184a:	f7ff fde1 	bl	8001410 <chprintf>
 800184e:	e787      	b.n	8001760 <shell_thread.12355.4157+0x20>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8001850:	ab05      	add	r3, sp, #20
 8001852:	9300      	str	r3, [sp, #0]
 8001854:	481d      	ldr	r0, [pc, #116]	; (80018cc <shell_thread.12355.4157+0x18c>)
 8001856:	991d      	ldr	r1, [sp, #116]	; 0x74
 8001858:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800185a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800185c:	f7ff ff48 	bl	80016f0 <cmdexec.12333.4170>
 8001860:	4603      	mov	r3, r0
 8001862:	2b00      	cmp	r3, #0
 8001864:	f43f af7c 	beq.w	8001760 <shell_thread.12355.4157+0x20>
 8001868:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800186a:	2b00      	cmp	r3, #0
 800186c:	d00b      	beq.n	8001886 <shell_thread.12355.4157+0x146>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 800186e:	ab05      	add	r3, sp, #20
 8001870:	9300      	str	r3, [sp, #0]
 8001872:	981c      	ldr	r0, [sp, #112]	; 0x70
 8001874:	991d      	ldr	r1, [sp, #116]	; 0x74
 8001876:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8001878:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800187a:	f7ff ff39 	bl	80016f0 <cmdexec.12333.4170>
 800187e:	4603      	mov	r3, r0
 8001880:	2b00      	cmp	r3, #0
 8001882:	f43f af6d 	beq.w	8001760 <shell_thread.12355.4157+0x20>
        chprintf(chp, "%s", cmd);
 8001886:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001888:	4912      	ldr	r1, [pc, #72]	; (80018d4 <shell_thread.12355.4157+0x194>)
 800188a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800188c:	f7ff fdc0 	bl	8001410 <chprintf>
        chprintf(chp, " ?\r\n");
 8001890:	981d      	ldr	r0, [sp, #116]	; 0x74
 8001892:	4911      	ldr	r1, [pc, #68]	; (80018d8 <shell_thread.12355.4157+0x198>)
 8001894:	f7ff fdbc 	bl	8001410 <chprintf>
 8001898:	e762      	b.n	8001760 <shell_thread.12355.4157+0x20>
      }
    }
  }
  shellExit(MSG_OK);
 800189a:	2000      	movs	r0, #0
 800189c:	f000 f828 	bl	80018f0 <shellExit.4165>
}
 80018a0:	b021      	add	sp, #132	; 0x84
 80018a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80018a6:	bf00      	nop
 80018a8:	08006544 	.word	0x08006544
 80018ac:	0800654c 	.word	0x0800654c
 80018b0:	08006564 	.word	0x08006564
 80018b4:	0800656c 	.word	0x0800656c
 80018b8:	08006578 	.word	0x08006578
 80018bc:	0800657c 	.word	0x0800657c
 80018c0:	08006594 	.word	0x08006594
 80018c4:	0800659c 	.word	0x0800659c
 80018c8:	080065a4 	.word	0x080065a4
 80018cc:	20000800 	.word	0x20000800
 80018d0:	080065bc 	.word	0x080065bc
 80018d4:	080065c0 	.word	0x080065c0
 80018d8:	080065c4 	.word	0x080065c4
 80018dc:	f3af 8000 	nop.w

080018e0 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 80018e0:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 80018e2:	4802      	ldr	r0, [pc, #8]	; (80018ec <shellInit+0xc>)
 80018e4:	f7ff fe04 	bl	80014f0 <chEvtObjectInit.12207.4215>
}
 80018e8:	bd08      	pop	{r3, pc}
 80018ea:	bf00      	nop
 80018ec:	20000c24 	.word	0x20000c24

080018f0 <shellExit.4165>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 80018f0:	b500      	push	{lr}
 80018f2:	b083      	sub	sp, #12
 80018f4:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 80018f6:	f7ff fdc3 	bl	8001480 <chSysLock.12195.4227>
  chEvtBroadcastI(&shell_terminated);
 80018fa:	4804      	ldr	r0, [pc, #16]	; (800190c <shellExit.4165+0x1c>)
 80018fc:	f7ff fe00 	bl	8001500 <chEvtBroadcastI.12293.4200>
  chThdExitS(msg);
 8001900:	9801      	ldr	r0, [sp, #4]
 8001902:	f004 f845 	bl	8005990 <chThdExitS>
}
 8001906:	b003      	add	sp, #12
 8001908:	f85d fb04 	ldr.w	pc, [sp], #4
 800190c:	20000c24 	.word	0x20000c24

08001910 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8001910:	b500      	push	{lr}
 8001912:	b087      	sub	sp, #28
 8001914:	9005      	str	r0, [sp, #20]
 8001916:	9104      	str	r1, [sp, #16]
 8001918:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 800191a:	9b05      	ldr	r3, [sp, #20]
 800191c:	9300      	str	r3, [sp, #0]
 800191e:	2000      	movs	r0, #0
 8001920:	9904      	ldr	r1, [sp, #16]
 8001922:	9a03      	ldr	r2, [sp, #12]
 8001924:	4b03      	ldr	r3, [pc, #12]	; (8001934 <shellCreate+0x24>)
 8001926:	f002 fe63 	bl	80045f0 <chThdCreateFromHeap>
 800192a:	4603      	mov	r3, r0
}
 800192c:	4618      	mov	r0, r3
 800192e:	b007      	add	sp, #28
 8001930:	f85d fb04 	ldr.w	pc, [sp], #4
 8001934:	08001741 	.word	0x08001741
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <shellGetLine.4050>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8001940:	b500      	push	{lr}
 8001942:	b087      	sub	sp, #28
 8001944:	9003      	str	r0, [sp, #12]
 8001946:	9102      	str	r1, [sp, #8]
 8001948:	9201      	str	r2, [sp, #4]
  char *p = line;
 800194a:	9b02      	ldr	r3, [sp, #8]
 800194c:	9305      	str	r3, [sp, #20]
 800194e:	e000      	b.n	8001952 <shellGetLine.4050+0x12>
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 8001950:	bf00      	nop
  char *p = line;

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8001952:	9b03      	ldr	r3, [sp, #12]
 8001954:	681b      	ldr	r3, [r3, #0]
 8001956:	685b      	ldr	r3, [r3, #4]
 8001958:	f10d 0213 	add.w	r2, sp, #19
 800195c:	9803      	ldr	r0, [sp, #12]
 800195e:	4611      	mov	r1, r2
 8001960:	2201      	movs	r2, #1
 8001962:	4798      	blx	r3
 8001964:	4603      	mov	r3, r0
 8001966:	2b00      	cmp	r3, #0
 8001968:	d101      	bne.n	800196e <shellGetLine.4050+0x2e>
      return true;
 800196a:	2301      	movs	r3, #1
 800196c:	e058      	b.n	8001a20 <shellGetLine.4050+0xe0>
    if (c == 4) {
 800196e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001972:	2b04      	cmp	r3, #4
 8001974:	d105      	bne.n	8001982 <shellGetLine.4050+0x42>
      chprintf(chp, "^D");
 8001976:	9803      	ldr	r0, [sp, #12]
 8001978:	492b      	ldr	r1, [pc, #172]	; (8001a28 <shellGetLine.4050+0xe8>)
 800197a:	f7ff fd49 	bl	8001410 <chprintf>
      return true;
 800197e:	2301      	movs	r3, #1

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 8001980:	e04e      	b.n	8001a20 <shellGetLine.4050+0xe0>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8001982:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001986:	2b08      	cmp	r3, #8
 8001988:	d003      	beq.n	8001992 <shellGetLine.4050+0x52>
 800198a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800198e:	2b7f      	cmp	r3, #127	; 0x7f
 8001990:	d11d      	bne.n	80019ce <shellGetLine.4050+0x8e>
      if (p != line) {
 8001992:	9a05      	ldr	r2, [sp, #20]
 8001994:	9b02      	ldr	r3, [sp, #8]
 8001996:	429a      	cmp	r2, r3
 8001998:	d0da      	beq.n	8001950 <shellGetLine.4050+0x10>
        chSequentialStreamPut(chp, c);
 800199a:	9b03      	ldr	r3, [sp, #12]
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	689b      	ldr	r3, [r3, #8]
 80019a0:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80019a4:	9803      	ldr	r0, [sp, #12]
 80019a6:	4611      	mov	r1, r2
 80019a8:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 80019aa:	9b03      	ldr	r3, [sp, #12]
 80019ac:	681b      	ldr	r3, [r3, #0]
 80019ae:	689b      	ldr	r3, [r3, #8]
 80019b0:	9803      	ldr	r0, [sp, #12]
 80019b2:	2120      	movs	r1, #32
 80019b4:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 80019b6:	9b03      	ldr	r3, [sp, #12]
 80019b8:	681b      	ldr	r3, [r3, #0]
 80019ba:	689b      	ldr	r3, [r3, #8]
 80019bc:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80019c0:	9803      	ldr	r0, [sp, #12]
 80019c2:	4611      	mov	r1, r2
 80019c4:	4798      	blx	r3
        p--;
 80019c6:	9b05      	ldr	r3, [sp, #20]
 80019c8:	3b01      	subs	r3, #1
 80019ca:	9305      	str	r3, [sp, #20]
      }
      continue;
 80019cc:	e7c1      	b.n	8001952 <shellGetLine.4050+0x12>
    }
    if (c == '\r') {
 80019ce:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80019d2:	2b0d      	cmp	r3, #13
 80019d4:	d108      	bne.n	80019e8 <shellGetLine.4050+0xa8>
      chprintf(chp, "\r\n");
 80019d6:	9803      	ldr	r0, [sp, #12]
 80019d8:	4914      	ldr	r1, [pc, #80]	; (8001a2c <shellGetLine.4050+0xec>)
 80019da:	f7ff fd19 	bl	8001410 <chprintf>
      *p = 0;
 80019de:	9b05      	ldr	r3, [sp, #20]
 80019e0:	2200      	movs	r2, #0
 80019e2:	701a      	strb	r2, [r3, #0]
      return false;
 80019e4:	2300      	movs	r3, #0

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 80019e6:	e01b      	b.n	8001a20 <shellGetLine.4050+0xe0>
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 80019e8:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80019ec:	2b1f      	cmp	r3, #31
 80019ee:	d801      	bhi.n	80019f4 <shellGetLine.4050+0xb4>
      continue;
 80019f0:	bf00      	nop
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 80019f2:	e7ae      	b.n	8001952 <shellGetLine.4050+0x12>
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	3b01      	subs	r3, #1
 80019f8:	9a02      	ldr	r2, [sp, #8]
 80019fa:	441a      	add	r2, r3
 80019fc:	9b05      	ldr	r3, [sp, #20]
 80019fe:	429a      	cmp	r2, r3
 8001a00:	d9a7      	bls.n	8001952 <shellGetLine.4050+0x12>
      chSequentialStreamPut(chp, c);
 8001a02:	9b03      	ldr	r3, [sp, #12]
 8001a04:	681b      	ldr	r3, [r3, #0]
 8001a06:	689b      	ldr	r3, [r3, #8]
 8001a08:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8001a0c:	9803      	ldr	r0, [sp, #12]
 8001a0e:	4611      	mov	r1, r2
 8001a10:	4798      	blx	r3
      *p++ = (char)c;
 8001a12:	9b05      	ldr	r3, [sp, #20]
 8001a14:	1c5a      	adds	r2, r3, #1
 8001a16:	9205      	str	r2, [sp, #20]
 8001a18:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8001a1c:	701a      	strb	r2, [r3, #0]
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 8001a1e:	e798      	b.n	8001952 <shellGetLine.4050+0x12>
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 8001a20:	4618      	mov	r0, r3
 8001a22:	b007      	add	sp, #28
 8001a24:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a28:	080065cc 	.word	0x080065cc
 8001a2c:	080065bc 	.word	0x080065bc

08001a30 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001a30:	b500      	push	{lr}
 8001a32:	b083      	sub	sp, #12
 8001a34:	9001      	str	r0, [sp, #4]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001a36:	4b16      	ldr	r3, [pc, #88]	; (8001a90 <_pal_lld_init+0x60>)
 8001a38:	4a15      	ldr	r2, [pc, #84]	; (8001a90 <_pal_lld_init+0x60>)
 8001a3a:	6952      	ldr	r2, [r2, #20]
 8001a3c:	f442 02fc 	orr.w	r2, r2, #8257536	; 0x7e0000
 8001a40:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8001a42:	9b01      	ldr	r3, [sp, #4]
 8001a44:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001a48:	4619      	mov	r1, r3
 8001a4a:	f001 fc71 	bl	8003330 <initgpio.9011>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	331c      	adds	r3, #28
 8001a52:	4810      	ldr	r0, [pc, #64]	; (8001a94 <_pal_lld_init+0x64>)
 8001a54:	4619      	mov	r1, r3
 8001a56:	f001 fc6b 	bl	8003330 <initgpio.9011>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8001a5a:	9b01      	ldr	r3, [sp, #4]
 8001a5c:	3338      	adds	r3, #56	; 0x38
 8001a5e:	480e      	ldr	r0, [pc, #56]	; (8001a98 <_pal_lld_init+0x68>)
 8001a60:	4619      	mov	r1, r3
 8001a62:	f001 fc65 	bl	8003330 <initgpio.9011>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8001a66:	9b01      	ldr	r3, [sp, #4]
 8001a68:	3354      	adds	r3, #84	; 0x54
 8001a6a:	480c      	ldr	r0, [pc, #48]	; (8001a9c <_pal_lld_init+0x6c>)
 8001a6c:	4619      	mov	r1, r3
 8001a6e:	f001 fc5f 	bl	8003330 <initgpio.9011>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8001a72:	9b01      	ldr	r3, [sp, #4]
 8001a74:	3370      	adds	r3, #112	; 0x70
 8001a76:	480a      	ldr	r0, [pc, #40]	; (8001aa0 <_pal_lld_init+0x70>)
 8001a78:	4619      	mov	r1, r3
 8001a7a:	f001 fc59 	bl	8003330 <initgpio.9011>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	338c      	adds	r3, #140	; 0x8c
 8001a82:	4808      	ldr	r0, [pc, #32]	; (8001aa4 <_pal_lld_init+0x74>)
 8001a84:	4619      	mov	r1, r3
 8001a86:	f001 fc53 	bl	8003330 <initgpio.9011>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8001a8a:	b003      	add	sp, #12
 8001a8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a90:	40021000 	.word	0x40021000
 8001a94:	48000400 	.word	0x48000400
 8001a98:	48000800 	.word	0x48000800
 8001a9c:	48000c00 	.word	0x48000c00
 8001aa0:	48001000 	.word	0x48001000
 8001aa4:	48001400 	.word	0x48001400
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001ab0:	b08e      	sub	sp, #56	; 0x38
 8001ab2:	9003      	str	r0, [sp, #12]
 8001ab4:	9102      	str	r1, [sp, #8]
 8001ab6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001ab8:	9b01      	ldr	r3, [sp, #4]
 8001aba:	f003 0303 	and.w	r3, r3, #3
 8001abe:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001ac0:	9b01      	ldr	r3, [sp, #4]
 8001ac2:	f003 0304 	and.w	r3, r3, #4
 8001ac6:	089b      	lsrs	r3, r3, #2
 8001ac8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001aca:	9b01      	ldr	r3, [sp, #4]
 8001acc:	f003 0318 	and.w	r3, r3, #24
 8001ad0:	08db      	lsrs	r3, r3, #3
 8001ad2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8001ad4:	9b01      	ldr	r3, [sp, #4]
 8001ad6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8001ada:	095b      	lsrs	r3, r3, #5
 8001adc:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001ade:	9b01      	ldr	r3, [sp, #4]
 8001ae0:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8001ae4:	09db      	lsrs	r3, r3, #7
 8001ae6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001ae8:	2300      	movs	r3, #0
 8001aea:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 8001aec:	9b02      	ldr	r3, [sp, #8]
 8001aee:	f003 0301 	and.w	r3, r3, #1
 8001af2:	2b00      	cmp	r3, #0
 8001af4:	d054      	beq.n	8001ba0 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001af6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001af8:	f003 0307 	and.w	r3, r3, #7
 8001afc:	009b      	lsls	r3, r3, #2
 8001afe:	9a08      	ldr	r2, [sp, #32]
 8001b00:	fa02 f303 	lsl.w	r3, r2, r3
 8001b04:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 8001b06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001b08:	f003 0307 	and.w	r3, r3, #7
 8001b0c:	009b      	lsls	r3, r3, #2
 8001b0e:	220f      	movs	r2, #15
 8001b10:	fa02 f303 	lsl.w	r3, r2, r3
 8001b14:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 8001b16:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001b18:	2b07      	cmp	r3, #7
 8001b1a:	d809      	bhi.n	8001b30 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001b1c:	9b03      	ldr	r3, [sp, #12]
 8001b1e:	6a1a      	ldr	r2, [r3, #32]
 8001b20:	9b06      	ldr	r3, [sp, #24]
 8001b22:	43db      	mvns	r3, r3
 8001b24:	401a      	ands	r2, r3
 8001b26:	9b07      	ldr	r3, [sp, #28]
 8001b28:	431a      	orrs	r2, r3
 8001b2a:	9b03      	ldr	r3, [sp, #12]
 8001b2c:	621a      	str	r2, [r3, #32]
 8001b2e:	e008      	b.n	8001b42 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001b30:	9b03      	ldr	r3, [sp, #12]
 8001b32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001b34:	9b06      	ldr	r3, [sp, #24]
 8001b36:	43db      	mvns	r3, r3
 8001b38:	401a      	ands	r2, r3
 8001b3a:	9b07      	ldr	r3, [sp, #28]
 8001b3c:	431a      	orrs	r2, r3
 8001b3e:	9b03      	ldr	r3, [sp, #12]
 8001b40:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 8001b42:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001b44:	2201      	movs	r2, #1
 8001b46:	fa02 f303 	lsl.w	r3, r2, r3
 8001b4a:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001b4c:	9b03      	ldr	r3, [sp, #12]
 8001b4e:	685a      	ldr	r2, [r3, #4]
 8001b50:	9b05      	ldr	r3, [sp, #20]
 8001b52:	43db      	mvns	r3, r3
 8001b54:	401a      	ands	r2, r3
 8001b56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001b58:	431a      	orrs	r2, r3
 8001b5a:	9b03      	ldr	r3, [sp, #12]
 8001b5c:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 8001b5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001b60:	005b      	lsls	r3, r3, #1
 8001b62:	2203      	movs	r2, #3
 8001b64:	fa02 f303 	lsl.w	r3, r2, r3
 8001b68:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001b6a:	9b03      	ldr	r3, [sp, #12]
 8001b6c:	689a      	ldr	r2, [r3, #8]
 8001b6e:	9b04      	ldr	r3, [sp, #16]
 8001b70:	43db      	mvns	r3, r3
 8001b72:	401a      	ands	r2, r3
 8001b74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001b76:	431a      	orrs	r2, r3
 8001b78:	9b03      	ldr	r3, [sp, #12]
 8001b7a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001b7c:	9b03      	ldr	r3, [sp, #12]
 8001b7e:	68da      	ldr	r2, [r3, #12]
 8001b80:	9b04      	ldr	r3, [sp, #16]
 8001b82:	43db      	mvns	r3, r3
 8001b84:	401a      	ands	r2, r3
 8001b86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001b88:	431a      	orrs	r2, r3
 8001b8a:	9b03      	ldr	r3, [sp, #12]
 8001b8c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8001b8e:	9b03      	ldr	r3, [sp, #12]
 8001b90:	681a      	ldr	r2, [r3, #0]
 8001b92:	9b04      	ldr	r3, [sp, #16]
 8001b94:	43db      	mvns	r3, r3
 8001b96:	401a      	ands	r2, r3
 8001b98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001b9a:	431a      	orrs	r2, r3
 8001b9c:	9b03      	ldr	r3, [sp, #12]
 8001b9e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 8001ba0:	9b02      	ldr	r3, [sp, #8]
 8001ba2:	085b      	lsrs	r3, r3, #1
 8001ba4:	9302      	str	r3, [sp, #8]
    if (!mask)
 8001ba6:	9b02      	ldr	r3, [sp, #8]
 8001ba8:	2b00      	cmp	r3, #0
 8001baa:	d00f      	beq.n	8001bcc <_pal_lld_setgroupmode+0x11c>
      return;
    otyper <<= 1;
 8001bac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001bae:	005b      	lsls	r3, r3, #1
 8001bb0:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8001bb2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001bb4:	009b      	lsls	r3, r3, #2
 8001bb6:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8001bb8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001bba:	009b      	lsls	r3, r3, #2
 8001bbc:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8001bbe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001bc0:	009b      	lsls	r3, r3, #2
 8001bc2:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 8001bc4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001bc6:	3301      	adds	r3, #1
 8001bc8:	9309      	str	r3, [sp, #36]	; 0x24
 8001bca:	e78f      	b.n	8001aec <_pal_lld_setgroupmode+0x3c>
  }
}
 8001bcc:	b00e      	add	sp, #56	; 0x38
 8001bce:	4770      	bx	lr

08001bd0 <port_lock.9083.4500>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001bd0:	b082      	sub	sp, #8
 8001bd2:	2320      	movs	r3, #32
 8001bd4:	9301      	str	r3, [sp, #4]
 8001bd6:	9b01      	ldr	r3, [sp, #4]
 8001bd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001bdc:	b002      	add	sp, #8
 8001bde:	4770      	bx	lr

08001be0 <port_unlock.9086.4498>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001be0:	b082      	sub	sp, #8
 8001be2:	2300      	movs	r3, #0
 8001be4:	9301      	str	r3, [sp, #4]
 8001be6:	9b01      	ldr	r3, [sp, #4]
 8001be8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001bec:	b002      	add	sp, #8
 8001bee:	4770      	bx	lr

08001bf0 <port_lock_from_isr.9088.4496>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001bf0:	b508      	push	{r3, lr}

  port_lock();
 8001bf2:	f7ff ffed 	bl	8001bd0 <port_lock.9083.4500>
}
 8001bf6:	bd08      	pop	{r3, pc}
 8001bf8:	f3af 8000 	nop.w
 8001bfc:	f3af 8000 	nop.w

08001c00 <port_unlock_from_isr.9090.4494>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001c00:	b508      	push	{r3, lr}

  port_unlock();
 8001c02:	f7ff ffed 	bl	8001be0 <port_unlock.9086.4498>
}
 8001c06:	bd08      	pop	{r3, pc}
 8001c08:	f3af 8000 	nop.w
 8001c0c:	f3af 8000 	nop.w

08001c10 <chSysLockFromISR.9092.4492>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001c10:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001c12:	f7ff ffed 	bl	8001bf0 <port_lock_from_isr.9088.4496>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001c16:	bd08      	pop	{r3, pc}
 8001c18:	f3af 8000 	nop.w
 8001c1c:	f3af 8000 	nop.w

08001c20 <chSysUnlockFromISR.9094.4490>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001c20:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001c22:	f7ff ffed 	bl	8001c00 <port_unlock_from_isr.9090.4494>
}
 8001c26:	bd08      	pop	{r3, pc}
 8001c28:	f3af 8000 	nop.w
 8001c2c:	f3af 8000 	nop.w

08001c30 <osalSysHalt.9100.4487>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 8001c30:	b500      	push	{lr}
 8001c32:	b083      	sub	sp, #12
 8001c34:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 8001c36:	9801      	ldr	r0, [sp, #4]
 8001c38:	f003 f99a 	bl	8004f70 <chSysHalt>
}
 8001c3c:	b003      	add	sp, #12
 8001c3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c42:	bf00      	nop
 8001c44:	f3af 8000 	nop.w
 8001c48:	f3af 8000 	nop.w
 8001c4c:	f3af 8000 	nop.w

08001c50 <osalSysLockFromISR.9096.4485>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8001c50:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8001c52:	f7ff ffdd 	bl	8001c10 <chSysLockFromISR.9092.4492>
}
 8001c56:	bd08      	pop	{r3, pc}
 8001c58:	f3af 8000 	nop.w
 8001c5c:	f3af 8000 	nop.w

08001c60 <osalSysUnlockFromISR.9098.4483>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8001c60:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8001c62:	f7ff ffdd 	bl	8001c20 <chSysUnlockFromISR.9094.4490>
}
 8001c66:	bd08      	pop	{r3, pc}
 8001c68:	f3af 8000 	nop.w
 8001c6c:	f3af 8000 	nop.w

08001c70 <osalThreadResumeI.9257.4479>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001c70:	b500      	push	{lr}
 8001c72:	b083      	sub	sp, #12
 8001c74:	9001      	str	r0, [sp, #4]
 8001c76:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8001c78:	9801      	ldr	r0, [sp, #4]
 8001c7a:	9900      	ldr	r1, [sp, #0]
 8001c7c:	f003 ff00 	bl	8005a80 <chThdResumeI>
}
 8001c80:	b003      	add	sp, #12
 8001c82:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c86:	bf00      	nop
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <spi_lld_serve_rx_interrupt.9261.4469>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001c90:	b500      	push	{lr}
 8001c92:	b083      	sub	sp, #12
 8001c94:	9001      	str	r0, [sp, #4]
 8001c96:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001c98:	9b00      	ldr	r3, [sp, #0]
 8001c9a:	f003 0308 	and.w	r3, r3, #8
 8001c9e:	2b00      	cmp	r3, #0
 8001ca0:	d002      	beq.n	8001ca8 <spi_lld_serve_rx_interrupt.9261.4469+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8001ca2:	4828      	ldr	r0, [pc, #160]	; (8001d44 <spi_lld_serve_rx_interrupt.9261.4469+0xb4>)
 8001ca4:	f7ff ffc4 	bl	8001c30 <osalSysHalt.9100.4487>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001cac:	685b      	ldr	r3, [r3, #4]
 8001cae:	9a01      	ldr	r2, [sp, #4]
 8001cb0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001cb2:	6852      	ldr	r2, [r2, #4]
 8001cb4:	6812      	ldr	r2, [r2, #0]
 8001cb6:	f022 020f 	bic.w	r2, r2, #15
 8001cba:	601a      	str	r2, [r3, #0]
 8001cbc:	9b01      	ldr	r3, [sp, #4]
 8001cbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001cc0:	681b      	ldr	r3, [r3, #0]
 8001cc2:	9a01      	ldr	r2, [sp, #4]
 8001cc4:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001cc6:	7c12      	ldrb	r2, [r2, #16]
 8001cc8:	210f      	movs	r1, #15
 8001cca:	fa01 f202 	lsl.w	r2, r1, r2
 8001cce:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 8001cd0:	9b01      	ldr	r3, [sp, #4]
 8001cd2:	6a1b      	ldr	r3, [r3, #32]
 8001cd4:	685b      	ldr	r3, [r3, #4]
 8001cd6:	9a01      	ldr	r2, [sp, #4]
 8001cd8:	6a12      	ldr	r2, [r2, #32]
 8001cda:	6852      	ldr	r2, [r2, #4]
 8001cdc:	6812      	ldr	r2, [r2, #0]
 8001cde:	f022 020f 	bic.w	r2, r2, #15
 8001ce2:	601a      	str	r2, [r3, #0]
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	6a1b      	ldr	r3, [r3, #32]
 8001ce8:	681b      	ldr	r3, [r3, #0]
 8001cea:	9a01      	ldr	r2, [sp, #4]
 8001cec:	6a12      	ldr	r2, [r2, #32]
 8001cee:	7c12      	ldrb	r2, [r2, #16]
 8001cf0:	210f      	movs	r1, #15
 8001cf2:	fa01 f202 	lsl.w	r2, r1, r2
 8001cf6:	605a      	str	r2, [r3, #4]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8001cf8:	9b01      	ldr	r3, [sp, #4]
 8001cfa:	685b      	ldr	r3, [r3, #4]
 8001cfc:	681b      	ldr	r3, [r3, #0]
 8001cfe:	2b00      	cmp	r3, #0
 8001d00:	d00f      	beq.n	8001d22 <spi_lld_serve_rx_interrupt.9261.4469+0x92>
 8001d02:	9b01      	ldr	r3, [sp, #4]
 8001d04:	2204      	movs	r2, #4
 8001d06:	701a      	strb	r2, [r3, #0]
 8001d08:	9b01      	ldr	r3, [sp, #4]
 8001d0a:	685b      	ldr	r3, [r3, #4]
 8001d0c:	681b      	ldr	r3, [r3, #0]
 8001d0e:	9801      	ldr	r0, [sp, #4]
 8001d10:	4798      	blx	r3
 8001d12:	9b01      	ldr	r3, [sp, #4]
 8001d14:	781b      	ldrb	r3, [r3, #0]
 8001d16:	2b04      	cmp	r3, #4
 8001d18:	d106      	bne.n	8001d28 <spi_lld_serve_rx_interrupt.9261.4469+0x98>
 8001d1a:	9b01      	ldr	r3, [sp, #4]
 8001d1c:	2202      	movs	r2, #2
 8001d1e:	701a      	strb	r2, [r3, #0]
 8001d20:	e002      	b.n	8001d28 <spi_lld_serve_rx_interrupt.9261.4469+0x98>
 8001d22:	9b01      	ldr	r3, [sp, #4]
 8001d24:	2202      	movs	r2, #2
 8001d26:	701a      	strb	r2, [r3, #0]
 8001d28:	f7ff ff92 	bl	8001c50 <osalSysLockFromISR.9096.4485>
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	3308      	adds	r3, #8
 8001d30:	4618      	mov	r0, r3
 8001d32:	2100      	movs	r1, #0
 8001d34:	f7ff ff9c 	bl	8001c70 <osalThreadResumeI.9257.4479>
 8001d38:	f7ff ff92 	bl	8001c60 <osalSysUnlockFromISR.9098.4483>
}
 8001d3c:	b003      	add	sp, #12
 8001d3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d42:	bf00      	nop
 8001d44:	080065d0 	.word	0x080065d0
 8001d48:	f3af 8000 	nop.w
 8001d4c:	f3af 8000 	nop.w

08001d50 <spi_lld_serve_tx_interrupt.9104.4473>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001d50:	b500      	push	{lr}
 8001d52:	b083      	sub	sp, #12
 8001d54:	9001      	str	r0, [sp, #4]
 8001d56:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001d58:	9b00      	ldr	r3, [sp, #0]
 8001d5a:	f003 0308 	and.w	r3, r3, #8
 8001d5e:	2b00      	cmp	r3, #0
 8001d60:	d002      	beq.n	8001d68 <spi_lld_serve_tx_interrupt.9104.4473+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8001d62:	4803      	ldr	r0, [pc, #12]	; (8001d70 <spi_lld_serve_tx_interrupt.9104.4473+0x20>)
 8001d64:	f7ff ff64 	bl	8001c30 <osalSysHalt.9100.4487>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 8001d68:	b003      	add	sp, #12
 8001d6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d6e:	bf00      	nop
 8001d70:	080065d0 	.word	0x080065d0
 8001d74:	f3af 8000 	nop.w
 8001d78:	f3af 8000 	nop.w
 8001d7c:	f3af 8000 	nop.w

08001d80 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8001d80:	b508      	push	{r3, lr}

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8001d82:	4814      	ldr	r0, [pc, #80]	; (8001dd4 <spi_lld_init+0x54>)
 8001d84:	f001 fd24 	bl	80037d0 <spiObjectInit>
  SPID1.spi       = SPI1;
 8001d88:	4b12      	ldr	r3, [pc, #72]	; (8001dd4 <spi_lld_init+0x54>)
 8001d8a:	4a13      	ldr	r2, [pc, #76]	; (8001dd8 <spi_lld_init+0x58>)
 8001d8c:	61da      	str	r2, [r3, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8001d8e:	4b11      	ldr	r3, [pc, #68]	; (8001dd4 <spi_lld_init+0x54>)
 8001d90:	4a12      	ldr	r2, [pc, #72]	; (8001ddc <spi_lld_init+0x5c>)
 8001d92:	621a      	str	r2, [r3, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8001d94:	4b0f      	ldr	r3, [pc, #60]	; (8001dd4 <spi_lld_init+0x54>)
 8001d96:	4a12      	ldr	r2, [pc, #72]	; (8001de0 <spi_lld_init+0x60>)
 8001d98:	625a      	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8001d9a:	4b0e      	ldr	r3, [pc, #56]	; (8001dd4 <spi_lld_init+0x54>)
 8001d9c:	f241 020a 	movw	r2, #4106	; 0x100a
 8001da0:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8001da2:	4b0c      	ldr	r3, [pc, #48]	; (8001dd4 <spi_lld_init+0x54>)
 8001da4:	f241 0218 	movw	r2, #4120	; 0x1018
 8001da8:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
 8001daa:	480e      	ldr	r0, [pc, #56]	; (8001de4 <spi_lld_init+0x64>)
 8001dac:	f001 fd10 	bl	80037d0 <spiObjectInit>
  SPID3.spi       = SPI3;
 8001db0:	4b0c      	ldr	r3, [pc, #48]	; (8001de4 <spi_lld_init+0x64>)
 8001db2:	4a0d      	ldr	r2, [pc, #52]	; (8001de8 <spi_lld_init+0x68>)
 8001db4:	61da      	str	r2, [r3, #28]
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
 8001db6:	4b0b      	ldr	r3, [pc, #44]	; (8001de4 <spi_lld_init+0x64>)
 8001db8:	4a0c      	ldr	r2, [pc, #48]	; (8001dec <spi_lld_init+0x6c>)
 8001dba:	621a      	str	r2, [r3, #32]
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 8001dbc:	4b09      	ldr	r3, [pc, #36]	; (8001de4 <spi_lld_init+0x64>)
 8001dbe:	4a0c      	ldr	r2, [pc, #48]	; (8001df0 <spi_lld_init+0x70>)
 8001dc0:	625a      	str	r2, [r3, #36]	; 0x24
  SPID3.rxdmamode = STM32_DMA_CR_CHSEL(SPI3_RX_DMA_CHANNEL) |
 8001dc2:	4b08      	ldr	r3, [pc, #32]	; (8001de4 <spi_lld_init+0x64>)
 8001dc4:	f241 020a 	movw	r2, #4106	; 0x100a
 8001dc8:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
 8001dca:	4b06      	ldr	r3, [pc, #24]	; (8001de4 <spi_lld_init+0x64>)
 8001dcc:	f241 0218 	movw	r2, #4120	; 0x1018
 8001dd0:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 8001dd2:	bd08      	pop	{r3, pc}
 8001dd4:	20000b3c 	.word	0x20000b3c
 8001dd8:	40013000 	.word	0x40013000
 8001ddc:	080068e4 	.word	0x080068e4
 8001de0:	080068f8 	.word	0x080068f8
 8001de4:	20000b70 	.word	0x20000b70
 8001de8:	40003c00 	.word	0x40003c00
 8001dec:	0800695c 	.word	0x0800695c
 8001df0:	08006970 	.word	0x08006970
 8001df4:	f3af 8000 	nop.w
 8001df8:	f3af 8000 	nop.w
 8001dfc:	f3af 8000 	nop.w

08001e00 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 8001e00:	b500      	push	{lr}
 8001e02:	b085      	sub	sp, #20
 8001e04:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8001e06:	9b01      	ldr	r3, [sp, #4]
 8001e08:	781b      	ldrb	r3, [r3, #0]
 8001e0a:	2b01      	cmp	r3, #1
 8001e0c:	d14d      	bne.n	8001eaa <spi_lld_start+0xaa>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
 8001e0e:	9a01      	ldr	r2, [sp, #4]
 8001e10:	4b4f      	ldr	r3, [pc, #316]	; (8001f50 <spi_lld_start+0x150>)
 8001e12:	429a      	cmp	r2, r3
 8001e14:	d11b      	bne.n	8001e4e <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8001e16:	9b01      	ldr	r3, [sp, #4]
 8001e18:	6a1b      	ldr	r3, [r3, #32]
 8001e1a:	4618      	mov	r0, r3
 8001e1c:	210a      	movs	r1, #10
 8001e1e:	4a4d      	ldr	r2, [pc, #308]	; (8001f54 <spi_lld_start+0x154>)
 8001e20:	9b01      	ldr	r3, [sp, #4]
 8001e22:	f000 fe8d 	bl	8002b40 <dmaStreamAllocate>
 8001e26:	4603      	mov	r3, r0
 8001e28:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e30:	4618      	mov	r0, r3
 8001e32:	210a      	movs	r1, #10
 8001e34:	4a48      	ldr	r2, [pc, #288]	; (8001f58 <spi_lld_start+0x158>)
 8001e36:	9b01      	ldr	r3, [sp, #4]
 8001e38:	f000 fe82 	bl	8002b40 <dmaStreamAllocate>
 8001e3c:	4603      	mov	r3, r0
 8001e3e:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 8001e42:	4b46      	ldr	r3, [pc, #280]	; (8001f5c <spi_lld_start+0x15c>)
 8001e44:	4a45      	ldr	r2, [pc, #276]	; (8001f5c <spi_lld_start+0x15c>)
 8001e46:	6992      	ldr	r2, [r2, #24]
 8001e48:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001e4c:	619a      	str	r2, [r3, #24]
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI3
    if (&SPID3 == spip) {
 8001e4e:	9a01      	ldr	r2, [sp, #4]
 8001e50:	4b43      	ldr	r3, [pc, #268]	; (8001f60 <spi_lld_start+0x160>)
 8001e52:	429a      	cmp	r2, r3
 8001e54:	d11b      	bne.n	8001e8e <spi_lld_start+0x8e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8001e56:	9b01      	ldr	r3, [sp, #4]
 8001e58:	6a1b      	ldr	r3, [r3, #32]
 8001e5a:	4618      	mov	r0, r3
 8001e5c:	210a      	movs	r1, #10
 8001e5e:	4a3d      	ldr	r2, [pc, #244]	; (8001f54 <spi_lld_start+0x154>)
 8001e60:	9b01      	ldr	r3, [sp, #4]
 8001e62:	f000 fe6d 	bl	8002b40 <dmaStreamAllocate>
 8001e66:	4603      	mov	r3, r0
 8001e68:	f88d 300e 	strb.w	r3, [sp, #14]
                            STM32_SPI_SPI3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8001e6c:	9b01      	ldr	r3, [sp, #4]
 8001e6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e70:	4618      	mov	r0, r3
 8001e72:	210a      	movs	r1, #10
 8001e74:	4a38      	ldr	r2, [pc, #224]	; (8001f58 <spi_lld_start+0x158>)
 8001e76:	9b01      	ldr	r3, [sp, #4]
 8001e78:	f000 fe62 	bl	8002b40 <dmaStreamAllocate>
 8001e7c:	4603      	mov	r3, r0
 8001e7e:	f88d 300e 	strb.w	r3, [sp, #14]
                            STM32_SPI_SPI3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI3(FALSE);
 8001e82:	4b36      	ldr	r3, [pc, #216]	; (8001f5c <spi_lld_start+0x15c>)
 8001e84:	4a35      	ldr	r2, [pc, #212]	; (8001f5c <spi_lld_start+0x15c>)
 8001e86:	69d2      	ldr	r2, [r2, #28]
 8001e88:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001e8c:	61da      	str	r2, [r3, #28]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8001e8e:	9b01      	ldr	r3, [sp, #4]
 8001e90:	6a1b      	ldr	r3, [r3, #32]
 8001e92:	685b      	ldr	r3, [r3, #4]
 8001e94:	9a01      	ldr	r2, [sp, #4]
 8001e96:	69d2      	ldr	r2, [r2, #28]
 8001e98:	320c      	adds	r2, #12
 8001e9a:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8001e9c:	9b01      	ldr	r3, [sp, #4]
 8001e9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001ea0:	685b      	ldr	r3, [r3, #4]
 8001ea2:	9a01      	ldr	r2, [sp, #4]
 8001ea4:	69d2      	ldr	r2, [r2, #28]
 8001ea6:	320c      	adds	r2, #12
 8001ea8:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 8001eaa:	9b01      	ldr	r3, [sp, #4]
 8001eac:	685b      	ldr	r3, [r3, #4]
 8001eae:	899b      	ldrh	r3, [r3, #12]
 8001eb0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8001eb4:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 8001eb6:	9b02      	ldr	r3, [sp, #8]
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d003      	beq.n	8001ec4 <spi_lld_start+0xc4>
 8001ebc:	9b02      	ldr	r3, [sp, #8]
 8001ebe:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8001ec2:	d80f      	bhi.n	8001ee4 <spi_lld_start+0xe4>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ec4:	9b01      	ldr	r3, [sp, #4]
 8001ec6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8001ec8:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ecc:	9b01      	ldr	r3, [sp, #4]
 8001ece:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ed0:	9b01      	ldr	r3, [sp, #4]
 8001ed2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8001ed4:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ed8:	9b01      	ldr	r3, [sp, #4]
 8001eda:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->fsize     = sizeof (uint8_t);
 8001edc:	9b01      	ldr	r3, [sp, #4]
 8001ede:	2201      	movs	r2, #1
 8001ee0:	631a      	str	r2, [r3, #48]	; 0x30
 8001ee2:	e012      	b.n	8001f0a <spi_lld_start+0x10a>
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ee4:	9b01      	ldr	r3, [sp, #4]
 8001ee6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001ee8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8001eec:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->fsize     = sizeof (uint8_t);
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ef0:	9b01      	ldr	r3, [sp, #4]
 8001ef2:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001ef4:	9b01      	ldr	r3, [sp, #4]
 8001ef6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ef8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8001efc:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001f00:	9b01      	ldr	r3, [sp, #4]
 8001f02:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->fsize     = sizeof (uint16_t);
 8001f04:	9b01      	ldr	r3, [sp, #4]
 8001f06:	2202      	movs	r2, #2
 8001f08:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8001f0a:	9b01      	ldr	r3, [sp, #4]
 8001f0c:	69db      	ldr	r3, [r3, #28]
 8001f0e:	2200      	movs	r2, #0
 8001f10:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 8001f12:	9b01      	ldr	r3, [sp, #4]
 8001f14:	69db      	ldr	r3, [r3, #28]
 8001f16:	9a01      	ldr	r2, [sp, #4]
 8001f18:	6852      	ldr	r2, [r2, #4]
 8001f1a:	8952      	ldrh	r2, [r2, #10]
 8001f1c:	f042 0204 	orr.w	r2, r2, #4
 8001f20:	b292      	uxth	r2, r2
 8001f22:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 8001f24:	9b01      	ldr	r3, [sp, #4]
 8001f26:	69da      	ldr	r2, [r3, #28]
 8001f28:	9b01      	ldr	r3, [sp, #4]
 8001f2a:	685b      	ldr	r3, [r3, #4]
 8001f2c:	899b      	ldrh	r3, [r3, #12]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8001f2e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001f32:	f043 0307 	orr.w	r3, r3, #7
 8001f36:	b29b      	uxth	r3, r3
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 8001f38:	6053      	str	r3, [r2, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 8001f3a:	9b01      	ldr	r3, [sp, #4]
 8001f3c:	69db      	ldr	r3, [r3, #28]
 8001f3e:	9a01      	ldr	r2, [sp, #4]
 8001f40:	69d2      	ldr	r2, [r2, #28]
 8001f42:	6812      	ldr	r2, [r2, #0]
 8001f44:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001f48:	601a      	str	r2, [r3, #0]
}
 8001f4a:	b005      	add	sp, #20
 8001f4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f50:	20000b3c 	.word	0x20000b3c
 8001f54:	08001c91 	.word	0x08001c91
 8001f58:	08001d51 	.word	0x08001d51
 8001f5c:	40021000 	.word	0x40021000
 8001f60:	20000b70 	.word	0x20000b70
 8001f64:	f3af 8000 	nop.w
 8001f68:	f3af 8000 	nop.w
 8001f6c:	f3af 8000 	nop.w

08001f70 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 8001f70:	b082      	sub	sp, #8
 8001f72:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 8001f74:	9b01      	ldr	r3, [sp, #4]
 8001f76:	685b      	ldr	r3, [r3, #4]
 8001f78:	685b      	ldr	r3, [r3, #4]
 8001f7a:	9a01      	ldr	r2, [sp, #4]
 8001f7c:	6852      	ldr	r2, [r2, #4]
 8001f7e:	8912      	ldrh	r2, [r2, #8]
 8001f80:	2101      	movs	r1, #1
 8001f82:	fa01 f202 	lsl.w	r2, r1, r2
 8001f86:	b292      	uxth	r2, r2
 8001f88:	835a      	strh	r2, [r3, #26]
}
 8001f8a:	b002      	add	sp, #8
 8001f8c:	4770      	bx	lr
 8001f8e:	bf00      	nop

08001f90 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 8001f90:	b082      	sub	sp, #8
 8001f92:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 8001f94:	9b01      	ldr	r3, [sp, #4]
 8001f96:	685b      	ldr	r3, [r3, #4]
 8001f98:	685b      	ldr	r3, [r3, #4]
 8001f9a:	9a01      	ldr	r2, [sp, #4]
 8001f9c:	6852      	ldr	r2, [r2, #4]
 8001f9e:	8912      	ldrh	r2, [r2, #8]
 8001fa0:	2101      	movs	r1, #1
 8001fa2:	fa01 f202 	lsl.w	r2, r1, r2
 8001fa6:	b292      	uxth	r2, r2
 8001fa8:	831a      	strh	r2, [r3, #24]
}
 8001faa:	b002      	add	sp, #8
 8001fac:	4770      	bx	lr
 8001fae:	bf00      	nop

08001fb0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8001fb0:	b084      	sub	sp, #16
 8001fb2:	9003      	str	r0, [sp, #12]
 8001fb4:	9102      	str	r1, [sp, #8]
 8001fb6:	9201      	str	r2, [sp, #4]
 8001fb8:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8001fba:	9b03      	ldr	r3, [sp, #12]
 8001fbc:	6a1b      	ldr	r3, [r3, #32]
 8001fbe:	685b      	ldr	r3, [r3, #4]
 8001fc0:	9a00      	ldr	r2, [sp, #0]
 8001fc2:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8001fc4:	9b03      	ldr	r3, [sp, #12]
 8001fc6:	6a1b      	ldr	r3, [r3, #32]
 8001fc8:	685b      	ldr	r3, [r3, #4]
 8001fca:	9a02      	ldr	r2, [sp, #8]
 8001fcc:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8001fce:	9b03      	ldr	r3, [sp, #12]
 8001fd0:	6a1b      	ldr	r3, [r3, #32]
 8001fd2:	685b      	ldr	r3, [r3, #4]
 8001fd4:	9a03      	ldr	r2, [sp, #12]
 8001fd6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001fd8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001fdc:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8001fde:	9b03      	ldr	r3, [sp, #12]
 8001fe0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fe2:	685b      	ldr	r3, [r3, #4]
 8001fe4:	9a01      	ldr	r2, [sp, #4]
 8001fe6:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8001fe8:	9b03      	ldr	r3, [sp, #12]
 8001fea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fec:	685b      	ldr	r3, [r3, #4]
 8001fee:	9a02      	ldr	r2, [sp, #8]
 8001ff0:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8001ff2:	9b03      	ldr	r3, [sp, #12]
 8001ff4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001ff6:	685b      	ldr	r3, [r3, #4]
 8001ff8:	9a03      	ldr	r2, [sp, #12]
 8001ffa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001ffc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002000:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8002002:	9b03      	ldr	r3, [sp, #12]
 8002004:	6a1b      	ldr	r3, [r3, #32]
 8002006:	685b      	ldr	r3, [r3, #4]
 8002008:	9a03      	ldr	r2, [sp, #12]
 800200a:	6a12      	ldr	r2, [r2, #32]
 800200c:	6852      	ldr	r2, [r2, #4]
 800200e:	6812      	ldr	r2, [r2, #0]
 8002010:	f042 0201 	orr.w	r2, r2, #1
 8002014:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 8002016:	9b03      	ldr	r3, [sp, #12]
 8002018:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800201a:	685b      	ldr	r3, [r3, #4]
 800201c:	9a03      	ldr	r2, [sp, #12]
 800201e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8002020:	6852      	ldr	r2, [r2, #4]
 8002022:	6812      	ldr	r2, [r2, #0]
 8002024:	f042 0201 	orr.w	r2, r2, #1
 8002028:	601a      	str	r2, [r3, #0]
}
 800202a:	b004      	add	sp, #16
 800202c:	4770      	bx	lr
 800202e:	bf00      	nop

08002030 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 8002030:	b084      	sub	sp, #16
 8002032:	9003      	str	r0, [sp, #12]
 8002034:	9102      	str	r1, [sp, #8]
 8002036:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8002038:	9b03      	ldr	r3, [sp, #12]
 800203a:	6a1b      	ldr	r3, [r3, #32]
 800203c:	685b      	ldr	r3, [r3, #4]
 800203e:	4a1a      	ldr	r2, [pc, #104]	; (80020a8 <spi_lld_send+0x78>)
 8002040:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8002042:	9b03      	ldr	r3, [sp, #12]
 8002044:	6a1b      	ldr	r3, [r3, #32]
 8002046:	685b      	ldr	r3, [r3, #4]
 8002048:	9a02      	ldr	r2, [sp, #8]
 800204a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800204c:	9b03      	ldr	r3, [sp, #12]
 800204e:	6a1b      	ldr	r3, [r3, #32]
 8002050:	685b      	ldr	r3, [r3, #4]
 8002052:	9a03      	ldr	r2, [sp, #12]
 8002054:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8002056:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8002058:	9b03      	ldr	r3, [sp, #12]
 800205a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800205c:	685b      	ldr	r3, [r3, #4]
 800205e:	9a01      	ldr	r2, [sp, #4]
 8002060:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8002062:	9b03      	ldr	r3, [sp, #12]
 8002064:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002066:	685b      	ldr	r3, [r3, #4]
 8002068:	9a02      	ldr	r2, [sp, #8]
 800206a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800206c:	9b03      	ldr	r3, [sp, #12]
 800206e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002070:	685b      	ldr	r3, [r3, #4]
 8002072:	9a03      	ldr	r2, [sp, #12]
 8002074:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8002076:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800207a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800207c:	9b03      	ldr	r3, [sp, #12]
 800207e:	6a1b      	ldr	r3, [r3, #32]
 8002080:	685b      	ldr	r3, [r3, #4]
 8002082:	9a03      	ldr	r2, [sp, #12]
 8002084:	6a12      	ldr	r2, [r2, #32]
 8002086:	6852      	ldr	r2, [r2, #4]
 8002088:	6812      	ldr	r2, [r2, #0]
 800208a:	f042 0201 	orr.w	r2, r2, #1
 800208e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 8002090:	9b03      	ldr	r3, [sp, #12]
 8002092:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002094:	685b      	ldr	r3, [r3, #4]
 8002096:	9a03      	ldr	r2, [sp, #12]
 8002098:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800209a:	6852      	ldr	r2, [r2, #4]
 800209c:	6812      	ldr	r2, [r2, #0]
 800209e:	f042 0201 	orr.w	r2, r2, #1
 80020a2:	601a      	str	r2, [r3, #0]
}
 80020a4:	b004      	add	sp, #16
 80020a6:	4770      	bx	lr
 80020a8:	20000ba4 	.word	0x20000ba4
 80020ac:	f3af 8000 	nop.w

080020b0 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 80020b0:	b084      	sub	sp, #16
 80020b2:	9003      	str	r0, [sp, #12]
 80020b4:	9102      	str	r1, [sp, #8]
 80020b6:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80020b8:	9b03      	ldr	r3, [sp, #12]
 80020ba:	6a1b      	ldr	r3, [r3, #32]
 80020bc:	685b      	ldr	r3, [r3, #4]
 80020be:	9a01      	ldr	r2, [sp, #4]
 80020c0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80020c2:	9b03      	ldr	r3, [sp, #12]
 80020c4:	6a1b      	ldr	r3, [r3, #32]
 80020c6:	685b      	ldr	r3, [r3, #4]
 80020c8:	9a02      	ldr	r2, [sp, #8]
 80020ca:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 80020cc:	9b03      	ldr	r3, [sp, #12]
 80020ce:	6a1b      	ldr	r3, [r3, #32]
 80020d0:	685b      	ldr	r3, [r3, #4]
 80020d2:	9a03      	ldr	r2, [sp, #12]
 80020d4:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80020d6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80020da:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 80020dc:	9b03      	ldr	r3, [sp, #12]
 80020de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020e0:	685b      	ldr	r3, [r3, #4]
 80020e2:	4a11      	ldr	r2, [pc, #68]	; (8002128 <spi_lld_receive+0x78>)
 80020e4:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80020e6:	9b03      	ldr	r3, [sp, #12]
 80020e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020ea:	685b      	ldr	r3, [r3, #4]
 80020ec:	9a02      	ldr	r2, [sp, #8]
 80020ee:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 80020f0:	9b03      	ldr	r3, [sp, #12]
 80020f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020f4:	685b      	ldr	r3, [r3, #4]
 80020f6:	9a03      	ldr	r2, [sp, #12]
 80020f8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80020fa:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 80020fc:	9b03      	ldr	r3, [sp, #12]
 80020fe:	6a1b      	ldr	r3, [r3, #32]
 8002100:	685b      	ldr	r3, [r3, #4]
 8002102:	9a03      	ldr	r2, [sp, #12]
 8002104:	6a12      	ldr	r2, [r2, #32]
 8002106:	6852      	ldr	r2, [r2, #4]
 8002108:	6812      	ldr	r2, [r2, #0]
 800210a:	f042 0201 	orr.w	r2, r2, #1
 800210e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 8002110:	9b03      	ldr	r3, [sp, #12]
 8002112:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002114:	685b      	ldr	r3, [r3, #4]
 8002116:	9a03      	ldr	r2, [sp, #12]
 8002118:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800211a:	6852      	ldr	r2, [r2, #4]
 800211c:	6812      	ldr	r2, [r2, #0]
 800211e:	f042 0201 	orr.w	r2, r2, #1
 8002122:	601a      	str	r2, [r3, #0]
}
 8002124:	b004      	add	sp, #16
 8002126:	4770      	bx	lr
 8002128:	080069c0 	.word	0x080069c0
 800212c:	f3af 8000 	nop.w

08002130 <port_lock.9335.4356>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002130:	b082      	sub	sp, #8
 8002132:	2320      	movs	r3, #32
 8002134:	9301      	str	r3, [sp, #4]
 8002136:	9b01      	ldr	r3, [sp, #4]
 8002138:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800213c:	b002      	add	sp, #8
 800213e:	4770      	bx	lr

08002140 <port_unlock.9338.4354>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002140:	b082      	sub	sp, #8
 8002142:	2300      	movs	r3, #0
 8002144:	9301      	str	r3, [sp, #4]
 8002146:	9b01      	ldr	r3, [sp, #4]
 8002148:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800214c:	b002      	add	sp, #8
 800214e:	4770      	bx	lr

08002150 <port_lock_from_isr.9340.4352>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002150:	b508      	push	{r3, lr}

  port_lock();
 8002152:	f7ff ffed 	bl	8002130 <port_lock.9335.4356>
}
 8002156:	bd08      	pop	{r3, pc}
 8002158:	f3af 8000 	nop.w
 800215c:	f3af 8000 	nop.w

08002160 <port_unlock_from_isr.9342.4350>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002160:	b508      	push	{r3, lr}

  port_unlock();
 8002162:	f7ff ffed 	bl	8002140 <port_unlock.9338.4354>
}
 8002166:	bd08      	pop	{r3, pc}
 8002168:	f3af 8000 	nop.w
 800216c:	f3af 8000 	nop.w

08002170 <chSysLockFromISR.9344.4348>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002170:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002172:	f7ff ffed 	bl	8002150 <port_lock_from_isr.9340.4352>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002176:	bd08      	pop	{r3, pc}
 8002178:	f3af 8000 	nop.w
 800217c:	f3af 8000 	nop.w

08002180 <chSysUnlockFromISR.9346.4346>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002180:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002182:	f7ff ffed 	bl	8002160 <port_unlock_from_isr.9342.4350>
}
 8002186:	bd08      	pop	{r3, pc}
 8002188:	f3af 8000 	nop.w
 800218c:	f3af 8000 	nop.w

08002190 <chOQIsEmptyI.9348.4343>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8002190:	b082      	sub	sp, #8
 8002192:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002194:	9b01      	ldr	r3, [sp, #4]
 8002196:	695a      	ldr	r2, [r3, #20]
 8002198:	9b01      	ldr	r3, [sp, #4]
 800219a:	699b      	ldr	r3, [r3, #24]
 800219c:	429a      	cmp	r2, r3
 800219e:	d105      	bne.n	80021ac <chOQIsEmptyI.9348.4343+0x1c>
 80021a0:	9b01      	ldr	r3, [sp, #4]
 80021a2:	689b      	ldr	r3, [r3, #8]
 80021a4:	2b00      	cmp	r3, #0
 80021a6:	d001      	beq.n	80021ac <chOQIsEmptyI.9348.4343+0x1c>
 80021a8:	2301      	movs	r3, #1
 80021aa:	e000      	b.n	80021ae <chOQIsEmptyI.9348.4343+0x1e>
 80021ac:	2300      	movs	r3, #0
 80021ae:	f003 0301 	and.w	r3, r3, #1
 80021b2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 80021b4:	4618      	mov	r0, r3
 80021b6:	b002      	add	sp, #8
 80021b8:	4770      	bx	lr
 80021ba:	bf00      	nop
 80021bc:	f3af 8000 	nop.w

080021c0 <osalSysLockFromISR.9440.4341>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80021c0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80021c2:	f7ff ffd5 	bl	8002170 <chSysLockFromISR.9344.4348>
}
 80021c6:	bd08      	pop	{r3, pc}
 80021c8:	f3af 8000 	nop.w
 80021cc:	f3af 8000 	nop.w

080021d0 <osalSysUnlockFromISR.9442.4339>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80021d0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80021d2:	f7ff ffd5 	bl	8002180 <chSysUnlockFromISR.9346.4346>
}
 80021d6:	bd08      	pop	{r3, pc}
 80021d8:	f3af 8000 	nop.w
 80021dc:	f3af 8000 	nop.w

080021e0 <osalEventBroadcastFlagsI.9447.4335>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80021e0:	b500      	push	{lr}
 80021e2:	b083      	sub	sp, #12
 80021e4:	9001      	str	r0, [sp, #4]
 80021e6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80021e8:	9801      	ldr	r0, [sp, #4]
 80021ea:	9900      	ldr	r1, [sp, #0]
 80021ec:	f002 fbf0 	bl	80049d0 <chEvtBroadcastFlagsI>
}
 80021f0:	b003      	add	sp, #12
 80021f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80021f6:	bf00      	nop
 80021f8:	f3af 8000 	nop.w
 80021fc:	f3af 8000 	nop.w

08002200 <usart_init.9462.4331>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8002200:	b084      	sub	sp, #16
 8002202:	9001      	str	r0, [sp, #4]
 8002204:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8002206:	9b01      	ldr	r3, [sp, #4]
 8002208:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800220a:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800220c:	9b01      	ldr	r3, [sp, #4]
 800220e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8002210:	9b00      	ldr	r3, [sp, #0]
 8002212:	681b      	ldr	r3, [r3, #0]
 8002214:	fbb2 f2f3 	udiv	r2, r2, r3
 8002218:	9b03      	ldr	r3, [sp, #12]
 800221a:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800221c:	9b00      	ldr	r3, [sp, #0]
 800221e:	689b      	ldr	r3, [r3, #8]
 8002220:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8002224:	9b03      	ldr	r3, [sp, #12]
 8002226:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002228:	9b00      	ldr	r3, [sp, #0]
 800222a:	68db      	ldr	r3, [r3, #12]
 800222c:	f043 0201 	orr.w	r2, r3, #1
 8002230:	9b03      	ldr	r3, [sp, #12]
 8002232:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002234:	9b00      	ldr	r3, [sp, #0]
 8002236:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002238:	f443 7396 	orr.w	r3, r3, #300	; 0x12c
 800223c:	f043 0301 	orr.w	r3, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002240:	9a03      	ldr	r2, [sp, #12]
 8002242:	6013      	str	r3, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8002244:	9b03      	ldr	r3, [sp, #12]
 8002246:	f04f 32ff 	mov.w	r2, #4294967295
 800224a:	621a      	str	r2, [r3, #32]
}
 800224c:	b004      	add	sp, #16
 800224e:	4770      	bx	lr

08002250 <set_error.9516.4324>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8002250:	b500      	push	{lr}
 8002252:	b085      	sub	sp, #20
 8002254:	9001      	str	r0, [sp, #4]
 8002256:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8002258:	2300      	movs	r3, #0
 800225a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800225c:	9b00      	ldr	r3, [sp, #0]
 800225e:	f003 0308 	and.w	r3, r3, #8
 8002262:	2b00      	cmp	r3, #0
 8002264:	d003      	beq.n	800226e <set_error.9516.4324+0x1e>
    sts |= SD_OVERRUN_ERROR;
 8002266:	9b03      	ldr	r3, [sp, #12]
 8002268:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800226c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800226e:	9b00      	ldr	r3, [sp, #0]
 8002270:	f003 0301 	and.w	r3, r3, #1
 8002274:	2b00      	cmp	r3, #0
 8002276:	d003      	beq.n	8002280 <set_error.9516.4324+0x30>
    sts |= SD_PARITY_ERROR;
 8002278:	9b03      	ldr	r3, [sp, #12]
 800227a:	f043 0320 	orr.w	r3, r3, #32
 800227e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 8002280:	9b00      	ldr	r3, [sp, #0]
 8002282:	f003 0302 	and.w	r3, r3, #2
 8002286:	2b00      	cmp	r3, #0
 8002288:	d003      	beq.n	8002292 <set_error.9516.4324+0x42>
    sts |= SD_FRAMING_ERROR;
 800228a:	9b03      	ldr	r3, [sp, #12]
 800228c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002290:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 8002292:	9b00      	ldr	r3, [sp, #0]
 8002294:	f003 0304 	and.w	r3, r3, #4
 8002298:	2b00      	cmp	r3, #0
 800229a:	d003      	beq.n	80022a4 <set_error.9516.4324+0x54>
    sts |= SD_NOISE_ERROR;
 800229c:	9b03      	ldr	r3, [sp, #12]
 800229e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80022a2:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 80022a4:	f7ff ff8c 	bl	80021c0 <osalSysLockFromISR.9440.4341>
  chnAddFlagsI(sdp, sts);
 80022a8:	9b01      	ldr	r3, [sp, #4]
 80022aa:	3304      	adds	r3, #4
 80022ac:	4618      	mov	r0, r3
 80022ae:	9903      	ldr	r1, [sp, #12]
 80022b0:	f7ff ff96 	bl	80021e0 <osalEventBroadcastFlagsI.9447.4335>
  osalSysUnlockFromISR();
 80022b4:	f7ff ff8c 	bl	80021d0 <osalSysUnlockFromISR.9442.4339>
}
 80022b8:	b005      	add	sp, #20
 80022ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80022be:	bf00      	nop

080022c0 <serve_interrupt.9520.4321>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 80022c0:	b500      	push	{lr}
 80022c2:	b087      	sub	sp, #28
 80022c4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 80022c6:	9b01      	ldr	r3, [sp, #4]
 80022c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80022ca:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 80022cc:	9b05      	ldr	r3, [sp, #20]
 80022ce:	681b      	ldr	r3, [r3, #0]
 80022d0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80022d2:	9b05      	ldr	r3, [sp, #20]
 80022d4:	69db      	ldr	r3, [r3, #28]
 80022d6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 80022d8:	9b05      	ldr	r3, [sp, #20]
 80022da:	9a03      	ldr	r2, [sp, #12]
 80022dc:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80022de:	9b03      	ldr	r3, [sp, #12]
 80022e0:	f003 030f 	and.w	r3, r3, #15
 80022e4:	2b00      	cmp	r3, #0
 80022e6:	d003      	beq.n	80022f0 <serve_interrupt.9520.4321+0x30>
    set_error(sdp, isr);
 80022e8:	9801      	ldr	r0, [sp, #4]
 80022ea:	9903      	ldr	r1, [sp, #12]
 80022ec:	f7ff ffb0 	bl	8002250 <set_error.9516.4324>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80022f0:	9b03      	ldr	r3, [sp, #12]
 80022f2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d00a      	beq.n	8002310 <serve_interrupt.9520.4321+0x50>
    osalSysLockFromISR();
 80022fa:	f7ff ff61 	bl	80021c0 <osalSysLockFromISR.9440.4341>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80022fe:	9b01      	ldr	r3, [sp, #4]
 8002300:	3304      	adds	r3, #4
 8002302:	4618      	mov	r0, r3
 8002304:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002308:	f7ff ff6a 	bl	80021e0 <osalEventBroadcastFlagsI.9447.4335>
    osalSysUnlockFromISR();
 800230c:	f7ff ff60 	bl	80021d0 <osalSysUnlockFromISR.9442.4339>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8002310:	9b03      	ldr	r3, [sp, #12]
 8002312:	f003 0320 	and.w	r3, r3, #32
 8002316:	2b00      	cmp	r3, #0
 8002318:	d00b      	beq.n	8002332 <serve_interrupt.9520.4321+0x72>
    osalSysLockFromISR();
 800231a:	f7ff ff51 	bl	80021c0 <osalSysLockFromISR.9440.4341>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800231e:	9b05      	ldr	r3, [sp, #20]
 8002320:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8002322:	b29b      	uxth	r3, r3
 8002324:	b2db      	uxtb	r3, r3
 8002326:	9801      	ldr	r0, [sp, #4]
 8002328:	4619      	mov	r1, r3
 800232a:	f001 f9a9 	bl	8003680 <sdIncomingDataI>
    osalSysUnlockFromISR();
 800232e:	f7ff ff4f 	bl	80021d0 <osalSysUnlockFromISR.9442.4339>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8002332:	9b04      	ldr	r3, [sp, #16]
 8002334:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002338:	2b00      	cmp	r3, #0
 800233a:	d023      	beq.n	8002384 <serve_interrupt.9520.4321+0xc4>
 800233c:	9b03      	ldr	r3, [sp, #12]
 800233e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002342:	2b00      	cmp	r3, #0
 8002344:	d01e      	beq.n	8002384 <serve_interrupt.9520.4321+0xc4>
    msg_t b;
    osalSysLockFromISR();
 8002346:	f7ff ff3b 	bl	80021c0 <osalSysLockFromISR.9440.4341>
    b = oqGetI(&sdp->oqueue);
 800234a:	9b01      	ldr	r3, [sp, #4]
 800234c:	3330      	adds	r3, #48	; 0x30
 800234e:	4618      	mov	r0, r3
 8002350:	f001 fd96 	bl	8003e80 <chOQGetI>
 8002354:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 8002356:	9b02      	ldr	r3, [sp, #8]
 8002358:	2b00      	cmp	r3, #0
 800235a:	da0d      	bge.n	8002378 <serve_interrupt.9520.4321+0xb8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800235c:	9b01      	ldr	r3, [sp, #4]
 800235e:	3304      	adds	r3, #4
 8002360:	4618      	mov	r0, r3
 8002362:	2108      	movs	r1, #8
 8002364:	f7ff ff3c 	bl	80021e0 <osalEventBroadcastFlagsI.9447.4335>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8002368:	9b04      	ldr	r3, [sp, #16]
 800236a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800236e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8002372:	9b05      	ldr	r3, [sp, #20]
 8002374:	601a      	str	r2, [r3, #0]
 8002376:	e003      	b.n	8002380 <serve_interrupt.9520.4321+0xc0>
    }
    else
      u->TDR = b;
 8002378:	9b02      	ldr	r3, [sp, #8]
 800237a:	b29a      	uxth	r2, r3
 800237c:	9b05      	ldr	r3, [sp, #20]
 800237e:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8002380:	f7ff ff26 	bl	80021d0 <osalSysUnlockFromISR.9442.4339>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8002384:	9b03      	ldr	r3, [sp, #12]
 8002386:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800238a:	2b00      	cmp	r3, #0
 800238c:	d016      	beq.n	80023bc <serve_interrupt.9520.4321+0xfc>
    osalSysLockFromISR();
 800238e:	f7ff ff17 	bl	80021c0 <osalSysLockFromISR.9440.4341>
    if (oqIsEmptyI(&sdp->oqueue))
 8002392:	9b01      	ldr	r3, [sp, #4]
 8002394:	3330      	adds	r3, #48	; 0x30
 8002396:	4618      	mov	r0, r3
 8002398:	f7ff fefa 	bl	8002190 <chOQIsEmptyI.9348.4343>
 800239c:	4603      	mov	r3, r0
 800239e:	2b00      	cmp	r3, #0
 80023a0:	d005      	beq.n	80023ae <serve_interrupt.9520.4321+0xee>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 80023a2:	9b01      	ldr	r3, [sp, #4]
 80023a4:	3304      	adds	r3, #4
 80023a6:	4618      	mov	r0, r3
 80023a8:	2110      	movs	r1, #16
 80023aa:	f7ff ff19 	bl	80021e0 <osalEventBroadcastFlagsI.9447.4335>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80023ae:	9b04      	ldr	r3, [sp, #16]
 80023b0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80023b4:	9b05      	ldr	r3, [sp, #20]
 80023b6:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80023b8:	f7ff ff0a 	bl	80021d0 <osalSysUnlockFromISR.9442.4339>
  }
}
 80023bc:	b007      	add	sp, #28
 80023be:	f85d fb04 	ldr.w	pc, [sp], #4
 80023c2:	bf00      	nop
 80023c4:	f3af 8000 	nop.w
 80023c8:	f3af 8000 	nop.w
 80023cc:	f3af 8000 	nop.w

080023d0 <notify1.9444.4316>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 80023d0:	b082      	sub	sp, #8
 80023d2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80023d4:	4b03      	ldr	r3, [pc, #12]	; (80023e4 <notify1.9444.4316+0x14>)
 80023d6:	4a03      	ldr	r2, [pc, #12]	; (80023e4 <notify1.9444.4316+0x14>)
 80023d8:	6812      	ldr	r2, [r2, #0]
 80023da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80023de:	601a      	str	r2, [r3, #0]
}
 80023e0:	b002      	add	sp, #8
 80023e2:	4770      	bx	lr
 80023e4:	40013800 	.word	0x40013800
 80023e8:	f3af 8000 	nop.w
 80023ec:	f3af 8000 	nop.w

080023f0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80023f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
 80023f2:	4803      	ldr	r0, [pc, #12]	; (8002400 <VectorD4+0x10>)
 80023f4:	f7ff ff64 	bl	80022c0 <serve_interrupt.9520.4321>

  OSAL_IRQ_EPILOGUE();
 80023f8:	f001 ffaa 	bl	8004350 <_port_irq_epilogue>
}
 80023fc:	bd08      	pop	{r3, pc}
 80023fe:	bf00      	nop
 8002400:	20000ba8 	.word	0x20000ba8
 8002404:	f3af 8000 	nop.w
 8002408:	f3af 8000 	nop.w
 800240c:	f3af 8000 	nop.w

08002410 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002410:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8002412:	4808      	ldr	r0, [pc, #32]	; (8002434 <sd_lld_init+0x24>)
 8002414:	2100      	movs	r1, #0
 8002416:	4a08      	ldr	r2, [pc, #32]	; (8002438 <sd_lld_init+0x28>)
 8002418:	f001 f8ea 	bl	80035f0 <sdObjectInit>
  SD1.usart = USART1;
 800241c:	4b05      	ldr	r3, [pc, #20]	; (8002434 <sd_lld_init+0x24>)
 800241e:	4a07      	ldr	r2, [pc, #28]	; (800243c <sd_lld_init+0x2c>)
 8002420:	675a      	str	r2, [r3, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8002422:	4b04      	ldr	r3, [pc, #16]	; (8002434 <sd_lld_init+0x24>)
 8002424:	4a06      	ldr	r2, [pc, #24]	; (8002440 <sd_lld_init+0x30>)
 8002426:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8002428:	2025      	movs	r0, #37	; 0x25
 800242a:	210c      	movs	r1, #12
 800242c:	f001 faa0 	bl	8003970 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8002430:	bd08      	pop	{r3, pc}
 8002432:	bf00      	nop
 8002434:	20000ba8 	.word	0x20000ba8
 8002438:	080023d1 	.word	0x080023d1
 800243c:	40013800 	.word	0x40013800
 8002440:	02255100 	.word	0x02255100
 8002444:	f3af 8000 	nop.w
 8002448:	f3af 8000 	nop.w
 800244c:	f3af 8000 	nop.w

08002450 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002450:	b500      	push	{lr}
 8002452:	b083      	sub	sp, #12
 8002454:	9001      	str	r0, [sp, #4]
 8002456:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8002458:	9b00      	ldr	r3, [sp, #0]
 800245a:	2b00      	cmp	r3, #0
 800245c:	d101      	bne.n	8002462 <sd_lld_start+0x12>
    config = &default_config;
 800245e:	4b0b      	ldr	r3, [pc, #44]	; (800248c <sd_lld_start+0x3c>)
 8002460:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8002462:	9b01      	ldr	r3, [sp, #4]
 8002464:	7a1b      	ldrb	r3, [r3, #8]
 8002466:	2b01      	cmp	r3, #1
 8002468:	d109      	bne.n	800247e <sd_lld_start+0x2e>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 800246a:	9a01      	ldr	r2, [sp, #4]
 800246c:	4b08      	ldr	r3, [pc, #32]	; (8002490 <sd_lld_start+0x40>)
 800246e:	429a      	cmp	r2, r3
 8002470:	d105      	bne.n	800247e <sd_lld_start+0x2e>
      rccEnableUSART1(FALSE);
 8002472:	4b08      	ldr	r3, [pc, #32]	; (8002494 <sd_lld_start+0x44>)
 8002474:	4a07      	ldr	r2, [pc, #28]	; (8002494 <sd_lld_start+0x44>)
 8002476:	6992      	ldr	r2, [r2, #24]
 8002478:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800247c:	619a      	str	r2, [r3, #24]
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 800247e:	9801      	ldr	r0, [sp, #4]
 8002480:	9900      	ldr	r1, [sp, #0]
 8002482:	f7ff febd 	bl	8002200 <usart_init.9462.4331>
}
 8002486:	b003      	add	sp, #12
 8002488:	f85d fb04 	ldr.w	pc, [sp], #4
 800248c:	080069d0 	.word	0x080069d0
 8002490:	20000ba8 	.word	0x20000ba8
 8002494:	40021000 	.word	0x40021000
 8002498:	f3af 8000 	nop.w
 800249c:	f3af 8000 	nop.w

080024a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80024a0:	b508      	push	{r3, lr}

  stm32_clock_init();
 80024a2:	f000 f80d 	bl	80024c0 <stm32_clock_init>
}
 80024a6:	bd08      	pop	{r3, pc}
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80024b0:	4770      	bx	lr
 80024b2:	bf00      	nop
 80024b4:	f3af 8000 	nop.w
 80024b8:	f3af 8000 	nop.w
 80024bc:	f3af 8000 	nop.w

080024c0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80024c0:	4b33      	ldr	r3, [pc, #204]	; (8002590 <stm32_clock_init+0xd0>)
 80024c2:	4a33      	ldr	r2, [pc, #204]	; (8002590 <stm32_clock_init+0xd0>)
 80024c4:	6812      	ldr	r2, [r2, #0]
 80024c6:	f042 0201 	orr.w	r2, r2, #1
 80024ca:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80024cc:	4b30      	ldr	r3, [pc, #192]	; (8002590 <stm32_clock_init+0xd0>)
 80024ce:	681b      	ldr	r3, [r3, #0]
 80024d0:	f003 0302 	and.w	r3, r3, #2
 80024d4:	2b00      	cmp	r3, #0
 80024d6:	d0f9      	beq.n	80024cc <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80024d8:	4b2d      	ldr	r3, [pc, #180]	; (8002590 <stm32_clock_init+0xd0>)
 80024da:	4a2d      	ldr	r2, [pc, #180]	; (8002590 <stm32_clock_init+0xd0>)
 80024dc:	6852      	ldr	r2, [r2, #4]
 80024de:	f022 0203 	bic.w	r2, r2, #3
 80024e2:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80024e4:	4b2a      	ldr	r3, [pc, #168]	; (8002590 <stm32_clock_init+0xd0>)
 80024e6:	4a2a      	ldr	r2, [pc, #168]	; (8002590 <stm32_clock_init+0xd0>)
 80024e8:	6852      	ldr	r2, [r2, #4]
 80024ea:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80024ec:	4b28      	ldr	r3, [pc, #160]	; (8002590 <stm32_clock_init+0xd0>)
 80024ee:	685b      	ldr	r3, [r3, #4]
 80024f0:	f003 030c 	and.w	r3, r3, #12
 80024f4:	2b00      	cmp	r3, #0
 80024f6:	d1f9      	bne.n	80024ec <stm32_clock_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80024f8:	4b25      	ldr	r3, [pc, #148]	; (8002590 <stm32_clock_init+0xd0>)
 80024fa:	4a25      	ldr	r2, [pc, #148]	; (8002590 <stm32_clock_init+0xd0>)
 80024fc:	6812      	ldr	r2, [r2, #0]
 80024fe:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 8002502:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002504:	4b22      	ldr	r3, [pc, #136]	; (8002590 <stm32_clock_init+0xd0>)
 8002506:	2200      	movs	r2, #0
 8002508:	605a      	str	r2, [r3, #4]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 800250a:	4b21      	ldr	r3, [pc, #132]	; (8002590 <stm32_clock_init+0xd0>)
 800250c:	4a20      	ldr	r2, [pc, #128]	; (8002590 <stm32_clock_init+0xd0>)
 800250e:	6812      	ldr	r2, [r2, #0]
 8002510:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8002514:	601a      	str	r2, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8002516:	4b1e      	ldr	r3, [pc, #120]	; (8002590 <stm32_clock_init+0xd0>)
 8002518:	681b      	ldr	r3, [r3, #0]
 800251a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800251e:	2b00      	cmp	r3, #0
 8002520:	d0f9      	beq.n	8002516 <stm32_clock_init+0x56>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8002522:	4b1b      	ldr	r3, [pc, #108]	; (8002590 <stm32_clock_init+0xd0>)
 8002524:	4a1a      	ldr	r2, [pc, #104]	; (8002590 <stm32_clock_init+0xd0>)
 8002526:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8002528:	f042 0201 	orr.w	r2, r2, #1
 800252c:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800252e:	4b18      	ldr	r3, [pc, #96]	; (8002590 <stm32_clock_init+0xd0>)
 8002530:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002532:	f003 0302 	and.w	r3, r3, #2
 8002536:	2b00      	cmp	r3, #0
 8002538:	d0f9      	beq.n	800252e <stm32_clock_init+0x6e>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 800253a:	4b15      	ldr	r3, [pc, #84]	; (8002590 <stm32_clock_init+0xd0>)
 800253c:	4a15      	ldr	r2, [pc, #84]	; (8002594 <stm32_clock_init+0xd4>)
 800253e:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8002540:	4b13      	ldr	r3, [pc, #76]	; (8002590 <stm32_clock_init+0xd0>)
 8002542:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8002546:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8002548:	4b11      	ldr	r3, [pc, #68]	; (8002590 <stm32_clock_init+0xd0>)
 800254a:	2230      	movs	r2, #48	; 0x30
 800254c:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 800254e:	4b10      	ldr	r3, [pc, #64]	; (8002590 <stm32_clock_init+0xd0>)
 8002550:	4a0f      	ldr	r2, [pc, #60]	; (8002590 <stm32_clock_init+0xd0>)
 8002552:	6812      	ldr	r2, [r2, #0]
 8002554:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002558:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800255a:	4b0d      	ldr	r3, [pc, #52]	; (8002590 <stm32_clock_init+0xd0>)
 800255c:	681b      	ldr	r3, [r3, #0]
 800255e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002562:	2b00      	cmp	r3, #0
 8002564:	d0f9      	beq.n	800255a <stm32_clock_init+0x9a>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8002566:	4b0c      	ldr	r3, [pc, #48]	; (8002598 <stm32_clock_init+0xd8>)
 8002568:	2212      	movs	r2, #18
 800256a:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800256c:	4b08      	ldr	r3, [pc, #32]	; (8002590 <stm32_clock_init+0xd0>)
 800256e:	4a08      	ldr	r2, [pc, #32]	; (8002590 <stm32_clock_init+0xd0>)
 8002570:	6852      	ldr	r2, [r2, #4]
 8002572:	f042 0202 	orr.w	r2, r2, #2
 8002576:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002578:	4b05      	ldr	r3, [pc, #20]	; (8002590 <stm32_clock_init+0xd0>)
 800257a:	685b      	ldr	r3, [r3, #4]
 800257c:	f003 030c 	and.w	r3, r3, #12
 8002580:	2b08      	cmp	r3, #8
 8002582:	d1f9      	bne.n	8002578 <stm32_clock_init+0xb8>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8002584:	4b02      	ldr	r3, [pc, #8]	; (8002590 <stm32_clock_init+0xd0>)
 8002586:	4a02      	ldr	r2, [pc, #8]	; (8002590 <stm32_clock_init+0xd0>)
 8002588:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800258a:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* !STM32_NO_INIT */
}
 800258c:	4770      	bx	lr
 800258e:	bf00      	nop
 8002590:	40021000 	.word	0x40021000
 8002594:	001d2400 	.word	0x001d2400
 8002598:	40022000 	.word	0x40022000
 800259c:	f3af 8000 	nop.w

080025a0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80025a0:	b500      	push	{lr}
 80025a2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80025a4:	2300      	movs	r3, #0
 80025a6:	9301      	str	r3, [sp, #4]
 80025a8:	4b14      	ldr	r3, [pc, #80]	; (80025fc <Vector6C+0x5c>)
 80025aa:	681a      	ldr	r2, [r3, #0]
 80025ac:	2300      	movs	r3, #0
 80025ae:	fa22 f303 	lsr.w	r3, r2, r3
 80025b2:	f003 030f 	and.w	r3, r3, #15
 80025b6:	9300      	str	r3, [sp, #0]
 80025b8:	9b00      	ldr	r3, [sp, #0]
 80025ba:	f003 030f 	and.w	r3, r3, #15
 80025be:	2b00      	cmp	r3, #0
 80025c0:	d017      	beq.n	80025f2 <Vector6C+0x52>
 80025c2:	4b0e      	ldr	r3, [pc, #56]	; (80025fc <Vector6C+0x5c>)
 80025c4:	2200      	movs	r2, #0
 80025c6:	9900      	ldr	r1, [sp, #0]
 80025c8:	fa01 f202 	lsl.w	r2, r1, r2
 80025cc:	605a      	str	r2, [r3, #4]
 80025ce:	4b0c      	ldr	r3, [pc, #48]	; (8002600 <Vector6C+0x60>)
 80025d0:	9a01      	ldr	r2, [sp, #4]
 80025d2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	d00b      	beq.n	80025f2 <Vector6C+0x52>
 80025da:	4b09      	ldr	r3, [pc, #36]	; (8002600 <Vector6C+0x60>)
 80025dc:	9a01      	ldr	r2, [sp, #4]
 80025de:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80025e2:	4907      	ldr	r1, [pc, #28]	; (8002600 <Vector6C+0x60>)
 80025e4:	9b01      	ldr	r3, [sp, #4]
 80025e6:	00db      	lsls	r3, r3, #3
 80025e8:	440b      	add	r3, r1
 80025ea:	685b      	ldr	r3, [r3, #4]
 80025ec:	4618      	mov	r0, r3
 80025ee:	9900      	ldr	r1, [sp, #0]
 80025f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80025f2:	f001 fead 	bl	8004350 <_port_irq_epilogue>
}
 80025f6:	b003      	add	sp, #12
 80025f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80025fc:	40020000 	.word	0x40020000
 8002600:	20000ad0 	.word	0x20000ad0
 8002604:	f3af 8000 	nop.w
 8002608:	f3af 8000 	nop.w
 800260c:	f3af 8000 	nop.w

08002610 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8002610:	b500      	push	{lr}
 8002612:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8002614:	2301      	movs	r3, #1
 8002616:	9301      	str	r3, [sp, #4]
 8002618:	4b14      	ldr	r3, [pc, #80]	; (800266c <Vector70+0x5c>)
 800261a:	681a      	ldr	r2, [r3, #0]
 800261c:	2304      	movs	r3, #4
 800261e:	fa22 f303 	lsr.w	r3, r2, r3
 8002622:	f003 030f 	and.w	r3, r3, #15
 8002626:	9300      	str	r3, [sp, #0]
 8002628:	9b00      	ldr	r3, [sp, #0]
 800262a:	f003 030f 	and.w	r3, r3, #15
 800262e:	2b00      	cmp	r3, #0
 8002630:	d017      	beq.n	8002662 <Vector70+0x52>
 8002632:	4b0e      	ldr	r3, [pc, #56]	; (800266c <Vector70+0x5c>)
 8002634:	2204      	movs	r2, #4
 8002636:	9900      	ldr	r1, [sp, #0]
 8002638:	fa01 f202 	lsl.w	r2, r1, r2
 800263c:	605a      	str	r2, [r3, #4]
 800263e:	4b0c      	ldr	r3, [pc, #48]	; (8002670 <Vector70+0x60>)
 8002640:	9a01      	ldr	r2, [sp, #4]
 8002642:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002646:	2b00      	cmp	r3, #0
 8002648:	d00b      	beq.n	8002662 <Vector70+0x52>
 800264a:	4b09      	ldr	r3, [pc, #36]	; (8002670 <Vector70+0x60>)
 800264c:	9a01      	ldr	r2, [sp, #4]
 800264e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002652:	4907      	ldr	r1, [pc, #28]	; (8002670 <Vector70+0x60>)
 8002654:	9b01      	ldr	r3, [sp, #4]
 8002656:	00db      	lsls	r3, r3, #3
 8002658:	440b      	add	r3, r1
 800265a:	685b      	ldr	r3, [r3, #4]
 800265c:	4618      	mov	r0, r3
 800265e:	9900      	ldr	r1, [sp, #0]
 8002660:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002662:	f001 fe75 	bl	8004350 <_port_irq_epilogue>
}
 8002666:	b003      	add	sp, #12
 8002668:	f85d fb04 	ldr.w	pc, [sp], #4
 800266c:	40020000 	.word	0x40020000
 8002670:	20000ad0 	.word	0x20000ad0
 8002674:	f3af 8000 	nop.w
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002680:	b500      	push	{lr}
 8002682:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8002684:	2302      	movs	r3, #2
 8002686:	9301      	str	r3, [sp, #4]
 8002688:	4b14      	ldr	r3, [pc, #80]	; (80026dc <Vector74+0x5c>)
 800268a:	681a      	ldr	r2, [r3, #0]
 800268c:	2308      	movs	r3, #8
 800268e:	fa22 f303 	lsr.w	r3, r2, r3
 8002692:	f003 030f 	and.w	r3, r3, #15
 8002696:	9300      	str	r3, [sp, #0]
 8002698:	9b00      	ldr	r3, [sp, #0]
 800269a:	f003 030f 	and.w	r3, r3, #15
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d017      	beq.n	80026d2 <Vector74+0x52>
 80026a2:	4b0e      	ldr	r3, [pc, #56]	; (80026dc <Vector74+0x5c>)
 80026a4:	2208      	movs	r2, #8
 80026a6:	9900      	ldr	r1, [sp, #0]
 80026a8:	fa01 f202 	lsl.w	r2, r1, r2
 80026ac:	605a      	str	r2, [r3, #4]
 80026ae:	4b0c      	ldr	r3, [pc, #48]	; (80026e0 <Vector74+0x60>)
 80026b0:	9a01      	ldr	r2, [sp, #4]
 80026b2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d00b      	beq.n	80026d2 <Vector74+0x52>
 80026ba:	4b09      	ldr	r3, [pc, #36]	; (80026e0 <Vector74+0x60>)
 80026bc:	9a01      	ldr	r2, [sp, #4]
 80026be:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80026c2:	4907      	ldr	r1, [pc, #28]	; (80026e0 <Vector74+0x60>)
 80026c4:	9b01      	ldr	r3, [sp, #4]
 80026c6:	00db      	lsls	r3, r3, #3
 80026c8:	440b      	add	r3, r1
 80026ca:	685b      	ldr	r3, [r3, #4]
 80026cc:	4618      	mov	r0, r3
 80026ce:	9900      	ldr	r1, [sp, #0]
 80026d0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80026d2:	f001 fe3d 	bl	8004350 <_port_irq_epilogue>
}
 80026d6:	b003      	add	sp, #12
 80026d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80026dc:	40020000 	.word	0x40020000
 80026e0:	20000ad0 	.word	0x20000ad0
 80026e4:	f3af 8000 	nop.w
 80026e8:	f3af 8000 	nop.w
 80026ec:	f3af 8000 	nop.w

080026f0 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80026f0:	b500      	push	{lr}
 80026f2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80026f4:	2303      	movs	r3, #3
 80026f6:	9301      	str	r3, [sp, #4]
 80026f8:	4b14      	ldr	r3, [pc, #80]	; (800274c <Vector78+0x5c>)
 80026fa:	681a      	ldr	r2, [r3, #0]
 80026fc:	230c      	movs	r3, #12
 80026fe:	fa22 f303 	lsr.w	r3, r2, r3
 8002702:	f003 030f 	and.w	r3, r3, #15
 8002706:	9300      	str	r3, [sp, #0]
 8002708:	9b00      	ldr	r3, [sp, #0]
 800270a:	f003 030f 	and.w	r3, r3, #15
 800270e:	2b00      	cmp	r3, #0
 8002710:	d017      	beq.n	8002742 <Vector78+0x52>
 8002712:	4b0e      	ldr	r3, [pc, #56]	; (800274c <Vector78+0x5c>)
 8002714:	220c      	movs	r2, #12
 8002716:	9900      	ldr	r1, [sp, #0]
 8002718:	fa01 f202 	lsl.w	r2, r1, r2
 800271c:	605a      	str	r2, [r3, #4]
 800271e:	4b0c      	ldr	r3, [pc, #48]	; (8002750 <Vector78+0x60>)
 8002720:	9a01      	ldr	r2, [sp, #4]
 8002722:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002726:	2b00      	cmp	r3, #0
 8002728:	d00b      	beq.n	8002742 <Vector78+0x52>
 800272a:	4b09      	ldr	r3, [pc, #36]	; (8002750 <Vector78+0x60>)
 800272c:	9a01      	ldr	r2, [sp, #4]
 800272e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002732:	4907      	ldr	r1, [pc, #28]	; (8002750 <Vector78+0x60>)
 8002734:	9b01      	ldr	r3, [sp, #4]
 8002736:	00db      	lsls	r3, r3, #3
 8002738:	440b      	add	r3, r1
 800273a:	685b      	ldr	r3, [r3, #4]
 800273c:	4618      	mov	r0, r3
 800273e:	9900      	ldr	r1, [sp, #0]
 8002740:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002742:	f001 fe05 	bl	8004350 <_port_irq_epilogue>
}
 8002746:	b003      	add	sp, #12
 8002748:	f85d fb04 	ldr.w	pc, [sp], #4
 800274c:	40020000 	.word	0x40020000
 8002750:	20000ad0 	.word	0x20000ad0
 8002754:	f3af 8000 	nop.w
 8002758:	f3af 8000 	nop.w
 800275c:	f3af 8000 	nop.w

08002760 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002760:	b500      	push	{lr}
 8002762:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8002764:	2304      	movs	r3, #4
 8002766:	9301      	str	r3, [sp, #4]
 8002768:	4b14      	ldr	r3, [pc, #80]	; (80027bc <Vector7C+0x5c>)
 800276a:	681a      	ldr	r2, [r3, #0]
 800276c:	2310      	movs	r3, #16
 800276e:	fa22 f303 	lsr.w	r3, r2, r3
 8002772:	f003 030f 	and.w	r3, r3, #15
 8002776:	9300      	str	r3, [sp, #0]
 8002778:	9b00      	ldr	r3, [sp, #0]
 800277a:	f003 030f 	and.w	r3, r3, #15
 800277e:	2b00      	cmp	r3, #0
 8002780:	d017      	beq.n	80027b2 <Vector7C+0x52>
 8002782:	4b0e      	ldr	r3, [pc, #56]	; (80027bc <Vector7C+0x5c>)
 8002784:	2210      	movs	r2, #16
 8002786:	9900      	ldr	r1, [sp, #0]
 8002788:	fa01 f202 	lsl.w	r2, r1, r2
 800278c:	605a      	str	r2, [r3, #4]
 800278e:	4b0c      	ldr	r3, [pc, #48]	; (80027c0 <Vector7C+0x60>)
 8002790:	9a01      	ldr	r2, [sp, #4]
 8002792:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002796:	2b00      	cmp	r3, #0
 8002798:	d00b      	beq.n	80027b2 <Vector7C+0x52>
 800279a:	4b09      	ldr	r3, [pc, #36]	; (80027c0 <Vector7C+0x60>)
 800279c:	9a01      	ldr	r2, [sp, #4]
 800279e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80027a2:	4907      	ldr	r1, [pc, #28]	; (80027c0 <Vector7C+0x60>)
 80027a4:	9b01      	ldr	r3, [sp, #4]
 80027a6:	00db      	lsls	r3, r3, #3
 80027a8:	440b      	add	r3, r1
 80027aa:	685b      	ldr	r3, [r3, #4]
 80027ac:	4618      	mov	r0, r3
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80027b2:	f001 fdcd 	bl	8004350 <_port_irq_epilogue>
}
 80027b6:	b003      	add	sp, #12
 80027b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80027bc:	40020000 	.word	0x40020000
 80027c0:	20000ad0 	.word	0x20000ad0
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80027d0:	b500      	push	{lr}
 80027d2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80027d4:	2305      	movs	r3, #5
 80027d6:	9301      	str	r3, [sp, #4]
 80027d8:	4b14      	ldr	r3, [pc, #80]	; (800282c <Vector80+0x5c>)
 80027da:	681a      	ldr	r2, [r3, #0]
 80027dc:	2314      	movs	r3, #20
 80027de:	fa22 f303 	lsr.w	r3, r2, r3
 80027e2:	f003 030f 	and.w	r3, r3, #15
 80027e6:	9300      	str	r3, [sp, #0]
 80027e8:	9b00      	ldr	r3, [sp, #0]
 80027ea:	f003 030f 	and.w	r3, r3, #15
 80027ee:	2b00      	cmp	r3, #0
 80027f0:	d017      	beq.n	8002822 <Vector80+0x52>
 80027f2:	4b0e      	ldr	r3, [pc, #56]	; (800282c <Vector80+0x5c>)
 80027f4:	2214      	movs	r2, #20
 80027f6:	9900      	ldr	r1, [sp, #0]
 80027f8:	fa01 f202 	lsl.w	r2, r1, r2
 80027fc:	605a      	str	r2, [r3, #4]
 80027fe:	4b0c      	ldr	r3, [pc, #48]	; (8002830 <Vector80+0x60>)
 8002800:	9a01      	ldr	r2, [sp, #4]
 8002802:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002806:	2b00      	cmp	r3, #0
 8002808:	d00b      	beq.n	8002822 <Vector80+0x52>
 800280a:	4b09      	ldr	r3, [pc, #36]	; (8002830 <Vector80+0x60>)
 800280c:	9a01      	ldr	r2, [sp, #4]
 800280e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002812:	4907      	ldr	r1, [pc, #28]	; (8002830 <Vector80+0x60>)
 8002814:	9b01      	ldr	r3, [sp, #4]
 8002816:	00db      	lsls	r3, r3, #3
 8002818:	440b      	add	r3, r1
 800281a:	685b      	ldr	r3, [r3, #4]
 800281c:	4618      	mov	r0, r3
 800281e:	9900      	ldr	r1, [sp, #0]
 8002820:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002822:	f001 fd95 	bl	8004350 <_port_irq_epilogue>
}
 8002826:	b003      	add	sp, #12
 8002828:	f85d fb04 	ldr.w	pc, [sp], #4
 800282c:	40020000 	.word	0x40020000
 8002830:	20000ad0 	.word	0x20000ad0
 8002834:	f3af 8000 	nop.w
 8002838:	f3af 8000 	nop.w
 800283c:	f3af 8000 	nop.w

08002840 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002840:	b500      	push	{lr}
 8002842:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8002844:	2306      	movs	r3, #6
 8002846:	9301      	str	r3, [sp, #4]
 8002848:	4b14      	ldr	r3, [pc, #80]	; (800289c <Vector84+0x5c>)
 800284a:	681a      	ldr	r2, [r3, #0]
 800284c:	2318      	movs	r3, #24
 800284e:	fa22 f303 	lsr.w	r3, r2, r3
 8002852:	f003 030f 	and.w	r3, r3, #15
 8002856:	9300      	str	r3, [sp, #0]
 8002858:	9b00      	ldr	r3, [sp, #0]
 800285a:	f003 030f 	and.w	r3, r3, #15
 800285e:	2b00      	cmp	r3, #0
 8002860:	d017      	beq.n	8002892 <Vector84+0x52>
 8002862:	4b0e      	ldr	r3, [pc, #56]	; (800289c <Vector84+0x5c>)
 8002864:	2218      	movs	r2, #24
 8002866:	9900      	ldr	r1, [sp, #0]
 8002868:	fa01 f202 	lsl.w	r2, r1, r2
 800286c:	605a      	str	r2, [r3, #4]
 800286e:	4b0c      	ldr	r3, [pc, #48]	; (80028a0 <Vector84+0x60>)
 8002870:	9a01      	ldr	r2, [sp, #4]
 8002872:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002876:	2b00      	cmp	r3, #0
 8002878:	d00b      	beq.n	8002892 <Vector84+0x52>
 800287a:	4b09      	ldr	r3, [pc, #36]	; (80028a0 <Vector84+0x60>)
 800287c:	9a01      	ldr	r2, [sp, #4]
 800287e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002882:	4907      	ldr	r1, [pc, #28]	; (80028a0 <Vector84+0x60>)
 8002884:	9b01      	ldr	r3, [sp, #4]
 8002886:	00db      	lsls	r3, r3, #3
 8002888:	440b      	add	r3, r1
 800288a:	685b      	ldr	r3, [r3, #4]
 800288c:	4618      	mov	r0, r3
 800288e:	9900      	ldr	r1, [sp, #0]
 8002890:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002892:	f001 fd5d 	bl	8004350 <_port_irq_epilogue>
}
 8002896:	b003      	add	sp, #12
 8002898:	f85d fb04 	ldr.w	pc, [sp], #4
 800289c:	40020000 	.word	0x40020000
 80028a0:	20000ad0 	.word	0x20000ad0
 80028a4:	f3af 8000 	nop.w
 80028a8:	f3af 8000 	nop.w
 80028ac:	f3af 8000 	nop.w

080028b0 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80028b0:	b500      	push	{lr}
 80028b2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 80028b4:	2307      	movs	r3, #7
 80028b6:	9301      	str	r3, [sp, #4]
 80028b8:	4b14      	ldr	r3, [pc, #80]	; (800290c <Vector120+0x5c>)
 80028ba:	681a      	ldr	r2, [r3, #0]
 80028bc:	2300      	movs	r3, #0
 80028be:	fa22 f303 	lsr.w	r3, r2, r3
 80028c2:	f003 030f 	and.w	r3, r3, #15
 80028c6:	9300      	str	r3, [sp, #0]
 80028c8:	9b00      	ldr	r3, [sp, #0]
 80028ca:	f003 030f 	and.w	r3, r3, #15
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d017      	beq.n	8002902 <Vector120+0x52>
 80028d2:	4b0e      	ldr	r3, [pc, #56]	; (800290c <Vector120+0x5c>)
 80028d4:	2200      	movs	r2, #0
 80028d6:	9900      	ldr	r1, [sp, #0]
 80028d8:	fa01 f202 	lsl.w	r2, r1, r2
 80028dc:	605a      	str	r2, [r3, #4]
 80028de:	4b0c      	ldr	r3, [pc, #48]	; (8002910 <Vector120+0x60>)
 80028e0:	9a01      	ldr	r2, [sp, #4]
 80028e2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80028e6:	2b00      	cmp	r3, #0
 80028e8:	d00b      	beq.n	8002902 <Vector120+0x52>
 80028ea:	4b09      	ldr	r3, [pc, #36]	; (8002910 <Vector120+0x60>)
 80028ec:	9a01      	ldr	r2, [sp, #4]
 80028ee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80028f2:	4907      	ldr	r1, [pc, #28]	; (8002910 <Vector120+0x60>)
 80028f4:	9b01      	ldr	r3, [sp, #4]
 80028f6:	00db      	lsls	r3, r3, #3
 80028f8:	440b      	add	r3, r1
 80028fa:	685b      	ldr	r3, [r3, #4]
 80028fc:	4618      	mov	r0, r3
 80028fe:	9900      	ldr	r1, [sp, #0]
 8002900:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002902:	f001 fd25 	bl	8004350 <_port_irq_epilogue>
}
 8002906:	b003      	add	sp, #12
 8002908:	f85d fb04 	ldr.w	pc, [sp], #4
 800290c:	40020400 	.word	0x40020400
 8002910:	20000ad0 	.word	0x20000ad0
 8002914:	f3af 8000 	nop.w
 8002918:	f3af 8000 	nop.w
 800291c:	f3af 8000 	nop.w

08002920 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002920:	b500      	push	{lr}
 8002922:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8002924:	2308      	movs	r3, #8
 8002926:	9301      	str	r3, [sp, #4]
 8002928:	4b14      	ldr	r3, [pc, #80]	; (800297c <Vector124+0x5c>)
 800292a:	681a      	ldr	r2, [r3, #0]
 800292c:	2304      	movs	r3, #4
 800292e:	fa22 f303 	lsr.w	r3, r2, r3
 8002932:	f003 030f 	and.w	r3, r3, #15
 8002936:	9300      	str	r3, [sp, #0]
 8002938:	9b00      	ldr	r3, [sp, #0]
 800293a:	f003 030f 	and.w	r3, r3, #15
 800293e:	2b00      	cmp	r3, #0
 8002940:	d017      	beq.n	8002972 <Vector124+0x52>
 8002942:	4b0e      	ldr	r3, [pc, #56]	; (800297c <Vector124+0x5c>)
 8002944:	2204      	movs	r2, #4
 8002946:	9900      	ldr	r1, [sp, #0]
 8002948:	fa01 f202 	lsl.w	r2, r1, r2
 800294c:	605a      	str	r2, [r3, #4]
 800294e:	4b0c      	ldr	r3, [pc, #48]	; (8002980 <Vector124+0x60>)
 8002950:	9a01      	ldr	r2, [sp, #4]
 8002952:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002956:	2b00      	cmp	r3, #0
 8002958:	d00b      	beq.n	8002972 <Vector124+0x52>
 800295a:	4b09      	ldr	r3, [pc, #36]	; (8002980 <Vector124+0x60>)
 800295c:	9a01      	ldr	r2, [sp, #4]
 800295e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002962:	4907      	ldr	r1, [pc, #28]	; (8002980 <Vector124+0x60>)
 8002964:	9b01      	ldr	r3, [sp, #4]
 8002966:	00db      	lsls	r3, r3, #3
 8002968:	440b      	add	r3, r1
 800296a:	685b      	ldr	r3, [r3, #4]
 800296c:	4618      	mov	r0, r3
 800296e:	9900      	ldr	r1, [sp, #0]
 8002970:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002972:	f001 fced 	bl	8004350 <_port_irq_epilogue>
}
 8002976:	b003      	add	sp, #12
 8002978:	f85d fb04 	ldr.w	pc, [sp], #4
 800297c:	40020400 	.word	0x40020400
 8002980:	20000ad0 	.word	0x20000ad0
 8002984:	f3af 8000 	nop.w
 8002988:	f3af 8000 	nop.w
 800298c:	f3af 8000 	nop.w

08002990 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002990:	b500      	push	{lr}
 8002992:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8002994:	2309      	movs	r3, #9
 8002996:	9301      	str	r3, [sp, #4]
 8002998:	4b14      	ldr	r3, [pc, #80]	; (80029ec <Vector128+0x5c>)
 800299a:	681a      	ldr	r2, [r3, #0]
 800299c:	2308      	movs	r3, #8
 800299e:	fa22 f303 	lsr.w	r3, r2, r3
 80029a2:	f003 030f 	and.w	r3, r3, #15
 80029a6:	9300      	str	r3, [sp, #0]
 80029a8:	9b00      	ldr	r3, [sp, #0]
 80029aa:	f003 030f 	and.w	r3, r3, #15
 80029ae:	2b00      	cmp	r3, #0
 80029b0:	d017      	beq.n	80029e2 <Vector128+0x52>
 80029b2:	4b0e      	ldr	r3, [pc, #56]	; (80029ec <Vector128+0x5c>)
 80029b4:	2208      	movs	r2, #8
 80029b6:	9900      	ldr	r1, [sp, #0]
 80029b8:	fa01 f202 	lsl.w	r2, r1, r2
 80029bc:	605a      	str	r2, [r3, #4]
 80029be:	4b0c      	ldr	r3, [pc, #48]	; (80029f0 <Vector128+0x60>)
 80029c0:	9a01      	ldr	r2, [sp, #4]
 80029c2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d00b      	beq.n	80029e2 <Vector128+0x52>
 80029ca:	4b09      	ldr	r3, [pc, #36]	; (80029f0 <Vector128+0x60>)
 80029cc:	9a01      	ldr	r2, [sp, #4]
 80029ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80029d2:	4907      	ldr	r1, [pc, #28]	; (80029f0 <Vector128+0x60>)
 80029d4:	9b01      	ldr	r3, [sp, #4]
 80029d6:	00db      	lsls	r3, r3, #3
 80029d8:	440b      	add	r3, r1
 80029da:	685b      	ldr	r3, [r3, #4]
 80029dc:	4618      	mov	r0, r3
 80029de:	9900      	ldr	r1, [sp, #0]
 80029e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80029e2:	f001 fcb5 	bl	8004350 <_port_irq_epilogue>
}
 80029e6:	b003      	add	sp, #12
 80029e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029ec:	40020400 	.word	0x40020400
 80029f0:	20000ad0 	.word	0x20000ad0
 80029f4:	f3af 8000 	nop.w
 80029f8:	f3af 8000 	nop.w
 80029fc:	f3af 8000 	nop.w

08002a00 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002a00:	b500      	push	{lr}
 8002a02:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8002a04:	230a      	movs	r3, #10
 8002a06:	9301      	str	r3, [sp, #4]
 8002a08:	4b14      	ldr	r3, [pc, #80]	; (8002a5c <Vector12C+0x5c>)
 8002a0a:	681a      	ldr	r2, [r3, #0]
 8002a0c:	230c      	movs	r3, #12
 8002a0e:	fa22 f303 	lsr.w	r3, r2, r3
 8002a12:	f003 030f 	and.w	r3, r3, #15
 8002a16:	9300      	str	r3, [sp, #0]
 8002a18:	9b00      	ldr	r3, [sp, #0]
 8002a1a:	f003 030f 	and.w	r3, r3, #15
 8002a1e:	2b00      	cmp	r3, #0
 8002a20:	d017      	beq.n	8002a52 <Vector12C+0x52>
 8002a22:	4b0e      	ldr	r3, [pc, #56]	; (8002a5c <Vector12C+0x5c>)
 8002a24:	220c      	movs	r2, #12
 8002a26:	9900      	ldr	r1, [sp, #0]
 8002a28:	fa01 f202 	lsl.w	r2, r1, r2
 8002a2c:	605a      	str	r2, [r3, #4]
 8002a2e:	4b0c      	ldr	r3, [pc, #48]	; (8002a60 <Vector12C+0x60>)
 8002a30:	9a01      	ldr	r2, [sp, #4]
 8002a32:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002a36:	2b00      	cmp	r3, #0
 8002a38:	d00b      	beq.n	8002a52 <Vector12C+0x52>
 8002a3a:	4b09      	ldr	r3, [pc, #36]	; (8002a60 <Vector12C+0x60>)
 8002a3c:	9a01      	ldr	r2, [sp, #4]
 8002a3e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002a42:	4907      	ldr	r1, [pc, #28]	; (8002a60 <Vector12C+0x60>)
 8002a44:	9b01      	ldr	r3, [sp, #4]
 8002a46:	00db      	lsls	r3, r3, #3
 8002a48:	440b      	add	r3, r1
 8002a4a:	685b      	ldr	r3, [r3, #4]
 8002a4c:	4618      	mov	r0, r3
 8002a4e:	9900      	ldr	r1, [sp, #0]
 8002a50:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002a52:	f001 fc7d 	bl	8004350 <_port_irq_epilogue>
}
 8002a56:	b003      	add	sp, #12
 8002a58:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a5c:	40020400 	.word	0x40020400
 8002a60:	20000ad0 	.word	0x20000ad0
 8002a64:	f3af 8000 	nop.w
 8002a68:	f3af 8000 	nop.w
 8002a6c:	f3af 8000 	nop.w

08002a70 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002a70:	b500      	push	{lr}
 8002a72:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8002a74:	230b      	movs	r3, #11
 8002a76:	9301      	str	r3, [sp, #4]
 8002a78:	4b14      	ldr	r3, [pc, #80]	; (8002acc <Vector130+0x5c>)
 8002a7a:	681a      	ldr	r2, [r3, #0]
 8002a7c:	2310      	movs	r3, #16
 8002a7e:	fa22 f303 	lsr.w	r3, r2, r3
 8002a82:	f003 030f 	and.w	r3, r3, #15
 8002a86:	9300      	str	r3, [sp, #0]
 8002a88:	9b00      	ldr	r3, [sp, #0]
 8002a8a:	f003 030f 	and.w	r3, r3, #15
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	d017      	beq.n	8002ac2 <Vector130+0x52>
 8002a92:	4b0e      	ldr	r3, [pc, #56]	; (8002acc <Vector130+0x5c>)
 8002a94:	2210      	movs	r2, #16
 8002a96:	9900      	ldr	r1, [sp, #0]
 8002a98:	fa01 f202 	lsl.w	r2, r1, r2
 8002a9c:	605a      	str	r2, [r3, #4]
 8002a9e:	4b0c      	ldr	r3, [pc, #48]	; (8002ad0 <Vector130+0x60>)
 8002aa0:	9a01      	ldr	r2, [sp, #4]
 8002aa2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002aa6:	2b00      	cmp	r3, #0
 8002aa8:	d00b      	beq.n	8002ac2 <Vector130+0x52>
 8002aaa:	4b09      	ldr	r3, [pc, #36]	; (8002ad0 <Vector130+0x60>)
 8002aac:	9a01      	ldr	r2, [sp, #4]
 8002aae:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8002ab2:	4907      	ldr	r1, [pc, #28]	; (8002ad0 <Vector130+0x60>)
 8002ab4:	9b01      	ldr	r3, [sp, #4]
 8002ab6:	00db      	lsls	r3, r3, #3
 8002ab8:	440b      	add	r3, r1
 8002aba:	685b      	ldr	r3, [r3, #4]
 8002abc:	4618      	mov	r0, r3
 8002abe:	9900      	ldr	r1, [sp, #0]
 8002ac0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002ac2:	f001 fc45 	bl	8004350 <_port_irq_epilogue>
}
 8002ac6:	b003      	add	sp, #12
 8002ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002acc:	40020400 	.word	0x40020400
 8002ad0:	20000ad0 	.word	0x20000ad0
 8002ad4:	f3af 8000 	nop.w
 8002ad8:	f3af 8000 	nop.w
 8002adc:	f3af 8000 	nop.w

08002ae0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002ae0:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8002ae2:	4b12      	ldr	r3, [pc, #72]	; (8002b2c <dmaInit+0x4c>)
 8002ae4:	2200      	movs	r2, #0
 8002ae6:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002ae8:	2300      	movs	r3, #0
 8002aea:	9301      	str	r3, [sp, #4]
 8002aec:	e011      	b.n	8002b12 <dmaInit+0x32>
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002aee:	4910      	ldr	r1, [pc, #64]	; (8002b30 <dmaInit+0x50>)
 8002af0:	9a01      	ldr	r2, [sp, #4]
 8002af2:	4613      	mov	r3, r2
 8002af4:	009b      	lsls	r3, r3, #2
 8002af6:	4413      	add	r3, r2
 8002af8:	009b      	lsls	r3, r3, #2
 8002afa:	440b      	add	r3, r1
 8002afc:	685b      	ldr	r3, [r3, #4]
 8002afe:	2200      	movs	r2, #0
 8002b00:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8002b02:	4b0c      	ldr	r3, [pc, #48]	; (8002b34 <dmaInit+0x54>)
 8002b04:	9a01      	ldr	r2, [sp, #4]
 8002b06:	2100      	movs	r1, #0
 8002b08:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002b0c:	9b01      	ldr	r3, [sp, #4]
 8002b0e:	3301      	adds	r3, #1
 8002b10:	9301      	str	r3, [sp, #4]
 8002b12:	9b01      	ldr	r3, [sp, #4]
 8002b14:	2b0b      	cmp	r3, #11
 8002b16:	ddea      	ble.n	8002aee <dmaInit+0xe>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8002b18:	4b07      	ldr	r3, [pc, #28]	; (8002b38 <dmaInit+0x58>)
 8002b1a:	f04f 32ff 	mov.w	r2, #4294967295
 8002b1e:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8002b20:	4b06      	ldr	r3, [pc, #24]	; (8002b3c <dmaInit+0x5c>)
 8002b22:	f04f 32ff 	mov.w	r2, #4294967295
 8002b26:	605a      	str	r2, [r3, #4]
#endif
}
 8002b28:	b002      	add	sp, #8
 8002b2a:	4770      	bx	lr
 8002b2c:	20000b30 	.word	0x20000b30
 8002b30:	080068d0 	.word	0x080068d0
 8002b34:	20000ad0 	.word	0x20000ad0
 8002b38:	40020000 	.word	0x40020000
 8002b3c:	40020400 	.word	0x40020400

08002b40 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8002b40:	b500      	push	{lr}
 8002b42:	b085      	sub	sp, #20
 8002b44:	9003      	str	r0, [sp, #12]
 8002b46:	9102      	str	r1, [sp, #8]
 8002b48:	9201      	str	r2, [sp, #4]
 8002b4a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8002b4c:	9b03      	ldr	r3, [sp, #12]
 8002b4e:	7c5b      	ldrb	r3, [r3, #17]
 8002b50:	2201      	movs	r2, #1
 8002b52:	409a      	lsls	r2, r3
 8002b54:	4b2f      	ldr	r3, [pc, #188]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002b56:	681b      	ldr	r3, [r3, #0]
 8002b58:	4013      	ands	r3, r2
 8002b5a:	2b00      	cmp	r3, #0
 8002b5c:	d001      	beq.n	8002b62 <dmaStreamAllocate+0x22>
    return true;
 8002b5e:	2301      	movs	r3, #1
 8002b60:	e053      	b.n	8002c0a <dmaStreamAllocate+0xca>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002b62:	9b03      	ldr	r3, [sp, #12]
 8002b64:	7c5b      	ldrb	r3, [r3, #17]
 8002b66:	461a      	mov	r2, r3
 8002b68:	4b2b      	ldr	r3, [pc, #172]	; (8002c18 <dmaStreamAllocate+0xd8>)
 8002b6a:	9901      	ldr	r1, [sp, #4]
 8002b6c:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002b70:	9b03      	ldr	r3, [sp, #12]
 8002b72:	7c5b      	ldrb	r3, [r3, #17]
 8002b74:	4a28      	ldr	r2, [pc, #160]	; (8002c18 <dmaStreamAllocate+0xd8>)
 8002b76:	00db      	lsls	r3, r3, #3
 8002b78:	4413      	add	r3, r2
 8002b7a:	9a00      	ldr	r2, [sp, #0]
 8002b7c:	605a      	str	r2, [r3, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8002b7e:	4b25      	ldr	r3, [pc, #148]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002b80:	681b      	ldr	r3, [r3, #0]
 8002b82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002b86:	2b00      	cmp	r3, #0
 8002b88:	d105      	bne.n	8002b96 <dmaStreamAllocate+0x56>
    rccEnableDMA1(false);
 8002b8a:	4b24      	ldr	r3, [pc, #144]	; (8002c1c <dmaStreamAllocate+0xdc>)
 8002b8c:	4a23      	ldr	r2, [pc, #140]	; (8002c1c <dmaStreamAllocate+0xdc>)
 8002b8e:	6952      	ldr	r2, [r2, #20]
 8002b90:	f042 0201 	orr.w	r2, r2, #1
 8002b94:	615a      	str	r2, [r3, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8002b96:	4b1f      	ldr	r3, [pc, #124]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002b98:	681b      	ldr	r3, [r3, #0]
 8002b9a:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
 8002b9e:	2b00      	cmp	r3, #0
 8002ba0:	d105      	bne.n	8002bae <dmaStreamAllocate+0x6e>
    rccEnableDMA2(false);
 8002ba2:	4b1e      	ldr	r3, [pc, #120]	; (8002c1c <dmaStreamAllocate+0xdc>)
 8002ba4:	4a1d      	ldr	r2, [pc, #116]	; (8002c1c <dmaStreamAllocate+0xdc>)
 8002ba6:	6952      	ldr	r2, [r2, #20]
 8002ba8:	f042 0202 	orr.w	r2, r2, #2
 8002bac:	615a      	str	r2, [r3, #20]
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8002bae:	9b03      	ldr	r3, [sp, #12]
 8002bb0:	685b      	ldr	r3, [r3, #4]
 8002bb2:	9a03      	ldr	r2, [sp, #12]
 8002bb4:	6852      	ldr	r2, [r2, #4]
 8002bb6:	6812      	ldr	r2, [r2, #0]
 8002bb8:	f022 020f 	bic.w	r2, r2, #15
 8002bbc:	601a      	str	r2, [r3, #0]
 8002bbe:	9b03      	ldr	r3, [sp, #12]
 8002bc0:	681b      	ldr	r3, [r3, #0]
 8002bc2:	9a03      	ldr	r2, [sp, #12]
 8002bc4:	7c12      	ldrb	r2, [r2, #16]
 8002bc6:	210f      	movs	r1, #15
 8002bc8:	fa01 f202 	lsl.w	r2, r1, r2
 8002bcc:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002bce:	9b03      	ldr	r3, [sp, #12]
 8002bd0:	685b      	ldr	r3, [r3, #4]
 8002bd2:	2200      	movs	r2, #0
 8002bd4:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8002bd6:	9b03      	ldr	r3, [sp, #12]
 8002bd8:	689a      	ldr	r2, [r3, #8]
 8002bda:	4b0e      	ldr	r3, [pc, #56]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002bdc:	681b      	ldr	r3, [r3, #0]
 8002bde:	4013      	ands	r3, r2
 8002be0:	2b00      	cmp	r3, #0
 8002be2:	d108      	bne.n	8002bf6 <dmaStreamAllocate+0xb6>
 8002be4:	9b01      	ldr	r3, [sp, #4]
 8002be6:	2b00      	cmp	r3, #0
 8002be8:	d005      	beq.n	8002bf6 <dmaStreamAllocate+0xb6>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8002bea:	9b03      	ldr	r3, [sp, #12]
 8002bec:	7c9b      	ldrb	r3, [r3, #18]
 8002bee:	4618      	mov	r0, r3
 8002bf0:	9902      	ldr	r1, [sp, #8]
 8002bf2:	f000 febd 	bl	8003970 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8002bf6:	9b03      	ldr	r3, [sp, #12]
 8002bf8:	7c5b      	ldrb	r3, [r3, #17]
 8002bfa:	2201      	movs	r2, #1
 8002bfc:	409a      	lsls	r2, r3
 8002bfe:	4b05      	ldr	r3, [pc, #20]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002c00:	681b      	ldr	r3, [r3, #0]
 8002c02:	431a      	orrs	r2, r3
 8002c04:	4b03      	ldr	r3, [pc, #12]	; (8002c14 <dmaStreamAllocate+0xd4>)
 8002c06:	601a      	str	r2, [r3, #0]

  return false;
 8002c08:	2300      	movs	r3, #0
}
 8002c0a:	4618      	mov	r0, r3
 8002c0c:	b005      	add	sp, #20
 8002c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c12:	bf00      	nop
 8002c14:	20000b30 	.word	0x20000b30
 8002c18:	20000ad0 	.word	0x20000ad0
 8002c1c:	40021000 	.word	0x40021000

08002c20 <port_lock.8803.4145>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c20:	b082      	sub	sp, #8
 8002c22:	2320      	movs	r3, #32
 8002c24:	9301      	str	r3, [sp, #4]
 8002c26:	9b01      	ldr	r3, [sp, #4]
 8002c28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c2c:	b002      	add	sp, #8
 8002c2e:	4770      	bx	lr

08002c30 <port_unlock.8806.4143>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c30:	b082      	sub	sp, #8
 8002c32:	2300      	movs	r3, #0
 8002c34:	9301      	str	r3, [sp, #4]
 8002c36:	9b01      	ldr	r3, [sp, #4]
 8002c38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c3c:	b002      	add	sp, #8
 8002c3e:	4770      	bx	lr

08002c40 <port_lock_from_isr.8808.4141>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002c40:	b508      	push	{r3, lr}

  port_lock();
 8002c42:	f7ff ffed 	bl	8002c20 <port_lock.8803.4145>
}
 8002c46:	bd08      	pop	{r3, pc}
 8002c48:	f3af 8000 	nop.w
 8002c4c:	f3af 8000 	nop.w

08002c50 <port_unlock_from_isr.8810.4139>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002c50:	b508      	push	{r3, lr}

  port_unlock();
 8002c52:	f7ff ffed 	bl	8002c30 <port_unlock.8806.4143>
}
 8002c56:	bd08      	pop	{r3, pc}
 8002c58:	f3af 8000 	nop.w
 8002c5c:	f3af 8000 	nop.w

08002c60 <chSysLockFromISR.8812.4137>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002c60:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002c62:	f7ff ffed 	bl	8002c40 <port_lock_from_isr.8808.4141>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002c66:	bd08      	pop	{r3, pc}
 8002c68:	f3af 8000 	nop.w
 8002c6c:	f3af 8000 	nop.w

08002c70 <chSysUnlockFromISR.8814.4135>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002c70:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002c72:	f7ff ffed 	bl	8002c50 <port_unlock_from_isr.8810.4139>
}
 8002c76:	bd08      	pop	{r3, pc}
 8002c78:	f3af 8000 	nop.w
 8002c7c:	f3af 8000 	nop.w

08002c80 <osalSysLockFromISR.8816.4133>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002c80:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002c82:	f7ff ffed 	bl	8002c60 <chSysLockFromISR.8812.4137>
}
 8002c86:	bd08      	pop	{r3, pc}
 8002c88:	f3af 8000 	nop.w
 8002c8c:	f3af 8000 	nop.w

08002c90 <osalSysUnlockFromISR.8818.4131>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002c90:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002c92:	f7ff ffed 	bl	8002c70 <chSysUnlockFromISR.8814.4135>
}
 8002c96:	bd08      	pop	{r3, pc}
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <osalOsTimerHandlerI.8820.4129>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8002ca0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8002ca2:	f002 f975 	bl	8004f90 <chSysTimerHandlerI>
}
 8002ca6:	bd08      	pop	{r3, pc}
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8002cb0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8002cb2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cb6:	691b      	ldr	r3, [r3, #16]
 8002cb8:	f003 0302 	and.w	r3, r3, #2
 8002cbc:	2b00      	cmp	r3, #0
 8002cbe:	d009      	beq.n	8002cd4 <VectorB0+0x24>
    STM32_ST_TIM->SR = 0U;
 8002cc0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cc4:	2200      	movs	r2, #0
 8002cc6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8002cc8:	f7ff ffda 	bl	8002c80 <osalSysLockFromISR.8816.4133>
    osalOsTimerHandlerI();
 8002ccc:	f7ff ffe8 	bl	8002ca0 <osalOsTimerHandlerI.8820.4129>
    osalSysUnlockFromISR();
 8002cd0:	f7ff ffde 	bl	8002c90 <osalSysUnlockFromISR.8818.4131>
  }

  OSAL_IRQ_EPILOGUE();
 8002cd4:	f001 fb3c 	bl	8004350 <_port_irq_epilogue>
}
 8002cd8:	bd08      	pop	{r3, pc}
 8002cda:	bf00      	nop
 8002cdc:	f3af 8000 	nop.w

08002ce0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8002ce0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002ce2:	4b19      	ldr	r3, [pc, #100]	; (8002d48 <st_lld_init+0x68>)
 8002ce4:	4a18      	ldr	r2, [pc, #96]	; (8002d48 <st_lld_init+0x68>)
 8002ce6:	69d2      	ldr	r2, [r2, #28]
 8002ce8:	f042 0201 	orr.w	r2, r2, #1
 8002cec:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002cee:	4b17      	ldr	r3, [pc, #92]	; (8002d4c <st_lld_init+0x6c>)
 8002cf0:	4a16      	ldr	r2, [pc, #88]	; (8002d4c <st_lld_init+0x6c>)
 8002cf2:	6892      	ldr	r2, [r2, #8]
 8002cf4:	f042 0201 	orr.w	r2, r2, #1
 8002cf8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002cfa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cfe:	f641 421f 	movw	r2, #7199	; 0x1c1f
 8002d02:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002d04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d08:	f04f 32ff 	mov.w	r2, #4294967295
 8002d0c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002d0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d12:	2200      	movs	r2, #0
 8002d14:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002d16:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d1a:	2200      	movs	r2, #0
 8002d1c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002d1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d22:	2200      	movs	r2, #0
 8002d24:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002d26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d2a:	2200      	movs	r2, #0
 8002d2c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002d2e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d32:	2201      	movs	r2, #1
 8002d34:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002d36:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d3a:	2201      	movs	r2, #1
 8002d3c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8002d3e:	201c      	movs	r0, #28
 8002d40:	2108      	movs	r1, #8
 8002d42:	f000 fe15 	bl	8003970 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002d46:	bd08      	pop	{r3, pc}
 8002d48:	40021000 	.word	0x40021000
 8002d4c:	e0042000 	.word	0xe0042000

08002d50 <ext_lld_init>:
/**
 * @brief   Low level EXT driver initialization.
 *
 * @notapi
 */
void ext_lld_init(void) {
 8002d50:	b508      	push	{r3, lr}

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 8002d52:	4802      	ldr	r0, [pc, #8]	; (8002d5c <ext_lld_init+0xc>)
 8002d54:	f000 fb1c 	bl	8003390 <extObjectInit>
}
 8002d58:	bd08      	pop	{r3, pc}
 8002d5a:	bf00      	nop
 8002d5c:	20000b34 	.word	0x20000b34

08002d60 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8002d60:	b500      	push	{lr}
 8002d62:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 0);
 8002d64:	4b0d      	ldr	r3, [pc, #52]	; (8002d9c <Vector58+0x3c>)
 8002d66:	695a      	ldr	r2, [r3, #20]
 8002d68:	4b0c      	ldr	r3, [pc, #48]	; (8002d9c <Vector58+0x3c>)
 8002d6a:	681b      	ldr	r3, [r3, #0]
 8002d6c:	4013      	ands	r3, r2
 8002d6e:	f003 0301 	and.w	r3, r3, #1
 8002d72:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002d74:	4b09      	ldr	r3, [pc, #36]	; (8002d9c <Vector58+0x3c>)
 8002d76:	9a01      	ldr	r2, [sp, #4]
 8002d78:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 0))
 8002d7a:	9b01      	ldr	r3, [sp, #4]
 8002d7c:	f003 0301 	and.w	r3, r3, #1
 8002d80:	2b00      	cmp	r3, #0
 8002d82:	d005      	beq.n	8002d90 <Vector58+0x30>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
 8002d84:	4b06      	ldr	r3, [pc, #24]	; (8002da0 <Vector58+0x40>)
 8002d86:	685b      	ldr	r3, [r3, #4]
 8002d88:	685b      	ldr	r3, [r3, #4]
 8002d8a:	4805      	ldr	r0, [pc, #20]	; (8002da0 <Vector58+0x40>)
 8002d8c:	2100      	movs	r1, #0
 8002d8e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002d90:	f001 fade 	bl	8004350 <_port_irq_epilogue>
}
 8002d94:	b003      	add	sp, #12
 8002d96:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d9a:	bf00      	nop
 8002d9c:	40010400 	.word	0x40010400
 8002da0:	20000b34 	.word	0x20000b34
 8002da4:	f3af 8000 	nop.w
 8002da8:	f3af 8000 	nop.w
 8002dac:	f3af 8000 	nop.w

08002db0 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8002db0:	b500      	push	{lr}
 8002db2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 1);
 8002db4:	4b0d      	ldr	r3, [pc, #52]	; (8002dec <Vector5C+0x3c>)
 8002db6:	695a      	ldr	r2, [r3, #20]
 8002db8:	4b0c      	ldr	r3, [pc, #48]	; (8002dec <Vector5C+0x3c>)
 8002dba:	681b      	ldr	r3, [r3, #0]
 8002dbc:	4013      	ands	r3, r2
 8002dbe:	f003 0302 	and.w	r3, r3, #2
 8002dc2:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002dc4:	4b09      	ldr	r3, [pc, #36]	; (8002dec <Vector5C+0x3c>)
 8002dc6:	9a01      	ldr	r2, [sp, #4]
 8002dc8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 1))
 8002dca:	9b01      	ldr	r3, [sp, #4]
 8002dcc:	f003 0302 	and.w	r3, r3, #2
 8002dd0:	2b00      	cmp	r3, #0
 8002dd2:	d005      	beq.n	8002de0 <Vector5C+0x30>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
 8002dd4:	4b06      	ldr	r3, [pc, #24]	; (8002df0 <Vector5C+0x40>)
 8002dd6:	685b      	ldr	r3, [r3, #4]
 8002dd8:	68db      	ldr	r3, [r3, #12]
 8002dda:	4805      	ldr	r0, [pc, #20]	; (8002df0 <Vector5C+0x40>)
 8002ddc:	2101      	movs	r1, #1
 8002dde:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002de0:	f001 fab6 	bl	8004350 <_port_irq_epilogue>
}
 8002de4:	b003      	add	sp, #12
 8002de6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dea:	bf00      	nop
 8002dec:	40010400 	.word	0x40010400
 8002df0:	20000b34 	.word	0x20000b34
 8002df4:	f3af 8000 	nop.w
 8002df8:	f3af 8000 	nop.w
 8002dfc:	f3af 8000 	nop.w

08002e00 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 8002e00:	b500      	push	{lr}
 8002e02:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 2);
 8002e04:	4b0d      	ldr	r3, [pc, #52]	; (8002e3c <Vector60+0x3c>)
 8002e06:	695a      	ldr	r2, [r3, #20]
 8002e08:	4b0c      	ldr	r3, [pc, #48]	; (8002e3c <Vector60+0x3c>)
 8002e0a:	681b      	ldr	r3, [r3, #0]
 8002e0c:	4013      	ands	r3, r2
 8002e0e:	f003 0304 	and.w	r3, r3, #4
 8002e12:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002e14:	4b09      	ldr	r3, [pc, #36]	; (8002e3c <Vector60+0x3c>)
 8002e16:	9a01      	ldr	r2, [sp, #4]
 8002e18:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 2))
 8002e1a:	9b01      	ldr	r3, [sp, #4]
 8002e1c:	f003 0304 	and.w	r3, r3, #4
 8002e20:	2b00      	cmp	r3, #0
 8002e22:	d005      	beq.n	8002e30 <Vector60+0x30>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
 8002e24:	4b06      	ldr	r3, [pc, #24]	; (8002e40 <Vector60+0x40>)
 8002e26:	685b      	ldr	r3, [r3, #4]
 8002e28:	695b      	ldr	r3, [r3, #20]
 8002e2a:	4805      	ldr	r0, [pc, #20]	; (8002e40 <Vector60+0x40>)
 8002e2c:	2102      	movs	r1, #2
 8002e2e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002e30:	f001 fa8e 	bl	8004350 <_port_irq_epilogue>
}
 8002e34:	b003      	add	sp, #12
 8002e36:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e3a:	bf00      	nop
 8002e3c:	40010400 	.word	0x40010400
 8002e40:	20000b34 	.word	0x20000b34
 8002e44:	f3af 8000 	nop.w
 8002e48:	f3af 8000 	nop.w
 8002e4c:	f3af 8000 	nop.w

08002e50 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 8002e50:	b500      	push	{lr}
 8002e52:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 3);
 8002e54:	4b0d      	ldr	r3, [pc, #52]	; (8002e8c <Vector64+0x3c>)
 8002e56:	695a      	ldr	r2, [r3, #20]
 8002e58:	4b0c      	ldr	r3, [pc, #48]	; (8002e8c <Vector64+0x3c>)
 8002e5a:	681b      	ldr	r3, [r3, #0]
 8002e5c:	4013      	ands	r3, r2
 8002e5e:	f003 0308 	and.w	r3, r3, #8
 8002e62:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002e64:	4b09      	ldr	r3, [pc, #36]	; (8002e8c <Vector64+0x3c>)
 8002e66:	9a01      	ldr	r2, [sp, #4]
 8002e68:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 3))
 8002e6a:	9b01      	ldr	r3, [sp, #4]
 8002e6c:	f003 0308 	and.w	r3, r3, #8
 8002e70:	2b00      	cmp	r3, #0
 8002e72:	d005      	beq.n	8002e80 <Vector64+0x30>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
 8002e74:	4b06      	ldr	r3, [pc, #24]	; (8002e90 <Vector64+0x40>)
 8002e76:	685b      	ldr	r3, [r3, #4]
 8002e78:	69db      	ldr	r3, [r3, #28]
 8002e7a:	4805      	ldr	r0, [pc, #20]	; (8002e90 <Vector64+0x40>)
 8002e7c:	2103      	movs	r1, #3
 8002e7e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002e80:	f001 fa66 	bl	8004350 <_port_irq_epilogue>
}
 8002e84:	b003      	add	sp, #12
 8002e86:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8a:	bf00      	nop
 8002e8c:	40010400 	.word	0x40010400
 8002e90:	20000b34 	.word	0x20000b34
 8002e94:	f3af 8000 	nop.w
 8002e98:	f3af 8000 	nop.w
 8002e9c:	f3af 8000 	nop.w

08002ea0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 8002ea0:	b500      	push	{lr}
 8002ea2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 4);
 8002ea4:	4b0d      	ldr	r3, [pc, #52]	; (8002edc <Vector68+0x3c>)
 8002ea6:	695a      	ldr	r2, [r3, #20]
 8002ea8:	4b0c      	ldr	r3, [pc, #48]	; (8002edc <Vector68+0x3c>)
 8002eaa:	681b      	ldr	r3, [r3, #0]
 8002eac:	4013      	ands	r3, r2
 8002eae:	f003 0310 	and.w	r3, r3, #16
 8002eb2:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002eb4:	4b09      	ldr	r3, [pc, #36]	; (8002edc <Vector68+0x3c>)
 8002eb6:	9a01      	ldr	r2, [sp, #4]
 8002eb8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 4))
 8002eba:	9b01      	ldr	r3, [sp, #4]
 8002ebc:	f003 0310 	and.w	r3, r3, #16
 8002ec0:	2b00      	cmp	r3, #0
 8002ec2:	d005      	beq.n	8002ed0 <Vector68+0x30>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
 8002ec4:	4b06      	ldr	r3, [pc, #24]	; (8002ee0 <Vector68+0x40>)
 8002ec6:	685b      	ldr	r3, [r3, #4]
 8002ec8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002eca:	4805      	ldr	r0, [pc, #20]	; (8002ee0 <Vector68+0x40>)
 8002ecc:	2104      	movs	r1, #4
 8002ece:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002ed0:	f001 fa3e 	bl	8004350 <_port_irq_epilogue>
}
 8002ed4:	b003      	add	sp, #12
 8002ed6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002eda:	bf00      	nop
 8002edc:	40010400 	.word	0x40010400
 8002ee0:	20000b34 	.word	0x20000b34
 8002ee4:	f3af 8000 	nop.w
 8002ee8:	f3af 8000 	nop.w
 8002eec:	f3af 8000 	nop.w

08002ef0 <Vector9C>:
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 8002ef0:	b500      	push	{lr}
 8002ef2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) |
 8002ef4:	4b23      	ldr	r3, [pc, #140]	; (8002f84 <Vector9C+0x94>)
 8002ef6:	695a      	ldr	r2, [r3, #20]
 8002ef8:	4b22      	ldr	r3, [pc, #136]	; (8002f84 <Vector9C+0x94>)
 8002efa:	681b      	ldr	r3, [r3, #0]
 8002efc:	4013      	ands	r3, r2
 8002efe:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 8002f02:	9301      	str	r3, [sp, #4]
                               (1 << 9));
  EXTI->PR = pr;
 8002f04:	4b1f      	ldr	r3, [pc, #124]	; (8002f84 <Vector9C+0x94>)
 8002f06:	9a01      	ldr	r2, [sp, #4]
 8002f08:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 5))
 8002f0a:	9b01      	ldr	r3, [sp, #4]
 8002f0c:	f003 0320 	and.w	r3, r3, #32
 8002f10:	2b00      	cmp	r3, #0
 8002f12:	d005      	beq.n	8002f20 <Vector9C+0x30>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 8002f14:	4b1c      	ldr	r3, [pc, #112]	; (8002f88 <Vector9C+0x98>)
 8002f16:	685b      	ldr	r3, [r3, #4]
 8002f18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f1a:	481b      	ldr	r0, [pc, #108]	; (8002f88 <Vector9C+0x98>)
 8002f1c:	2105      	movs	r1, #5
 8002f1e:	4798      	blx	r3
  if (pr & (1 << 6))
 8002f20:	9b01      	ldr	r3, [sp, #4]
 8002f22:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002f26:	2b00      	cmp	r3, #0
 8002f28:	d005      	beq.n	8002f36 <Vector9C+0x46>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 8002f2a:	4b17      	ldr	r3, [pc, #92]	; (8002f88 <Vector9C+0x98>)
 8002f2c:	685b      	ldr	r3, [r3, #4]
 8002f2e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002f30:	4815      	ldr	r0, [pc, #84]	; (8002f88 <Vector9C+0x98>)
 8002f32:	2106      	movs	r1, #6
 8002f34:	4798      	blx	r3
  if (pr & (1 << 7))
 8002f36:	9b01      	ldr	r3, [sp, #4]
 8002f38:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002f3c:	2b00      	cmp	r3, #0
 8002f3e:	d005      	beq.n	8002f4c <Vector9C+0x5c>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 8002f40:	4b11      	ldr	r3, [pc, #68]	; (8002f88 <Vector9C+0x98>)
 8002f42:	685b      	ldr	r3, [r3, #4]
 8002f44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f46:	4810      	ldr	r0, [pc, #64]	; (8002f88 <Vector9C+0x98>)
 8002f48:	2107      	movs	r1, #7
 8002f4a:	4798      	blx	r3
  if (pr & (1 << 8))
 8002f4c:	9b01      	ldr	r3, [sp, #4]
 8002f4e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002f52:	2b00      	cmp	r3, #0
 8002f54:	d005      	beq.n	8002f62 <Vector9C+0x72>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 8002f56:	4b0c      	ldr	r3, [pc, #48]	; (8002f88 <Vector9C+0x98>)
 8002f58:	685b      	ldr	r3, [r3, #4]
 8002f5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002f5c:	480a      	ldr	r0, [pc, #40]	; (8002f88 <Vector9C+0x98>)
 8002f5e:	2108      	movs	r1, #8
 8002f60:	4798      	blx	r3
  if (pr & (1 << 9))
 8002f62:	9b01      	ldr	r3, [sp, #4]
 8002f64:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002f68:	2b00      	cmp	r3, #0
 8002f6a:	d005      	beq.n	8002f78 <Vector9C+0x88>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 8002f6c:	4b06      	ldr	r3, [pc, #24]	; (8002f88 <Vector9C+0x98>)
 8002f6e:	685b      	ldr	r3, [r3, #4]
 8002f70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002f72:	4805      	ldr	r0, [pc, #20]	; (8002f88 <Vector9C+0x98>)
 8002f74:	2109      	movs	r1, #9
 8002f76:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002f78:	f001 f9ea 	bl	8004350 <_port_irq_epilogue>
}
 8002f7c:	b003      	add	sp, #12
 8002f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f82:	bf00      	nop
 8002f84:	40010400 	.word	0x40010400
 8002f88:	20000b34 	.word	0x20000b34
 8002f8c:	f3af 8000 	nop.w

08002f90 <VectorE0>:
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 8002f90:	b500      	push	{lr}
 8002f92:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) |
 8002f94:	4b28      	ldr	r3, [pc, #160]	; (8003038 <VectorE0+0xa8>)
 8002f96:	695a      	ldr	r2, [r3, #20]
 8002f98:	4b27      	ldr	r3, [pc, #156]	; (8003038 <VectorE0+0xa8>)
 8002f9a:	681b      	ldr	r3, [r3, #0]
 8002f9c:	4013      	ands	r3, r2
 8002f9e:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8002fa2:	9301      	str	r3, [sp, #4]
                               (1 << 14) | (1 << 15));
  EXTI->PR = pr;
 8002fa4:	4b24      	ldr	r3, [pc, #144]	; (8003038 <VectorE0+0xa8>)
 8002fa6:	9a01      	ldr	r2, [sp, #4]
 8002fa8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 10))
 8002faa:	9b01      	ldr	r3, [sp, #4]
 8002fac:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002fb0:	2b00      	cmp	r3, #0
 8002fb2:	d005      	beq.n	8002fc0 <VectorE0+0x30>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 8002fb4:	4b21      	ldr	r3, [pc, #132]	; (800303c <VectorE0+0xac>)
 8002fb6:	685b      	ldr	r3, [r3, #4]
 8002fb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002fba:	4820      	ldr	r0, [pc, #128]	; (800303c <VectorE0+0xac>)
 8002fbc:	210a      	movs	r1, #10
 8002fbe:	4798      	blx	r3
  if (pr & (1 << 11))
 8002fc0:	9b01      	ldr	r3, [sp, #4]
 8002fc2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8002fc6:	2b00      	cmp	r3, #0
 8002fc8:	d005      	beq.n	8002fd6 <VectorE0+0x46>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 8002fca:	4b1c      	ldr	r3, [pc, #112]	; (800303c <VectorE0+0xac>)
 8002fcc:	685b      	ldr	r3, [r3, #4]
 8002fce:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002fd0:	481a      	ldr	r0, [pc, #104]	; (800303c <VectorE0+0xac>)
 8002fd2:	210b      	movs	r1, #11
 8002fd4:	4798      	blx	r3
  if (pr & (1 << 12))
 8002fd6:	9b01      	ldr	r3, [sp, #4]
 8002fd8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002fdc:	2b00      	cmp	r3, #0
 8002fde:	d005      	beq.n	8002fec <VectorE0+0x5c>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 8002fe0:	4b16      	ldr	r3, [pc, #88]	; (800303c <VectorE0+0xac>)
 8002fe2:	685b      	ldr	r3, [r3, #4]
 8002fe4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8002fe6:	4815      	ldr	r0, [pc, #84]	; (800303c <VectorE0+0xac>)
 8002fe8:	210c      	movs	r1, #12
 8002fea:	4798      	blx	r3
  if (pr & (1 << 13))
 8002fec:	9b01      	ldr	r3, [sp, #4]
 8002fee:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002ff2:	2b00      	cmp	r3, #0
 8002ff4:	d005      	beq.n	8003002 <VectorE0+0x72>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 8002ff6:	4b11      	ldr	r3, [pc, #68]	; (800303c <VectorE0+0xac>)
 8002ff8:	685b      	ldr	r3, [r3, #4]
 8002ffa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002ffc:	480f      	ldr	r0, [pc, #60]	; (800303c <VectorE0+0xac>)
 8002ffe:	210d      	movs	r1, #13
 8003000:	4798      	blx	r3
  if (pr & (1 << 14))
 8003002:	9b01      	ldr	r3, [sp, #4]
 8003004:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003008:	2b00      	cmp	r3, #0
 800300a:	d005      	beq.n	8003018 <VectorE0+0x88>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 800300c:	4b0b      	ldr	r3, [pc, #44]	; (800303c <VectorE0+0xac>)
 800300e:	685b      	ldr	r3, [r3, #4]
 8003010:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8003012:	480a      	ldr	r0, [pc, #40]	; (800303c <VectorE0+0xac>)
 8003014:	210e      	movs	r1, #14
 8003016:	4798      	blx	r3
  if (pr & (1 << 15))
 8003018:	9b01      	ldr	r3, [sp, #4]
 800301a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800301e:	2b00      	cmp	r3, #0
 8003020:	d005      	beq.n	800302e <VectorE0+0x9e>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8003022:	4b06      	ldr	r3, [pc, #24]	; (800303c <VectorE0+0xac>)
 8003024:	685b      	ldr	r3, [r3, #4]
 8003026:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8003028:	4804      	ldr	r0, [pc, #16]	; (800303c <VectorE0+0xac>)
 800302a:	210f      	movs	r1, #15
 800302c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800302e:	f001 f98f 	bl	8004350 <_port_irq_epilogue>
}
 8003032:	b003      	add	sp, #12
 8003034:	f85d fb04 	ldr.w	pc, [sp], #4
 8003038:	40010400 	.word	0x40010400
 800303c:	20000b34 	.word	0x20000b34

08003040 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 8003040:	b500      	push	{lr}
 8003042:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 16);
 8003044:	4b0d      	ldr	r3, [pc, #52]	; (800307c <Vector44+0x3c>)
 8003046:	695a      	ldr	r2, [r3, #20]
 8003048:	4b0c      	ldr	r3, [pc, #48]	; (800307c <Vector44+0x3c>)
 800304a:	681b      	ldr	r3, [r3, #0]
 800304c:	4013      	ands	r3, r2
 800304e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003052:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003054:	4b09      	ldr	r3, [pc, #36]	; (800307c <Vector44+0x3c>)
 8003056:	9a01      	ldr	r2, [sp, #4]
 8003058:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 16))
 800305a:	9b01      	ldr	r3, [sp, #4]
 800305c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003060:	2b00      	cmp	r3, #0
 8003062:	d006      	beq.n	8003072 <Vector44+0x32>
    EXTD1.config->channels[16].cb(&EXTD1, 16);
 8003064:	4b06      	ldr	r3, [pc, #24]	; (8003080 <Vector44+0x40>)
 8003066:	685b      	ldr	r3, [r3, #4]
 8003068:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800306c:	4804      	ldr	r0, [pc, #16]	; (8003080 <Vector44+0x40>)
 800306e:	2110      	movs	r1, #16
 8003070:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003072:	f001 f96d 	bl	8004350 <_port_irq_epilogue>
}
 8003076:	b003      	add	sp, #12
 8003078:	f85d fb04 	ldr.w	pc, [sp], #4
 800307c:	40010400 	.word	0x40010400
 8003080:	20000b34 	.word	0x20000b34
 8003084:	f3af 8000 	nop.w
 8003088:	f3af 8000 	nop.w
 800308c:	f3af 8000 	nop.w

08003090 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC Alarm).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 8003090:	b500      	push	{lr}
 8003092:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 17);
 8003094:	4b0d      	ldr	r3, [pc, #52]	; (80030cc <VectorE4+0x3c>)
 8003096:	695a      	ldr	r2, [r3, #20]
 8003098:	4b0c      	ldr	r3, [pc, #48]	; (80030cc <VectorE4+0x3c>)
 800309a:	681b      	ldr	r3, [r3, #0]
 800309c:	4013      	ands	r3, r2
 800309e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80030a2:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80030a4:	4b09      	ldr	r3, [pc, #36]	; (80030cc <VectorE4+0x3c>)
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 17))
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80030b0:	2b00      	cmp	r3, #0
 80030b2:	d006      	beq.n	80030c2 <VectorE4+0x32>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
 80030b4:	4b06      	ldr	r3, [pc, #24]	; (80030d0 <VectorE4+0x40>)
 80030b6:	685b      	ldr	r3, [r3, #4]
 80030b8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80030bc:	4804      	ldr	r0, [pc, #16]	; (80030d0 <VectorE4+0x40>)
 80030be:	2111      	movs	r1, #17
 80030c0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80030c2:	f001 f945 	bl	8004350 <_port_irq_epilogue>
}
 80030c6:	b003      	add	sp, #12
 80030c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80030cc:	40010400 	.word	0x40010400
 80030d0:	20000b34 	.word	0x20000b34
 80030d4:	f3af 8000 	nop.w
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (USB Wakeup).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 18);
 80030e4:	4b0d      	ldr	r3, [pc, #52]	; (800311c <VectorE8+0x3c>)
 80030e6:	695a      	ldr	r2, [r3, #20]
 80030e8:	4b0c      	ldr	r3, [pc, #48]	; (800311c <VectorE8+0x3c>)
 80030ea:	681b      	ldr	r3, [r3, #0]
 80030ec:	4013      	ands	r3, r2
 80030ee:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80030f2:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80030f4:	4b09      	ldr	r3, [pc, #36]	; (800311c <VectorE8+0x3c>)
 80030f6:	9a01      	ldr	r2, [sp, #4]
 80030f8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 18))
 80030fa:	9b01      	ldr	r3, [sp, #4]
 80030fc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8003100:	2b00      	cmp	r3, #0
 8003102:	d006      	beq.n	8003112 <VectorE8+0x32>
    EXTD1.config->channels[18].cb(&EXTD1, 18);
 8003104:	4b06      	ldr	r3, [pc, #24]	; (8003120 <VectorE8+0x40>)
 8003106:	685b      	ldr	r3, [r3, #4]
 8003108:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800310c:	4804      	ldr	r0, [pc, #16]	; (8003120 <VectorE8+0x40>)
 800310e:	2112      	movs	r1, #18
 8003110:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003112:	f001 f91d 	bl	8004350 <_port_irq_epilogue>
}
 8003116:	b003      	add	sp, #12
 8003118:	f85d fb04 	ldr.w	pc, [sp], #4
 800311c:	40010400 	.word	0x40010400
 8003120:	20000b34 	.word	0x20000b34
 8003124:	f3af 8000 	nop.w
 8003128:	f3af 8000 	nop.w
 800312c:	f3af 8000 	nop.w

08003130 <Vector48>:
/**
 * @brief   EXTI[19] interrupt handler (Tamper TimeStamp).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 8003130:	b500      	push	{lr}
 8003132:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 19);
 8003134:	4b0d      	ldr	r3, [pc, #52]	; (800316c <Vector48+0x3c>)
 8003136:	695a      	ldr	r2, [r3, #20]
 8003138:	4b0c      	ldr	r3, [pc, #48]	; (800316c <Vector48+0x3c>)
 800313a:	681b      	ldr	r3, [r3, #0]
 800313c:	4013      	ands	r3, r2
 800313e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8003142:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003144:	4b09      	ldr	r3, [pc, #36]	; (800316c <Vector48+0x3c>)
 8003146:	9a01      	ldr	r2, [sp, #4]
 8003148:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 19))
 800314a:	9b01      	ldr	r3, [sp, #4]
 800314c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8003150:	2b00      	cmp	r3, #0
 8003152:	d006      	beq.n	8003162 <Vector48+0x32>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
 8003154:	4b06      	ldr	r3, [pc, #24]	; (8003170 <Vector48+0x40>)
 8003156:	685b      	ldr	r3, [r3, #4]
 8003158:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800315c:	4804      	ldr	r0, [pc, #16]	; (8003170 <Vector48+0x40>)
 800315e:	2113      	movs	r1, #19
 8003160:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003162:	f001 f8f5 	bl	8004350 <_port_irq_epilogue>
}
 8003166:	b003      	add	sp, #12
 8003168:	f85d fb04 	ldr.w	pc, [sp], #4
 800316c:	40010400 	.word	0x40010400
 8003170:	20000b34 	.word	0x20000b34
 8003174:	f3af 8000 	nop.w
 8003178:	f3af 8000 	nop.w
 800317c:	f3af 8000 	nop.w

08003180 <Vector4C>:
/**
 * @brief   EXTI[20] interrupt handler (RTC Wakeup).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 8003180:	b500      	push	{lr}
 8003182:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & (1 << 20);
 8003184:	4b0d      	ldr	r3, [pc, #52]	; (80031bc <Vector4C+0x3c>)
 8003186:	695a      	ldr	r2, [r3, #20]
 8003188:	4b0c      	ldr	r3, [pc, #48]	; (80031bc <Vector4C+0x3c>)
 800318a:	681b      	ldr	r3, [r3, #0]
 800318c:	4013      	ands	r3, r2
 800318e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003192:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003194:	4b09      	ldr	r3, [pc, #36]	; (80031bc <Vector4C+0x3c>)
 8003196:	9a01      	ldr	r2, [sp, #4]
 8003198:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 20))
 800319a:	9b01      	ldr	r3, [sp, #4]
 800319c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80031a0:	2b00      	cmp	r3, #0
 80031a2:	d006      	beq.n	80031b2 <Vector4C+0x32>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
 80031a4:	4b06      	ldr	r3, [pc, #24]	; (80031c0 <Vector4C+0x40>)
 80031a6:	685b      	ldr	r3, [r3, #4]
 80031a8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80031ac:	4804      	ldr	r0, [pc, #16]	; (80031c0 <Vector4C+0x40>)
 80031ae:	2114      	movs	r1, #20
 80031b0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80031b2:	f001 f8cd 	bl	8004350 <_port_irq_epilogue>
}
 80031b6:	b003      	add	sp, #12
 80031b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80031bc:	40010400 	.word	0x40010400
 80031c0:	20000b34 	.word	0x20000b34
 80031c4:	f3af 8000 	nop.w
 80031c8:	f3af 8000 	nop.w
 80031cc:	f3af 8000 	nop.w

080031d0 <Vector140>:
/**
 * @brief   EXTI[21],EXTI[22],EXTI[29] interrupt handler (COMP1, COMP2, COMP3).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector140) {
 80031d0:	b500      	push	{lr}
 80031d2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & ((1 << 21) | (1 << 22) | (1 << 29));
 80031d4:	4b19      	ldr	r3, [pc, #100]	; (800323c <Vector140+0x6c>)
 80031d6:	695a      	ldr	r2, [r3, #20]
 80031d8:	4b18      	ldr	r3, [pc, #96]	; (800323c <Vector140+0x6c>)
 80031da:	681b      	ldr	r3, [r3, #0]
 80031dc:	401a      	ands	r2, r3
 80031de:	4b18      	ldr	r3, [pc, #96]	; (8003240 <Vector140+0x70>)
 80031e0:	4013      	ands	r3, r2
 80031e2:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80031e4:	4b15      	ldr	r3, [pc, #84]	; (800323c <Vector140+0x6c>)
 80031e6:	9a01      	ldr	r2, [sp, #4]
 80031e8:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 21))
 80031ea:	9b01      	ldr	r3, [sp, #4]
 80031ec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80031f0:	2b00      	cmp	r3, #0
 80031f2:	d006      	beq.n	8003202 <Vector140+0x32>
    EXTD1.config->channels[21].cb(&EXTD1, 21);
 80031f4:	4b13      	ldr	r3, [pc, #76]	; (8003244 <Vector140+0x74>)
 80031f6:	685b      	ldr	r3, [r3, #4]
 80031f8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80031fc:	4811      	ldr	r0, [pc, #68]	; (8003244 <Vector140+0x74>)
 80031fe:	2115      	movs	r1, #21
 8003200:	4798      	blx	r3
  if (pr & (1 << 22))
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003208:	2b00      	cmp	r3, #0
 800320a:	d006      	beq.n	800321a <Vector140+0x4a>
    EXTD1.config->channels[22].cb(&EXTD1, 22);
 800320c:	4b0d      	ldr	r3, [pc, #52]	; (8003244 <Vector140+0x74>)
 800320e:	685b      	ldr	r3, [r3, #4]
 8003210:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8003214:	480b      	ldr	r0, [pc, #44]	; (8003244 <Vector140+0x74>)
 8003216:	2116      	movs	r1, #22
 8003218:	4798      	blx	r3
  if (pr & (1 << 29))
 800321a:	9b01      	ldr	r3, [sp, #4]
 800321c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8003220:	2b00      	cmp	r3, #0
 8003222:	d006      	beq.n	8003232 <Vector140+0x62>
    EXTD1.config->channels[29].cb(&EXTD1, 29);
 8003224:	4b07      	ldr	r3, [pc, #28]	; (8003244 <Vector140+0x74>)
 8003226:	685b      	ldr	r3, [r3, #4]
 8003228:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800322c:	4805      	ldr	r0, [pc, #20]	; (8003244 <Vector140+0x74>)
 800322e:	211d      	movs	r1, #29
 8003230:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003232:	f001 f88d 	bl	8004350 <_port_irq_epilogue>
}
 8003236:	b003      	add	sp, #12
 8003238:	f85d fb04 	ldr.w	pc, [sp], #4
 800323c:	40010400 	.word	0x40010400
 8003240:	20600000 	.word	0x20600000
 8003244:	20000b34 	.word	0x20000b34
 8003248:	f3af 8000 	nop.w
 800324c:	f3af 8000 	nop.w

08003250 <Vector144>:
/**
 * @brief   EXTI[30]...EXTI[32] interrupt handler (COMP4, COMP5, COMP6).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector144) {
 8003250:	b500      	push	{lr}
 8003252:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & EXTI->IMR & ((1 << 30) | (1 << 31));
 8003254:	4b1e      	ldr	r3, [pc, #120]	; (80032d0 <Vector144+0x80>)
 8003256:	695a      	ldr	r2, [r3, #20]
 8003258:	4b1d      	ldr	r3, [pc, #116]	; (80032d0 <Vector144+0x80>)
 800325a:	681b      	ldr	r3, [r3, #0]
 800325c:	4013      	ands	r3, r2
 800325e:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8003262:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003264:	4b1a      	ldr	r3, [pc, #104]	; (80032d0 <Vector144+0x80>)
 8003266:	9a01      	ldr	r2, [sp, #4]
 8003268:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 30))
 800326a:	9b01      	ldr	r3, [sp, #4]
 800326c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8003270:	2b00      	cmp	r3, #0
 8003272:	d006      	beq.n	8003282 <Vector144+0x32>
    EXTD1.config->channels[30].cb(&EXTD1, 30);
 8003274:	4b17      	ldr	r3, [pc, #92]	; (80032d4 <Vector144+0x84>)
 8003276:	685b      	ldr	r3, [r3, #4]
 8003278:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800327c:	4815      	ldr	r0, [pc, #84]	; (80032d4 <Vector144+0x84>)
 800327e:	211e      	movs	r1, #30
 8003280:	4798      	blx	r3
  if (pr & (1 << 31))
 8003282:	9b01      	ldr	r3, [sp, #4]
 8003284:	2b00      	cmp	r3, #0
 8003286:	da06      	bge.n	8003296 <Vector144+0x46>
    EXTD1.config->channels[31].cb(&EXTD1, 31);
 8003288:	4b12      	ldr	r3, [pc, #72]	; (80032d4 <Vector144+0x84>)
 800328a:	685b      	ldr	r3, [r3, #4]
 800328c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8003290:	4810      	ldr	r0, [pc, #64]	; (80032d4 <Vector144+0x84>)
 8003292:	211f      	movs	r1, #31
 8003294:	4798      	blx	r3

  pr = EXTI->PR2 & EXTI->IMR2 & (1 << 0);
 8003296:	4b0e      	ldr	r3, [pc, #56]	; (80032d0 <Vector144+0x80>)
 8003298:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800329a:	4b0d      	ldr	r3, [pc, #52]	; (80032d0 <Vector144+0x80>)
 800329c:	6a1b      	ldr	r3, [r3, #32]
 800329e:	4013      	ands	r3, r2
 80032a0:	f003 0301 	and.w	r3, r3, #1
 80032a4:	9301      	str	r3, [sp, #4]
  EXTI->PR2 = pr;
 80032a6:	4b0a      	ldr	r3, [pc, #40]	; (80032d0 <Vector144+0x80>)
 80032a8:	9a01      	ldr	r2, [sp, #4]
 80032aa:	635a      	str	r2, [r3, #52]	; 0x34
  if (pr & (1 << 0))
 80032ac:	9b01      	ldr	r3, [sp, #4]
 80032ae:	f003 0301 	and.w	r3, r3, #1
 80032b2:	2b00      	cmp	r3, #0
 80032b4:	d006      	beq.n	80032c4 <Vector144+0x74>
    EXTD1.config->channels[32].cb(&EXTD1, 32);
 80032b6:	4b07      	ldr	r3, [pc, #28]	; (80032d4 <Vector144+0x84>)
 80032b8:	685b      	ldr	r3, [r3, #4]
 80032ba:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80032be:	4805      	ldr	r0, [pc, #20]	; (80032d4 <Vector144+0x84>)
 80032c0:	2120      	movs	r1, #32
 80032c2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80032c4:	f001 f844 	bl	8004350 <_port_irq_epilogue>
}
 80032c8:	b003      	add	sp, #12
 80032ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80032ce:	bf00      	nop
 80032d0:	40010400 	.word	0x40010400
 80032d4:	20000b34 	.word	0x20000b34
 80032d8:	f3af 8000 	nop.w
 80032dc:	f3af 8000 	nop.w

080032e0 <Vector148>:
/**
 * @brief   EXTI[33] interrupt handler (COMP7).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector148) {
 80032e0:	b500      	push	{lr}
 80032e2:	b083      	sub	sp, #12
  uint32_t pr2;

  OSAL_IRQ_PROLOGUE();

  pr2 = EXTI->PR2 & EXTI->IMR & (1 << 1);
 80032e4:	4b0d      	ldr	r3, [pc, #52]	; (800331c <Vector148+0x3c>)
 80032e6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80032e8:	4b0c      	ldr	r3, [pc, #48]	; (800331c <Vector148+0x3c>)
 80032ea:	681b      	ldr	r3, [r3, #0]
 80032ec:	4013      	ands	r3, r2
 80032ee:	f003 0302 	and.w	r3, r3, #2
 80032f2:	9301      	str	r3, [sp, #4]
  EXTI->PR2 = pr2;
 80032f4:	4b09      	ldr	r3, [pc, #36]	; (800331c <Vector148+0x3c>)
 80032f6:	9a01      	ldr	r2, [sp, #4]
 80032f8:	635a      	str	r2, [r3, #52]	; 0x34
  if (pr2 & (1 << 1))
 80032fa:	9b01      	ldr	r3, [sp, #4]
 80032fc:	f003 0302 	and.w	r3, r3, #2
 8003300:	2b00      	cmp	r3, #0
 8003302:	d006      	beq.n	8003312 <Vector148+0x32>
    EXTD1.config->channels[33].cb(&EXTD1, 33);
 8003304:	4b06      	ldr	r3, [pc, #24]	; (8003320 <Vector148+0x40>)
 8003306:	685b      	ldr	r3, [r3, #4]
 8003308:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800330c:	4804      	ldr	r0, [pc, #16]	; (8003320 <Vector148+0x40>)
 800330e:	2121      	movs	r1, #33	; 0x21
 8003310:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003312:	f001 f81d 	bl	8004350 <_port_irq_epilogue>
}
 8003316:	b003      	add	sp, #12
 8003318:	f85d fb04 	ldr.w	pc, [sp], #4
 800331c:	40010400 	.word	0x40010400
 8003320:	20000b34 	.word	0x20000b34
 8003324:	f3af 8000 	nop.w
 8003328:	f3af 8000 	nop.w
 800332c:	f3af 8000 	nop.w

08003330 <initgpio.9011>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8003330:	b082      	sub	sp, #8
 8003332:	9001      	str	r0, [sp, #4]
 8003334:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8003336:	9b00      	ldr	r3, [sp, #0]
 8003338:	685a      	ldr	r2, [r3, #4]
 800333a:	9b01      	ldr	r3, [sp, #4]
 800333c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800333e:	9b00      	ldr	r3, [sp, #0]
 8003340:	689a      	ldr	r2, [r3, #8]
 8003342:	9b01      	ldr	r3, [sp, #4]
 8003344:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8003346:	9b00      	ldr	r3, [sp, #0]
 8003348:	68da      	ldr	r2, [r3, #12]
 800334a:	9b01      	ldr	r3, [sp, #4]
 800334c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800334e:	9b00      	ldr	r3, [sp, #0]
 8003350:	691a      	ldr	r2, [r3, #16]
 8003352:	9b01      	ldr	r3, [sp, #4]
 8003354:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8003356:	9b00      	ldr	r3, [sp, #0]
 8003358:	695a      	ldr	r2, [r3, #20]
 800335a:	9b01      	ldr	r3, [sp, #4]
 800335c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800335e:	9b00      	ldr	r3, [sp, #0]
 8003360:	699a      	ldr	r2, [r3, #24]
 8003362:	9b01      	ldr	r3, [sp, #4]
 8003364:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003366:	9b00      	ldr	r3, [sp, #0]
 8003368:	681a      	ldr	r2, [r3, #0]
 800336a:	9b01      	ldr	r3, [sp, #4]
 800336c:	601a      	str	r2, [r3, #0]
}
 800336e:	b002      	add	sp, #8
 8003370:	4770      	bx	lr
 8003372:	bf00      	nop
 8003374:	f3af 8000 	nop.w
 8003378:	f3af 8000 	nop.w
 800337c:	f3af 8000 	nop.w

08003380 <extInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void extInit(void) {
 8003380:	b508      	push	{r3, lr}

  ext_lld_init();
 8003382:	f7ff fce5 	bl	8002d50 <ext_lld_init>
}
 8003386:	bd08      	pop	{r3, pc}
 8003388:	f3af 8000 	nop.w
 800338c:	f3af 8000 	nop.w

08003390 <extObjectInit>:
 *
 * @param[out] extp     pointer to the @p EXTDriver object
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {
 8003390:	b082      	sub	sp, #8
 8003392:	9001      	str	r0, [sp, #4]

  extp->state  = EXT_STOP;
 8003394:	9b01      	ldr	r3, [sp, #4]
 8003396:	2201      	movs	r2, #1
 8003398:	701a      	strb	r2, [r3, #0]
  extp->config = NULL;
 800339a:	9b01      	ldr	r3, [sp, #4]
 800339c:	2200      	movs	r2, #0
 800339e:	605a      	str	r2, [r3, #4]
}
 80033a0:	b002      	add	sp, #8
 80033a2:	4770      	bx	lr
 80033a4:	f3af 8000 	nop.w
 80033a8:	f3af 8000 	nop.w
 80033ac:	f3af 8000 	nop.w

080033b0 <port_lock.8056.4445>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80033b0:	b082      	sub	sp, #8
 80033b2:	2320      	movs	r3, #32
 80033b4:	9301      	str	r3, [sp, #4]
 80033b6:	9b01      	ldr	r3, [sp, #4]
 80033b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80033bc:	b002      	add	sp, #8
 80033be:	4770      	bx	lr

080033c0 <port_unlock.8059.4443>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80033c0:	b082      	sub	sp, #8
 80033c2:	2300      	movs	r3, #0
 80033c4:	9301      	str	r3, [sp, #4]
 80033c6:	9b01      	ldr	r3, [sp, #4]
 80033c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80033cc:	b002      	add	sp, #8
 80033ce:	4770      	bx	lr

080033d0 <chSysLock.8061.4441>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80033d0:	b508      	push	{r3, lr}

  port_lock();
 80033d2:	f7ff ffed 	bl	80033b0 <port_lock.8056.4445>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80033d6:	bd08      	pop	{r3, pc}
 80033d8:	f3af 8000 	nop.w
 80033dc:	f3af 8000 	nop.w

080033e0 <chSysUnlock.8063.4439>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80033e0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80033e2:	f7ff ffed 	bl	80033c0 <port_unlock.8059.4443>
}
 80033e6:	bd08      	pop	{r3, pc}
 80033e8:	f3af 8000 	nop.w
 80033ec:	f3af 8000 	nop.w

080033f0 <chEvtObjectInit.8065.4436>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80033f0:	b082      	sub	sp, #8
 80033f2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80033f4:	9b01      	ldr	r3, [sp, #4]
 80033f6:	9a01      	ldr	r2, [sp, #4]
 80033f8:	601a      	str	r2, [r3, #0]
}
 80033fa:	b002      	add	sp, #8
 80033fc:	4770      	bx	lr
 80033fe:	bf00      	nop

08003400 <chIQIsEmptyI.8154.4433>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003400:	b082      	sub	sp, #8
 8003402:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003404:	9b01      	ldr	r3, [sp, #4]
 8003406:	689b      	ldr	r3, [r3, #8]
 8003408:	2b00      	cmp	r3, #0
 800340a:	bf14      	ite	ne
 800340c:	2300      	movne	r3, #0
 800340e:	2301      	moveq	r3, #1
 8003410:	b2db      	uxtb	r3, r3
}
 8003412:	4618      	mov	r0, r3
 8003414:	b002      	add	sp, #8
 8003416:	4770      	bx	lr
 8003418:	f3af 8000 	nop.w
 800341c:	f3af 8000 	nop.w

08003420 <osalSysLock.8175.4428>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003420:	b508      	push	{r3, lr}

  chSysLock();
 8003422:	f7ff ffd5 	bl	80033d0 <chSysLock.8061.4441>
}
 8003426:	bd08      	pop	{r3, pc}
 8003428:	f3af 8000 	nop.w
 800342c:	f3af 8000 	nop.w

08003430 <osalSysUnlock.8177.4426>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003430:	b508      	push	{r3, lr}

  chSysUnlock();
 8003432:	f7ff ffd5 	bl	80033e0 <chSysUnlock.8063.4439>
}
 8003436:	bd08      	pop	{r3, pc}
 8003438:	f3af 8000 	nop.w
 800343c:	f3af 8000 	nop.w

08003440 <osalEventObjectInit.8179.4421>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8003440:	b500      	push	{lr}
 8003442:	b083      	sub	sp, #12
 8003444:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8003446:	9801      	ldr	r0, [sp, #4]
 8003448:	f7ff ffd2 	bl	80033f0 <chEvtObjectInit.8065.4436>
}
 800344c:	b003      	add	sp, #12
 800344e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003452:	bf00      	nop
 8003454:	f3af 8000 	nop.w
 8003458:	f3af 8000 	nop.w
 800345c:	f3af 8000 	nop.w

08003460 <osalEventBroadcastFlagsI.8223.4417>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8003460:	b500      	push	{lr}
 8003462:	b083      	sub	sp, #12
 8003464:	9001      	str	r0, [sp, #4]
 8003466:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8003468:	9801      	ldr	r0, [sp, #4]
 800346a:	9900      	ldr	r1, [sp, #0]
 800346c:	f001 fab0 	bl	80049d0 <chEvtBroadcastFlagsI>
}
 8003470:	b003      	add	sp, #12
 8003472:	f85d fb04 	ldr.w	pc, [sp], #4
 8003476:	bf00      	nop
 8003478:	f3af 8000 	nop.w
 800347c:	f3af 8000 	nop.w

08003480 <write.8182>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8003480:	b500      	push	{lr}
 8003482:	b085      	sub	sp, #20
 8003484:	9003      	str	r0, [sp, #12]
 8003486:	9102      	str	r1, [sp, #8]
 8003488:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	3330      	adds	r3, #48	; 0x30
 800348e:	4618      	mov	r0, r3
 8003490:	9902      	ldr	r1, [sp, #8]
 8003492:	9a01      	ldr	r2, [sp, #4]
 8003494:	f04f 33ff 	mov.w	r3, #4294967295
 8003498:	f000 fd22 	bl	8003ee0 <chOQWriteTimeout>
 800349c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800349e:	4618      	mov	r0, r3
 80034a0:	b005      	add	sp, #20
 80034a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034a6:	bf00      	nop
 80034a8:	f3af 8000 	nop.w
 80034ac:	f3af 8000 	nop.w

080034b0 <read.8194>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80034b0:	b500      	push	{lr}
 80034b2:	b085      	sub	sp, #20
 80034b4:	9003      	str	r0, [sp, #12]
 80034b6:	9102      	str	r1, [sp, #8]
 80034b8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80034ba:	9b03      	ldr	r3, [sp, #12]
 80034bc:	330c      	adds	r3, #12
 80034be:	4618      	mov	r0, r3
 80034c0:	9902      	ldr	r1, [sp, #8]
 80034c2:	9a01      	ldr	r2, [sp, #4]
 80034c4:	f04f 33ff 	mov.w	r3, #4294967295
 80034c8:	f000 fc12 	bl	8003cf0 <chIQReadTimeout>
 80034cc:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 80034ce:	4618      	mov	r0, r3
 80034d0:	b005      	add	sp, #20
 80034d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034d6:	bf00      	nop
 80034d8:	f3af 8000 	nop.w
 80034dc:	f3af 8000 	nop.w

080034e0 <put.8205>:

static msg_t put(void *ip, uint8_t b) {
 80034e0:	b500      	push	{lr}
 80034e2:	b083      	sub	sp, #12
 80034e4:	9001      	str	r0, [sp, #4]
 80034e6:	460b      	mov	r3, r1
 80034e8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80034ec:	9b01      	ldr	r3, [sp, #4]
 80034ee:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80034f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80034f6:	4610      	mov	r0, r2
 80034f8:	4619      	mov	r1, r3
 80034fa:	f04f 32ff 	mov.w	r2, #4294967295
 80034fe:	f000 fc77 	bl	8003df0 <chOQPutTimeout>
 8003502:	4603      	mov	r3, r0
}
 8003504:	4618      	mov	r0, r3
 8003506:	b003      	add	sp, #12
 8003508:	f85d fb04 	ldr.w	pc, [sp], #4
 800350c:	f3af 8000 	nop.w

08003510 <get.8214>:

static msg_t get(void *ip) {
 8003510:	b500      	push	{lr}
 8003512:	b083      	sub	sp, #12
 8003514:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003516:	9b01      	ldr	r3, [sp, #4]
 8003518:	330c      	adds	r3, #12
 800351a:	4618      	mov	r0, r3
 800351c:	f04f 31ff 	mov.w	r1, #4294967295
 8003520:	f000 fb9e 	bl	8003c60 <chIQGetTimeout>
 8003524:	4603      	mov	r3, r0
}
 8003526:	4618      	mov	r0, r3
 8003528:	b003      	add	sp, #12
 800352a:	f85d fb04 	ldr.w	pc, [sp], #4
 800352e:	bf00      	nop

08003530 <putt.8209>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8003530:	b500      	push	{lr}
 8003532:	b085      	sub	sp, #20
 8003534:	9003      	str	r0, [sp, #12]
 8003536:	460b      	mov	r3, r1
 8003538:	9201      	str	r2, [sp, #4]
 800353a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 800353e:	9b03      	ldr	r3, [sp, #12]
 8003540:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8003544:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003548:	4610      	mov	r0, r2
 800354a:	4619      	mov	r1, r3
 800354c:	9a01      	ldr	r2, [sp, #4]
 800354e:	f000 fc4f 	bl	8003df0 <chOQPutTimeout>
 8003552:	4603      	mov	r3, r0
}
 8003554:	4618      	mov	r0, r3
 8003556:	b005      	add	sp, #20
 8003558:	f85d fb04 	ldr.w	pc, [sp], #4
 800355c:	f3af 8000 	nop.w

08003560 <gett.8217>:

static msg_t gett(void *ip, systime_t timeout) {
 8003560:	b500      	push	{lr}
 8003562:	b083      	sub	sp, #12
 8003564:	9001      	str	r0, [sp, #4]
 8003566:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003568:	9b01      	ldr	r3, [sp, #4]
 800356a:	330c      	adds	r3, #12
 800356c:	4618      	mov	r0, r3
 800356e:	9900      	ldr	r1, [sp, #0]
 8003570:	f000 fb76 	bl	8003c60 <chIQGetTimeout>
 8003574:	4603      	mov	r3, r0
}
 8003576:	4618      	mov	r0, r3
 8003578:	b003      	add	sp, #12
 800357a:	f85d fb04 	ldr.w	pc, [sp], #4
 800357e:	bf00      	nop

08003580 <writet.8187>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8003580:	b500      	push	{lr}
 8003582:	b085      	sub	sp, #20
 8003584:	9003      	str	r0, [sp, #12]
 8003586:	9102      	str	r1, [sp, #8]
 8003588:	9201      	str	r2, [sp, #4]
 800358a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800358c:	9b03      	ldr	r3, [sp, #12]
 800358e:	3330      	adds	r3, #48	; 0x30
 8003590:	4618      	mov	r0, r3
 8003592:	9902      	ldr	r1, [sp, #8]
 8003594:	9a01      	ldr	r2, [sp, #4]
 8003596:	9b00      	ldr	r3, [sp, #0]
 8003598:	f000 fca2 	bl	8003ee0 <chOQWriteTimeout>
 800359c:	4603      	mov	r3, r0
}
 800359e:	4618      	mov	r0, r3
 80035a0:	b005      	add	sp, #20
 80035a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80035a6:	bf00      	nop
 80035a8:	f3af 8000 	nop.w
 80035ac:	f3af 8000 	nop.w

080035b0 <readt.8199>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 80035b0:	b500      	push	{lr}
 80035b2:	b085      	sub	sp, #20
 80035b4:	9003      	str	r0, [sp, #12]
 80035b6:	9102      	str	r1, [sp, #8]
 80035b8:	9201      	str	r2, [sp, #4]
 80035ba:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80035bc:	9b03      	ldr	r3, [sp, #12]
 80035be:	330c      	adds	r3, #12
 80035c0:	4618      	mov	r0, r3
 80035c2:	9902      	ldr	r1, [sp, #8]
 80035c4:	9a01      	ldr	r2, [sp, #4]
 80035c6:	9b00      	ldr	r3, [sp, #0]
 80035c8:	f000 fb92 	bl	8003cf0 <chIQReadTimeout>
 80035cc:	4603      	mov	r3, r0
}
 80035ce:	4618      	mov	r0, r3
 80035d0:	b005      	add	sp, #20
 80035d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80035d6:	bf00      	nop
 80035d8:	f3af 8000 	nop.w
 80035dc:	f3af 8000 	nop.w

080035e0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80035e0:	b508      	push	{r3, lr}

  sd_lld_init();
 80035e2:	f7fe ff15 	bl	8002410 <sd_lld_init>
}
 80035e6:	bd08      	pop	{r3, pc}
 80035e8:	f3af 8000 	nop.w
 80035ec:	f3af 8000 	nop.w

080035f0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80035f0:	b500      	push	{lr}
 80035f2:	b087      	sub	sp, #28
 80035f4:	9005      	str	r0, [sp, #20]
 80035f6:	9104      	str	r1, [sp, #16]
 80035f8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80035fa:	9b05      	ldr	r3, [sp, #20]
 80035fc:	4a13      	ldr	r2, [pc, #76]	; (800364c <sdObjectInit+0x5c>)
 80035fe:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8003600:	9b05      	ldr	r3, [sp, #20]
 8003602:	3304      	adds	r3, #4
 8003604:	4618      	mov	r0, r3
 8003606:	f7ff ff1b 	bl	8003440 <osalEventObjectInit.8179.4421>
  sdp->state = SD_STOP;
 800360a:	9b05      	ldr	r3, [sp, #20]
 800360c:	2201      	movs	r2, #1
 800360e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8003610:	9b05      	ldr	r3, [sp, #20]
 8003612:	f103 020c 	add.w	r2, r3, #12
 8003616:	9b05      	ldr	r3, [sp, #20]
 8003618:	3354      	adds	r3, #84	; 0x54
 800361a:	9905      	ldr	r1, [sp, #20]
 800361c:	9100      	str	r1, [sp, #0]
 800361e:	4610      	mov	r0, r2
 8003620:	4619      	mov	r1, r3
 8003622:	2210      	movs	r2, #16
 8003624:	9b04      	ldr	r3, [sp, #16]
 8003626:	f000 fac3 	bl	8003bb0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 800362a:	9b05      	ldr	r3, [sp, #20]
 800362c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8003630:	9b05      	ldr	r3, [sp, #20]
 8003632:	3364      	adds	r3, #100	; 0x64
 8003634:	9905      	ldr	r1, [sp, #20]
 8003636:	9100      	str	r1, [sp, #0]
 8003638:	4610      	mov	r0, r2
 800363a:	4619      	mov	r1, r3
 800363c:	2210      	movs	r2, #16
 800363e:	9b03      	ldr	r3, [sp, #12]
 8003640:	f000 fbae 	bl	8003da0 <chOQObjectInit>
}
 8003644:	b007      	add	sp, #28
 8003646:	f85d fb04 	ldr.w	pc, [sp], #4
 800364a:	bf00      	nop
 800364c:	080068b0 	.word	0x080068b0

08003650 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8003650:	b500      	push	{lr}
 8003652:	b083      	sub	sp, #12
 8003654:	9001      	str	r0, [sp, #4]
 8003656:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8003658:	f7ff fee2 	bl	8003420 <osalSysLock.8175.4428>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800365c:	9801      	ldr	r0, [sp, #4]
 800365e:	9900      	ldr	r1, [sp, #0]
 8003660:	f7fe fef6 	bl	8002450 <sd_lld_start>
  sdp->state = SD_READY;
 8003664:	9b01      	ldr	r3, [sp, #4]
 8003666:	2202      	movs	r2, #2
 8003668:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800366a:	f7ff fee1 	bl	8003430 <osalSysUnlock.8177.4426>
}
 800366e:	b003      	add	sp, #12
 8003670:	f85d fb04 	ldr.w	pc, [sp], #4
 8003674:	f3af 8000 	nop.w
 8003678:	f3af 8000 	nop.w
 800367c:	f3af 8000 	nop.w

08003680 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8003680:	b500      	push	{lr}
 8003682:	b083      	sub	sp, #12
 8003684:	9001      	str	r0, [sp, #4]
 8003686:	460b      	mov	r3, r1
 8003688:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800368c:	9b01      	ldr	r3, [sp, #4]
 800368e:	330c      	adds	r3, #12
 8003690:	4618      	mov	r0, r3
 8003692:	f7ff feb5 	bl	8003400 <chIQIsEmptyI.8154.4433>
 8003696:	4603      	mov	r3, r0
 8003698:	2b00      	cmp	r3, #0
 800369a:	d005      	beq.n	80036a8 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800369c:	9b01      	ldr	r3, [sp, #4]
 800369e:	3304      	adds	r3, #4
 80036a0:	4618      	mov	r0, r3
 80036a2:	2104      	movs	r1, #4
 80036a4:	f7ff fedc 	bl	8003460 <osalEventBroadcastFlagsI.8223.4417>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80036a8:	9b01      	ldr	r3, [sp, #4]
 80036aa:	f103 020c 	add.w	r2, r3, #12
 80036ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80036b2:	4610      	mov	r0, r2
 80036b4:	4619      	mov	r1, r3
 80036b6:	f000 faa3 	bl	8003c00 <chIQPutI>
 80036ba:	4603      	mov	r3, r0
 80036bc:	2b00      	cmp	r3, #0
 80036be:	da05      	bge.n	80036cc <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80036c0:	9b01      	ldr	r3, [sp, #4]
 80036c2:	3304      	adds	r3, #4
 80036c4:	4618      	mov	r0, r3
 80036c6:	2180      	movs	r1, #128	; 0x80
 80036c8:	f7ff feca 	bl	8003460 <osalEventBroadcastFlagsI.8223.4417>
}
 80036cc:	b003      	add	sp, #12
 80036ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80036d2:	bf00      	nop
 80036d4:	f3af 8000 	nop.w
 80036d8:	f3af 8000 	nop.w
 80036dc:	f3af 8000 	nop.w

080036e0 <port_lock.8336.4275>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80036e0:	b082      	sub	sp, #8
 80036e2:	2320      	movs	r3, #32
 80036e4:	9301      	str	r3, [sp, #4]
 80036e6:	9b01      	ldr	r3, [sp, #4]
 80036e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80036ec:	b002      	add	sp, #8
 80036ee:	4770      	bx	lr

080036f0 <port_unlock.8339.4273>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80036f0:	b082      	sub	sp, #8
 80036f2:	2300      	movs	r3, #0
 80036f4:	9301      	str	r3, [sp, #4]
 80036f6:	9b01      	ldr	r3, [sp, #4]
 80036f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80036fc:	b002      	add	sp, #8
 80036fe:	4770      	bx	lr

08003700 <chSysLock.8341.4271>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003700:	b508      	push	{r3, lr}

  port_lock();
 8003702:	f7ff ffed 	bl	80036e0 <port_lock.8336.4275>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003706:	bd08      	pop	{r3, pc}
 8003708:	f3af 8000 	nop.w
 800370c:	f3af 8000 	nop.w

08003710 <chSysUnlock.8343.4269>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003710:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003712:	f7ff ffed 	bl	80036f0 <port_unlock.8339.4273>
}
 8003716:	bd08      	pop	{r3, pc}
 8003718:	f3af 8000 	nop.w
 800371c:	f3af 8000 	nop.w

08003720 <osalSysLock.8345.4267>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003720:	b508      	push	{r3, lr}

  chSysLock();
 8003722:	f7ff ffed 	bl	8003700 <chSysLock.8341.4271>
}
 8003726:	bd08      	pop	{r3, pc}
 8003728:	f3af 8000 	nop.w
 800372c:	f3af 8000 	nop.w

08003730 <osalSysUnlock.8347.4265>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003730:	b508      	push	{r3, lr}

  chSysUnlock();
 8003732:	f7ff ffed 	bl	8003710 <chSysUnlock.8343.4269>
}
 8003736:	bd08      	pop	{r3, pc}
 8003738:	f3af 8000 	nop.w
 800373c:	f3af 8000 	nop.w

08003740 <osalThreadSuspendS.8427.4262>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8003740:	b500      	push	{lr}
 8003742:	b083      	sub	sp, #12
 8003744:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8003746:	9801      	ldr	r0, [sp, #4]
 8003748:	f002 f982 	bl	8005a50 <chThdSuspendS>
 800374c:	4603      	mov	r3, r0
}
 800374e:	4618      	mov	r0, r3
 8003750:	b003      	add	sp, #12
 8003752:	f85d fb04 	ldr.w	pc, [sp], #4
 8003756:	bf00      	nop
 8003758:	f3af 8000 	nop.w
 800375c:	f3af 8000 	nop.w

08003760 <osalMutexObjectInit.8349.4259>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8003760:	b500      	push	{lr}
 8003762:	b083      	sub	sp, #12
 8003764:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8003766:	9801      	ldr	r0, [sp, #4]
 8003768:	f001 f812 	bl	8004790 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800376c:	b003      	add	sp, #12
 800376e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003772:	bf00      	nop
 8003774:	f3af 8000 	nop.w
 8003778:	f3af 8000 	nop.w
 800377c:	f3af 8000 	nop.w

08003780 <osalMutexLock.8430.4256>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8003780:	b500      	push	{lr}
 8003782:	b083      	sub	sp, #12
 8003784:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8003786:	9801      	ldr	r0, [sp, #4]
 8003788:	f001 f812 	bl	80047b0 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800378c:	b003      	add	sp, #12
 800378e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003792:	bf00      	nop
 8003794:	f3af 8000 	nop.w
 8003798:	f3af 8000 	nop.w
 800379c:	f3af 8000 	nop.w

080037a0 <osalMutexUnlock.8433.4253>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 80037a0:	b500      	push	{lr}
 80037a2:	b083      	sub	sp, #12
 80037a4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80037a6:	9801      	ldr	r0, [sp, #4]
 80037a8:	f001 f872 	bl	8004890 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 80037ac:	b003      	add	sp, #12
 80037ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80037b2:	bf00      	nop
 80037b4:	f3af 8000 	nop.w
 80037b8:	f3af 8000 	nop.w
 80037bc:	f3af 8000 	nop.w

080037c0 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 80037c0:	b508      	push	{r3, lr}

  spi_lld_init();
 80037c2:	f7fe fadd 	bl	8001d80 <spi_lld_init>
}
 80037c6:	bd08      	pop	{r3, pc}
 80037c8:	f3af 8000 	nop.w
 80037cc:	f3af 8000 	nop.w

080037d0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 80037d0:	b500      	push	{lr}
 80037d2:	b083      	sub	sp, #12
 80037d4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 80037d6:	9b01      	ldr	r3, [sp, #4]
 80037d8:	2201      	movs	r2, #1
 80037da:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 80037dc:	9b01      	ldr	r3, [sp, #4]
 80037de:	2200      	movs	r2, #0
 80037e0:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80037e2:	9b01      	ldr	r3, [sp, #4]
 80037e4:	2200      	movs	r2, #0
 80037e6:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	330c      	adds	r3, #12
 80037ec:	4618      	mov	r0, r3
 80037ee:	f7ff ffb7 	bl	8003760 <osalMutexObjectInit.8349.4259>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 80037f2:	b003      	add	sp, #12
 80037f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80037f8:	f3af 8000 	nop.w
 80037fc:	f3af 8000 	nop.w

08003800 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8003800:	b500      	push	{lr}
 8003802:	b083      	sub	sp, #12
 8003804:	9001      	str	r0, [sp, #4]
 8003806:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 8003808:	f7ff ff8a 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800380c:	9b01      	ldr	r3, [sp, #4]
 800380e:	9a00      	ldr	r2, [sp, #0]
 8003810:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 8003812:	9801      	ldr	r0, [sp, #4]
 8003814:	f7fe faf4 	bl	8001e00 <spi_lld_start>
  spip->state = SPI_READY;
 8003818:	9b01      	ldr	r3, [sp, #4]
 800381a:	2202      	movs	r2, #2
 800381c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800381e:	f7ff ff87 	bl	8003730 <osalSysUnlock.8347.4265>
}
 8003822:	b003      	add	sp, #12
 8003824:	f85d fb04 	ldr.w	pc, [sp], #4
 8003828:	f3af 8000 	nop.w
 800382c:	f3af 8000 	nop.w

08003830 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 8003830:	b500      	push	{lr}
 8003832:	b083      	sub	sp, #12
 8003834:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8003836:	f7ff ff73 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 800383a:	9801      	ldr	r0, [sp, #4]
 800383c:	f7fe fb98 	bl	8001f70 <spi_lld_select>
  osalSysUnlock();
 8003840:	f7ff ff76 	bl	8003730 <osalSysUnlock.8347.4265>
}
 8003844:	b003      	add	sp, #12
 8003846:	f85d fb04 	ldr.w	pc, [sp], #4
 800384a:	bf00      	nop
 800384c:	f3af 8000 	nop.w

08003850 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8003850:	b500      	push	{lr}
 8003852:	b083      	sub	sp, #12
 8003854:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8003856:	f7ff ff63 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800385a:	9801      	ldr	r0, [sp, #4]
 800385c:	f7fe fb98 	bl	8001f90 <spi_lld_unselect>
  osalSysUnlock();
 8003860:	f7ff ff66 	bl	8003730 <osalSysUnlock.8347.4265>
}
 8003864:	b003      	add	sp, #12
 8003866:	f85d fb04 	ldr.w	pc, [sp], #4
 800386a:	bf00      	nop
 800386c:	f3af 8000 	nop.w

08003870 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8003870:	b500      	push	{lr}
 8003872:	b085      	sub	sp, #20
 8003874:	9003      	str	r0, [sp, #12]
 8003876:	9102      	str	r1, [sp, #8]
 8003878:	9201      	str	r2, [sp, #4]
 800387a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800387c:	f7ff ff50 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8003880:	9b03      	ldr	r3, [sp, #12]
 8003882:	2203      	movs	r2, #3
 8003884:	701a      	strb	r2, [r3, #0]
 8003886:	9803      	ldr	r0, [sp, #12]
 8003888:	9902      	ldr	r1, [sp, #8]
 800388a:	9a01      	ldr	r2, [sp, #4]
 800388c:	9b00      	ldr	r3, [sp, #0]
 800388e:	f7fe fb8f 	bl	8001fb0 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8003892:	9b03      	ldr	r3, [sp, #12]
 8003894:	3308      	adds	r3, #8
 8003896:	4618      	mov	r0, r3
 8003898:	f7ff ff52 	bl	8003740 <osalThreadSuspendS.8427.4262>
  osalSysUnlock();
 800389c:	f7ff ff48 	bl	8003730 <osalSysUnlock.8347.4265>
}
 80038a0:	b005      	add	sp, #20
 80038a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80038a6:	bf00      	nop
 80038a8:	f3af 8000 	nop.w
 80038ac:	f3af 8000 	nop.w

080038b0 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80038b0:	b500      	push	{lr}
 80038b2:	b085      	sub	sp, #20
 80038b4:	9003      	str	r0, [sp, #12]
 80038b6:	9102      	str	r1, [sp, #8]
 80038b8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 80038ba:	f7ff ff31 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 80038be:	9b03      	ldr	r3, [sp, #12]
 80038c0:	2203      	movs	r2, #3
 80038c2:	701a      	strb	r2, [r3, #0]
 80038c4:	9803      	ldr	r0, [sp, #12]
 80038c6:	9902      	ldr	r1, [sp, #8]
 80038c8:	9a01      	ldr	r2, [sp, #4]
 80038ca:	f7fe fbb1 	bl	8002030 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 80038ce:	9b03      	ldr	r3, [sp, #12]
 80038d0:	3308      	adds	r3, #8
 80038d2:	4618      	mov	r0, r3
 80038d4:	f7ff ff34 	bl	8003740 <osalThreadSuspendS.8427.4262>
  osalSysUnlock();
 80038d8:	f7ff ff2a 	bl	8003730 <osalSysUnlock.8347.4265>
}
 80038dc:	b005      	add	sp, #20
 80038de:	f85d fb04 	ldr.w	pc, [sp], #4
 80038e2:	bf00      	nop
 80038e4:	f3af 8000 	nop.w
 80038e8:	f3af 8000 	nop.w
 80038ec:	f3af 8000 	nop.w

080038f0 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 80038f0:	b500      	push	{lr}
 80038f2:	b085      	sub	sp, #20
 80038f4:	9003      	str	r0, [sp, #12]
 80038f6:	9102      	str	r1, [sp, #8]
 80038f8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 80038fa:	f7ff ff11 	bl	8003720 <osalSysLock.8345.4267>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 80038fe:	9b03      	ldr	r3, [sp, #12]
 8003900:	2203      	movs	r2, #3
 8003902:	701a      	strb	r2, [r3, #0]
 8003904:	9803      	ldr	r0, [sp, #12]
 8003906:	9902      	ldr	r1, [sp, #8]
 8003908:	9a01      	ldr	r2, [sp, #4]
 800390a:	f7fe fbd1 	bl	80020b0 <spi_lld_receive>
  (void) osalThreadSuspendS(&spip->thread);
 800390e:	9b03      	ldr	r3, [sp, #12]
 8003910:	3308      	adds	r3, #8
 8003912:	4618      	mov	r0, r3
 8003914:	f7ff ff14 	bl	8003740 <osalThreadSuspendS.8427.4262>
  osalSysUnlock();
 8003918:	f7ff ff0a 	bl	8003730 <osalSysUnlock.8347.4265>
}
 800391c:	b005      	add	sp, #20
 800391e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003922:	bf00      	nop
 8003924:	f3af 8000 	nop.w
 8003928:	f3af 8000 	nop.w
 800392c:	f3af 8000 	nop.w

08003930 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 8003930:	b500      	push	{lr}
 8003932:	b083      	sub	sp, #12
 8003934:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexLock(&spip->mutex);
 8003936:	9b01      	ldr	r3, [sp, #4]
 8003938:	330c      	adds	r3, #12
 800393a:	4618      	mov	r0, r3
 800393c:	f7ff ff20 	bl	8003780 <osalMutexLock.8430.4256>
}
 8003940:	b003      	add	sp, #12
 8003942:	f85d fb04 	ldr.w	pc, [sp], #4
 8003946:	bf00      	nop
 8003948:	f3af 8000 	nop.w
 800394c:	f3af 8000 	nop.w

08003950 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 8003950:	b500      	push	{lr}
 8003952:	b083      	sub	sp, #12
 8003954:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexUnlock(&spip->mutex);
 8003956:	9b01      	ldr	r3, [sp, #4]
 8003958:	330c      	adds	r3, #12
 800395a:	4618      	mov	r0, r3
 800395c:	f7ff ff20 	bl	80037a0 <osalMutexUnlock.8433.4253>
}
 8003960:	b003      	add	sp, #12
 8003962:	f85d fb04 	ldr.w	pc, [sp], #4
 8003966:	bf00      	nop
 8003968:	f3af 8000 	nop.w
 800396c:	f3af 8000 	nop.w

08003970 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8003970:	b082      	sub	sp, #8
 8003972:	9001      	str	r0, [sp, #4]
 8003974:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003976:	4911      	ldr	r1, [pc, #68]	; (80039bc <nvicEnableVector+0x4c>)
 8003978:	9b00      	ldr	r3, [sp, #0]
 800397a:	b2db      	uxtb	r3, r3
 800397c:	011b      	lsls	r3, r3, #4
 800397e:	b2da      	uxtb	r2, r3
 8003980:	9b01      	ldr	r3, [sp, #4]
 8003982:	440b      	add	r3, r1
 8003984:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8003988:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800398a:	4b0c      	ldr	r3, [pc, #48]	; (80039bc <nvicEnableVector+0x4c>)
 800398c:	9a01      	ldr	r2, [sp, #4]
 800398e:	0952      	lsrs	r2, r2, #5
 8003990:	9901      	ldr	r1, [sp, #4]
 8003992:	f001 011f 	and.w	r1, r1, #31
 8003996:	2001      	movs	r0, #1
 8003998:	fa00 f101 	lsl.w	r1, r0, r1
 800399c:	3260      	adds	r2, #96	; 0x60
 800399e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80039a2:	4b06      	ldr	r3, [pc, #24]	; (80039bc <nvicEnableVector+0x4c>)
 80039a4:	9a01      	ldr	r2, [sp, #4]
 80039a6:	0952      	lsrs	r2, r2, #5
 80039a8:	9901      	ldr	r1, [sp, #4]
 80039aa:	f001 011f 	and.w	r1, r1, #31
 80039ae:	2001      	movs	r0, #1
 80039b0:	fa00 f101 	lsl.w	r1, r0, r1
 80039b4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80039b8:	b002      	add	sp, #8
 80039ba:	4770      	bx	lr
 80039bc:	e000e100 	.word	0xe000e100

080039c0 <hal_lld_backup_domain_init.8666.4016>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80039c0:	4b13      	ldr	r3, [pc, #76]	; (8003a10 <hal_lld_backup_domain_init.8666.4016+0x50>)
 80039c2:	4a13      	ldr	r2, [pc, #76]	; (8003a10 <hal_lld_backup_domain_init.8666.4016+0x50>)
 80039c4:	6812      	ldr	r2, [r2, #0]
 80039c6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80039ca:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80039cc:	4b11      	ldr	r3, [pc, #68]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039ce:	6a1b      	ldr	r3, [r3, #32]
 80039d0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80039d4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80039d8:	d006      	beq.n	80039e8 <hal_lld_backup_domain_init.8666.4016+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80039da:	4b0e      	ldr	r3, [pc, #56]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039dc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80039e0:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 80039e2:	4b0c      	ldr	r3, [pc, #48]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039e4:	2200      	movs	r2, #0
 80039e6:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80039e8:	4b0a      	ldr	r3, [pc, #40]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039ea:	6a1b      	ldr	r3, [r3, #32]
 80039ec:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80039f0:	2b00      	cmp	r3, #0
 80039f2:	d10b      	bne.n	8003a0c <hal_lld_backup_domain_init.8666.4016+0x4c>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80039f4:	4b07      	ldr	r3, [pc, #28]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039f6:	4a07      	ldr	r2, [pc, #28]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 80039f8:	6a12      	ldr	r2, [r2, #32]
 80039fa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80039fe:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8003a00:	4b04      	ldr	r3, [pc, #16]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 8003a02:	4a04      	ldr	r2, [pc, #16]	; (8003a14 <hal_lld_backup_domain_init.8666.4016+0x54>)
 8003a04:	6a12      	ldr	r2, [r2, #32]
 8003a06:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003a0a:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop
 8003a10:	40007000 	.word	0x40007000
 8003a14:	40021000 	.word	0x40021000
 8003a18:	f3af 8000 	nop.w
 8003a1c:	f3af 8000 	nop.w

08003a20 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8003a20:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8003a22:	4b19      	ldr	r3, [pc, #100]	; (8003a88 <hal_lld_init+0x68>)
 8003a24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003a26:	4b18      	ldr	r3, [pc, #96]	; (8003a88 <hal_lld_init+0x68>)
 8003a28:	f04f 32ff 	mov.w	r2, #4294967295
 8003a2c:	629a      	str	r2, [r3, #40]	; 0x28
 8003a2e:	4b16      	ldr	r3, [pc, #88]	; (8003a88 <hal_lld_init+0x68>)
 8003a30:	2200      	movs	r2, #0
 8003a32:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8003a34:	4b14      	ldr	r3, [pc, #80]	; (8003a88 <hal_lld_init+0x68>)
 8003a36:	691b      	ldr	r3, [r3, #16]
 8003a38:	4b13      	ldr	r3, [pc, #76]	; (8003a88 <hal_lld_init+0x68>)
 8003a3a:	f04f 32ff 	mov.w	r2, #4294967295
 8003a3e:	611a      	str	r2, [r3, #16]
 8003a40:	4b11      	ldr	r3, [pc, #68]	; (8003a88 <hal_lld_init+0x68>)
 8003a42:	2200      	movs	r2, #0
 8003a44:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8003a46:	4b10      	ldr	r3, [pc, #64]	; (8003a88 <hal_lld_init+0x68>)
 8003a48:	68db      	ldr	r3, [r3, #12]
 8003a4a:	4b0f      	ldr	r3, [pc, #60]	; (8003a88 <hal_lld_init+0x68>)
 8003a4c:	f04f 32ff 	mov.w	r2, #4294967295
 8003a50:	60da      	str	r2, [r3, #12]
 8003a52:	4b0d      	ldr	r3, [pc, #52]	; (8003a88 <hal_lld_init+0x68>)
 8003a54:	2200      	movs	r2, #0
 8003a56:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8003a58:	4b0b      	ldr	r3, [pc, #44]	; (8003a88 <hal_lld_init+0x68>)
 8003a5a:	4a0b      	ldr	r2, [pc, #44]	; (8003a88 <hal_lld_init+0x68>)
 8003a5c:	69d2      	ldr	r2, [r2, #28]
 8003a5e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003a62:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8003a64:	f7ff ffac 	bl	80039c0 <hal_lld_backup_domain_init.8666.4016>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8003a68:	f7ff f83a 	bl	8002ae0 <dmaInit>
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8003a6c:	4b06      	ldr	r3, [pc, #24]	; (8003a88 <hal_lld_init+0x68>)
 8003a6e:	4a06      	ldr	r2, [pc, #24]	; (8003a88 <hal_lld_init+0x68>)
 8003a70:	6992      	ldr	r2, [r2, #24]
 8003a72:	f042 0201 	orr.w	r2, r2, #1
 8003a76:	619a      	str	r2, [r3, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8003a78:	4b04      	ldr	r3, [pc, #16]	; (8003a8c <hal_lld_init+0x6c>)
 8003a7a:	4a04      	ldr	r2, [pc, #16]	; (8003a8c <hal_lld_init+0x6c>)
 8003a7c:	6812      	ldr	r2, [r2, #0]
 8003a7e:	f042 0220 	orr.w	r2, r2, #32
 8003a82:	601a      	str	r2, [r3, #0]
#endif
}
 8003a84:	bd08      	pop	{r3, pc}
 8003a86:	bf00      	nop
 8003a88:	40021000 	.word	0x40021000
 8003a8c:	40010000 	.word	0x40010000

08003a90 <port_lock.6884.4413>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003a90:	b082      	sub	sp, #8
 8003a92:	2320      	movs	r3, #32
 8003a94:	9301      	str	r3, [sp, #4]
 8003a96:	9b01      	ldr	r3, [sp, #4]
 8003a98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003a9c:	b002      	add	sp, #8
 8003a9e:	4770      	bx	lr

08003aa0 <port_unlock.6887.4411>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003aa0:	b082      	sub	sp, #8
 8003aa2:	2300      	movs	r3, #0
 8003aa4:	9301      	str	r3, [sp, #4]
 8003aa6:	9b01      	ldr	r3, [sp, #4]
 8003aa8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003aac:	b002      	add	sp, #8
 8003aae:	4770      	bx	lr

08003ab0 <queue_init.6889.4408>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003ab0:	b082      	sub	sp, #8
 8003ab2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8003ab4:	9b01      	ldr	r3, [sp, #4]
 8003ab6:	9a01      	ldr	r2, [sp, #4]
 8003ab8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003aba:	9b01      	ldr	r3, [sp, #4]
 8003abc:	9a01      	ldr	r2, [sp, #4]
 8003abe:	605a      	str	r2, [r3, #4]
}
 8003ac0:	b002      	add	sp, #8
 8003ac2:	4770      	bx	lr
 8003ac4:	f3af 8000 	nop.w
 8003ac8:	f3af 8000 	nop.w
 8003acc:	f3af 8000 	nop.w

08003ad0 <chSysLock.6967.4406>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003ad0:	b508      	push	{r3, lr}

  port_lock();
 8003ad2:	f7ff ffdd 	bl	8003a90 <port_lock.6884.4413>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003ad6:	bd08      	pop	{r3, pc}
 8003ad8:	f3af 8000 	nop.w
 8003adc:	f3af 8000 	nop.w

08003ae0 <chSysUnlock.6969.4404>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003ae0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003ae2:	f7ff ffdd 	bl	8003aa0 <port_unlock.6887.4411>
}
 8003ae6:	bd08      	pop	{r3, pc}
 8003ae8:	f3af 8000 	nop.w
 8003aec:	f3af 8000 	nop.w

08003af0 <chThdQueueObjectInit.6971.4401>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003af0:	b500      	push	{lr}
 8003af2:	b083      	sub	sp, #12
 8003af4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003af6:	9801      	ldr	r0, [sp, #4]
 8003af8:	f7ff ffda 	bl	8003ab0 <queue_init.6889.4408>
}
 8003afc:	b003      	add	sp, #12
 8003afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b02:	bf00      	nop
 8003b04:	f3af 8000 	nop.w
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <chIQIsEmptyI.6974.4398>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003b10:	b082      	sub	sp, #8
 8003b12:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003b14:	9b01      	ldr	r3, [sp, #4]
 8003b16:	689b      	ldr	r3, [r3, #8]
 8003b18:	2b00      	cmp	r3, #0
 8003b1a:	bf14      	ite	ne
 8003b1c:	2300      	movne	r3, #0
 8003b1e:	2301      	moveq	r3, #1
 8003b20:	b2db      	uxtb	r3, r3
}
 8003b22:	4618      	mov	r0, r3
 8003b24:	b002      	add	sp, #8
 8003b26:	4770      	bx	lr
 8003b28:	f3af 8000 	nop.w
 8003b2c:	f3af 8000 	nop.w

08003b30 <chIQIsFullI.6991.4395>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003b30:	b082      	sub	sp, #8
 8003b32:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	695a      	ldr	r2, [r3, #20]
 8003b38:	9b01      	ldr	r3, [sp, #4]
 8003b3a:	699b      	ldr	r3, [r3, #24]
 8003b3c:	429a      	cmp	r2, r3
 8003b3e:	d105      	bne.n	8003b4c <chIQIsFullI.6991.4395+0x1c>
 8003b40:	9b01      	ldr	r3, [sp, #4]
 8003b42:	689b      	ldr	r3, [r3, #8]
 8003b44:	2b00      	cmp	r3, #0
 8003b46:	d001      	beq.n	8003b4c <chIQIsFullI.6991.4395+0x1c>
 8003b48:	2301      	movs	r3, #1
 8003b4a:	e000      	b.n	8003b4e <chIQIsFullI.6991.4395+0x1e>
 8003b4c:	2300      	movs	r3, #0
 8003b4e:	f003 0301 	and.w	r3, r3, #1
 8003b52:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003b54:	4618      	mov	r0, r3
 8003b56:	b002      	add	sp, #8
 8003b58:	4770      	bx	lr
 8003b5a:	bf00      	nop
 8003b5c:	f3af 8000 	nop.w

08003b60 <chOQIsEmptyI.6994.4392>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8003b60:	b082      	sub	sp, #8
 8003b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003b64:	9b01      	ldr	r3, [sp, #4]
 8003b66:	695a      	ldr	r2, [r3, #20]
 8003b68:	9b01      	ldr	r3, [sp, #4]
 8003b6a:	699b      	ldr	r3, [r3, #24]
 8003b6c:	429a      	cmp	r2, r3
 8003b6e:	d105      	bne.n	8003b7c <chOQIsEmptyI.6994.4392+0x1c>
 8003b70:	9b01      	ldr	r3, [sp, #4]
 8003b72:	689b      	ldr	r3, [r3, #8]
 8003b74:	2b00      	cmp	r3, #0
 8003b76:	d001      	beq.n	8003b7c <chOQIsEmptyI.6994.4392+0x1c>
 8003b78:	2301      	movs	r3, #1
 8003b7a:	e000      	b.n	8003b7e <chOQIsEmptyI.6994.4392+0x1e>
 8003b7c:	2300      	movs	r3, #0
 8003b7e:	f003 0301 	and.w	r3, r3, #1
 8003b82:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003b84:	4618      	mov	r0, r3
 8003b86:	b002      	add	sp, #8
 8003b88:	4770      	bx	lr
 8003b8a:	bf00      	nop
 8003b8c:	f3af 8000 	nop.w

08003b90 <chOQIsFullI.6998.4388>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003b90:	b082      	sub	sp, #8
 8003b92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003b94:	9b01      	ldr	r3, [sp, #4]
 8003b96:	689b      	ldr	r3, [r3, #8]
 8003b98:	2b00      	cmp	r3, #0
 8003b9a:	bf14      	ite	ne
 8003b9c:	2300      	movne	r3, #0
 8003b9e:	2301      	moveq	r3, #1
 8003ba0:	b2db      	uxtb	r3, r3
}
 8003ba2:	4618      	mov	r0, r3
 8003ba4:	b002      	add	sp, #8
 8003ba6:	4770      	bx	lr
 8003ba8:	f3af 8000 	nop.w
 8003bac:	f3af 8000 	nop.w

08003bb0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8003bb0:	b500      	push	{lr}
 8003bb2:	b085      	sub	sp, #20
 8003bb4:	9003      	str	r0, [sp, #12]
 8003bb6:	9102      	str	r1, [sp, #8]
 8003bb8:	9201      	str	r2, [sp, #4]
 8003bba:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 8003bbc:	9b03      	ldr	r3, [sp, #12]
 8003bbe:	4618      	mov	r0, r3
 8003bc0:	f7ff ff96 	bl	8003af0 <chThdQueueObjectInit.6971.4401>
  iqp->q_counter = 0;
 8003bc4:	9b03      	ldr	r3, [sp, #12]
 8003bc6:	2200      	movs	r2, #0
 8003bc8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8003bca:	9b03      	ldr	r3, [sp, #12]
 8003bcc:	9a02      	ldr	r2, [sp, #8]
 8003bce:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8003bd0:	9b03      	ldr	r3, [sp, #12]
 8003bd2:	9a02      	ldr	r2, [sp, #8]
 8003bd4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8003bd6:	9b03      	ldr	r3, [sp, #12]
 8003bd8:	9a02      	ldr	r2, [sp, #8]
 8003bda:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8003bdc:	9a02      	ldr	r2, [sp, #8]
 8003bde:	9b01      	ldr	r3, [sp, #4]
 8003be0:	441a      	add	r2, r3
 8003be2:	9b03      	ldr	r3, [sp, #12]
 8003be4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8003be6:	9b03      	ldr	r3, [sp, #12]
 8003be8:	9a00      	ldr	r2, [sp, #0]
 8003bea:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8003bec:	9b03      	ldr	r3, [sp, #12]
 8003bee:	9a06      	ldr	r2, [sp, #24]
 8003bf0:	621a      	str	r2, [r3, #32]
}
 8003bf2:	b005      	add	sp, #20
 8003bf4:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bf8:	f3af 8000 	nop.w
 8003bfc:	f3af 8000 	nop.w

08003c00 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003c00:	b500      	push	{lr}
 8003c02:	b083      	sub	sp, #12
 8003c04:	9001      	str	r0, [sp, #4]
 8003c06:	460b      	mov	r3, r1
 8003c08:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 8003c0c:	9801      	ldr	r0, [sp, #4]
 8003c0e:	f7ff ff8f 	bl	8003b30 <chIQIsFullI.6991.4395>
 8003c12:	4603      	mov	r3, r0
 8003c14:	2b00      	cmp	r3, #0
 8003c16:	d002      	beq.n	8003c1e <chIQPutI+0x1e>
    return Q_FULL;
 8003c18:	f06f 0303 	mvn.w	r3, #3
 8003c1c:	e01c      	b.n	8003c58 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 8003c1e:	9b01      	ldr	r3, [sp, #4]
 8003c20:	689b      	ldr	r3, [r3, #8]
 8003c22:	1c5a      	adds	r2, r3, #1
 8003c24:	9b01      	ldr	r3, [sp, #4]
 8003c26:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003c28:	9b01      	ldr	r3, [sp, #4]
 8003c2a:	695b      	ldr	r3, [r3, #20]
 8003c2c:	1c59      	adds	r1, r3, #1
 8003c2e:	9a01      	ldr	r2, [sp, #4]
 8003c30:	6151      	str	r1, [r2, #20]
 8003c32:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003c36:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003c38:	9b01      	ldr	r3, [sp, #4]
 8003c3a:	695a      	ldr	r2, [r3, #20]
 8003c3c:	9b01      	ldr	r3, [sp, #4]
 8003c3e:	691b      	ldr	r3, [r3, #16]
 8003c40:	429a      	cmp	r2, r3
 8003c42:	d303      	bcc.n	8003c4c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8003c44:	9b01      	ldr	r3, [sp, #4]
 8003c46:	68da      	ldr	r2, [r3, #12]
 8003c48:	9b01      	ldr	r3, [sp, #4]
 8003c4a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8003c4c:	9b01      	ldr	r3, [sp, #4]
 8003c4e:	4618      	mov	r0, r3
 8003c50:	2100      	movs	r1, #0
 8003c52:	f001 ff4d 	bl	8005af0 <chThdDequeueNextI>

  return Q_OK;
 8003c56:	2300      	movs	r3, #0
}
 8003c58:	4618      	mov	r0, r3
 8003c5a:	b003      	add	sp, #12
 8003c5c:	f85d fb04 	ldr.w	pc, [sp], #4

08003c60 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003c60:	b500      	push	{lr}
 8003c62:	b085      	sub	sp, #20
 8003c64:	9001      	str	r0, [sp, #4]
 8003c66:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8003c68:	f7ff ff32 	bl	8003ad0 <chSysLock.6967.4406>
  if (iqp->q_notify != NULL) {
 8003c6c:	9b01      	ldr	r3, [sp, #4]
 8003c6e:	69db      	ldr	r3, [r3, #28]
 8003c70:	2b00      	cmp	r3, #0
 8003c72:	d011      	beq.n	8003c98 <chIQGetTimeout+0x38>
    iqp->q_notify(iqp);
 8003c74:	9b01      	ldr	r3, [sp, #4]
 8003c76:	69db      	ldr	r3, [r3, #28]
 8003c78:	9801      	ldr	r0, [sp, #4]
 8003c7a:	4798      	blx	r3
 8003c7c:	e00c      	b.n	8003c98 <chIQGetTimeout+0x38>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8003c7e:	9b01      	ldr	r3, [sp, #4]
 8003c80:	4618      	mov	r0, r3
 8003c82:	9900      	ldr	r1, [sp, #0]
 8003c84:	f001 ff14 	bl	8005ab0 <chThdEnqueueTimeoutS>
 8003c88:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 8003c8a:	9b03      	ldr	r3, [sp, #12]
 8003c8c:	2b00      	cmp	r3, #0
 8003c8e:	da03      	bge.n	8003c98 <chIQGetTimeout+0x38>
      chSysUnlock();
 8003c90:	f7ff ff26 	bl	8003ae0 <chSysUnlock.6969.4404>
      return msg;
 8003c94:	9b03      	ldr	r3, [sp, #12]
 8003c96:	e020      	b.n	8003cda <chIQGetTimeout+0x7a>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8003c98:	9801      	ldr	r0, [sp, #4]
 8003c9a:	f7ff ff39 	bl	8003b10 <chIQIsEmptyI.6974.4398>
 8003c9e:	4603      	mov	r3, r0
 8003ca0:	2b00      	cmp	r3, #0
 8003ca2:	d1ec      	bne.n	8003c7e <chIQGetTimeout+0x1e>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8003ca4:	9b01      	ldr	r3, [sp, #4]
 8003ca6:	689b      	ldr	r3, [r3, #8]
 8003ca8:	1e5a      	subs	r2, r3, #1
 8003caa:	9b01      	ldr	r3, [sp, #4]
 8003cac:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8003cae:	9b01      	ldr	r3, [sp, #4]
 8003cb0:	699b      	ldr	r3, [r3, #24]
 8003cb2:	1c59      	adds	r1, r3, #1
 8003cb4:	9a01      	ldr	r2, [sp, #4]
 8003cb6:	6191      	str	r1, [r2, #24]
 8003cb8:	781b      	ldrb	r3, [r3, #0]
 8003cba:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 8003cbe:	9b01      	ldr	r3, [sp, #4]
 8003cc0:	699a      	ldr	r2, [r3, #24]
 8003cc2:	9b01      	ldr	r3, [sp, #4]
 8003cc4:	691b      	ldr	r3, [r3, #16]
 8003cc6:	429a      	cmp	r2, r3
 8003cc8:	d303      	bcc.n	8003cd2 <chIQGetTimeout+0x72>
    iqp->q_rdptr = iqp->q_buffer;
 8003cca:	9b01      	ldr	r3, [sp, #4]
 8003ccc:	68da      	ldr	r2, [r3, #12]
 8003cce:	9b01      	ldr	r3, [sp, #4]
 8003cd0:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 8003cd2:	f7ff ff05 	bl	8003ae0 <chSysUnlock.6969.4404>

  return (msg_t)b;
 8003cd6:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8003cda:	4618      	mov	r0, r3
 8003cdc:	b005      	add	sp, #20
 8003cde:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ce2:	bf00      	nop
 8003ce4:	f3af 8000 	nop.w
 8003ce8:	f3af 8000 	nop.w
 8003cec:	f3af 8000 	nop.w

08003cf0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003cf0:	b500      	push	{lr}
 8003cf2:	b087      	sub	sp, #28
 8003cf4:	9003      	str	r0, [sp, #12]
 8003cf6:	9102      	str	r1, [sp, #8]
 8003cf8:	9201      	str	r2, [sp, #4]
 8003cfa:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 8003cfc:	9b03      	ldr	r3, [sp, #12]
 8003cfe:	69db      	ldr	r3, [r3, #28]
 8003d00:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003d02:	2300      	movs	r3, #0
 8003d04:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003d06:	f7ff fee3 	bl	8003ad0 <chSysLock.6967.4406>
  while (true) {
    if (nfy != NULL) {
 8003d0a:	9b04      	ldr	r3, [sp, #16]
 8003d0c:	2b00      	cmp	r3, #0
 8003d0e:	d00f      	beq.n	8003d30 <chIQReadTimeout+0x40>
      nfy(iqp);
 8003d10:	9b04      	ldr	r3, [sp, #16]
 8003d12:	9803      	ldr	r0, [sp, #12]
 8003d14:	4798      	blx	r3
 8003d16:	e00b      	b.n	8003d30 <chIQReadTimeout+0x40>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8003d18:	9b03      	ldr	r3, [sp, #12]
 8003d1a:	4618      	mov	r0, r3
 8003d1c:	9900      	ldr	r1, [sp, #0]
 8003d1e:	f001 fec7 	bl	8005ab0 <chThdEnqueueTimeoutS>
 8003d22:	4603      	mov	r3, r0
 8003d24:	2b00      	cmp	r3, #0
 8003d26:	d003      	beq.n	8003d30 <chIQReadTimeout+0x40>
        chSysUnlock();
 8003d28:	f7ff feda 	bl	8003ae0 <chSysUnlock.6969.4404>
        return r;
 8003d2c:	9b05      	ldr	r3, [sp, #20]
 8003d2e:	e02e      	b.n	8003d8e <chIQReadTimeout+0x9e>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003d30:	9803      	ldr	r0, [sp, #12]
 8003d32:	f7ff feed 	bl	8003b10 <chIQIsEmptyI.6974.4398>
 8003d36:	4603      	mov	r3, r0
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d1ed      	bne.n	8003d18 <chIQReadTimeout+0x28>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8003d3c:	9b03      	ldr	r3, [sp, #12]
 8003d3e:	689b      	ldr	r3, [r3, #8]
 8003d40:	1e5a      	subs	r2, r3, #1
 8003d42:	9b03      	ldr	r3, [sp, #12]
 8003d44:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003d46:	9b02      	ldr	r3, [sp, #8]
 8003d48:	1c5a      	adds	r2, r3, #1
 8003d4a:	9202      	str	r2, [sp, #8]
 8003d4c:	9a03      	ldr	r2, [sp, #12]
 8003d4e:	6992      	ldr	r2, [r2, #24]
 8003d50:	1c50      	adds	r0, r2, #1
 8003d52:	9903      	ldr	r1, [sp, #12]
 8003d54:	6188      	str	r0, [r1, #24]
 8003d56:	7812      	ldrb	r2, [r2, #0]
 8003d58:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8003d5a:	9b03      	ldr	r3, [sp, #12]
 8003d5c:	699a      	ldr	r2, [r3, #24]
 8003d5e:	9b03      	ldr	r3, [sp, #12]
 8003d60:	691b      	ldr	r3, [r3, #16]
 8003d62:	429a      	cmp	r2, r3
 8003d64:	d303      	bcc.n	8003d6e <chIQReadTimeout+0x7e>
      iqp->q_rdptr = iqp->q_buffer;
 8003d66:	9b03      	ldr	r3, [sp, #12]
 8003d68:	68da      	ldr	r2, [r3, #12]
 8003d6a:	9b03      	ldr	r3, [sp, #12]
 8003d6c:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003d6e:	f7ff feb7 	bl	8003ae0 <chSysUnlock.6969.4404>

    r++;
 8003d72:	9b05      	ldr	r3, [sp, #20]
 8003d74:	3301      	adds	r3, #1
 8003d76:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8003d78:	9b01      	ldr	r3, [sp, #4]
 8003d7a:	3b01      	subs	r3, #1
 8003d7c:	9301      	str	r3, [sp, #4]
 8003d7e:	9b01      	ldr	r3, [sp, #4]
 8003d80:	2b00      	cmp	r3, #0
 8003d82:	d101      	bne.n	8003d88 <chIQReadTimeout+0x98>
      return r;
 8003d84:	9b05      	ldr	r3, [sp, #20]
 8003d86:	e002      	b.n	8003d8e <chIQReadTimeout+0x9e>
    }

    chSysLock();
 8003d88:	f7ff fea2 	bl	8003ad0 <chSysLock.6967.4406>
 8003d8c:	e7bd      	b.n	8003d0a <chIQReadTimeout+0x1a>
  }
}
 8003d8e:	4618      	mov	r0, r3
 8003d90:	b007      	add	sp, #28
 8003d92:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d96:	bf00      	nop
 8003d98:	f3af 8000 	nop.w
 8003d9c:	f3af 8000 	nop.w

08003da0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8003da0:	b500      	push	{lr}
 8003da2:	b085      	sub	sp, #20
 8003da4:	9003      	str	r0, [sp, #12]
 8003da6:	9102      	str	r1, [sp, #8]
 8003da8:	9201      	str	r2, [sp, #4]
 8003daa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 8003dac:	9b03      	ldr	r3, [sp, #12]
 8003dae:	4618      	mov	r0, r3
 8003db0:	f7ff fe9e 	bl	8003af0 <chThdQueueObjectInit.6971.4401>
  oqp->q_counter = size;
 8003db4:	9b03      	ldr	r3, [sp, #12]
 8003db6:	9a01      	ldr	r2, [sp, #4]
 8003db8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8003dba:	9b03      	ldr	r3, [sp, #12]
 8003dbc:	9a02      	ldr	r2, [sp, #8]
 8003dbe:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8003dc0:	9b03      	ldr	r3, [sp, #12]
 8003dc2:	9a02      	ldr	r2, [sp, #8]
 8003dc4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8003dc6:	9b03      	ldr	r3, [sp, #12]
 8003dc8:	9a02      	ldr	r2, [sp, #8]
 8003dca:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8003dcc:	9a02      	ldr	r2, [sp, #8]
 8003dce:	9b01      	ldr	r3, [sp, #4]
 8003dd0:	441a      	add	r2, r3
 8003dd2:	9b03      	ldr	r3, [sp, #12]
 8003dd4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8003dd6:	9b03      	ldr	r3, [sp, #12]
 8003dd8:	9a00      	ldr	r2, [sp, #0]
 8003dda:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8003ddc:	9b03      	ldr	r3, [sp, #12]
 8003dde:	9a06      	ldr	r2, [sp, #24]
 8003de0:	621a      	str	r2, [r3, #32]
}
 8003de2:	b005      	add	sp, #20
 8003de4:	f85d fb04 	ldr.w	pc, [sp], #4
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003df0:	b500      	push	{lr}
 8003df2:	b087      	sub	sp, #28
 8003df4:	9003      	str	r0, [sp, #12]
 8003df6:	460b      	mov	r3, r1
 8003df8:	9201      	str	r2, [sp, #4]
 8003dfa:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 8003dfe:	f7ff fe67 	bl	8003ad0 <chSysLock.6967.4406>
 8003e02:	e00c      	b.n	8003e1e <chOQPutTimeout+0x2e>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003e04:	9b03      	ldr	r3, [sp, #12]
 8003e06:	4618      	mov	r0, r3
 8003e08:	9901      	ldr	r1, [sp, #4]
 8003e0a:	f001 fe51 	bl	8005ab0 <chThdEnqueueTimeoutS>
 8003e0e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003e10:	9b05      	ldr	r3, [sp, #20]
 8003e12:	2b00      	cmp	r3, #0
 8003e14:	da03      	bge.n	8003e1e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8003e16:	f7ff fe63 	bl	8003ae0 <chSysUnlock.6969.4404>
      return msg;
 8003e1a:	9b05      	ldr	r3, [sp, #20]
 8003e1c:	e027      	b.n	8003e6e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8003e1e:	9803      	ldr	r0, [sp, #12]
 8003e20:	f7ff feb6 	bl	8003b90 <chOQIsFullI.6998.4388>
 8003e24:	4603      	mov	r3, r0
 8003e26:	2b00      	cmp	r3, #0
 8003e28:	d1ec      	bne.n	8003e04 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8003e2a:	9b03      	ldr	r3, [sp, #12]
 8003e2c:	689b      	ldr	r3, [r3, #8]
 8003e2e:	1e5a      	subs	r2, r3, #1
 8003e30:	9b03      	ldr	r3, [sp, #12]
 8003e32:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003e34:	9b03      	ldr	r3, [sp, #12]
 8003e36:	695b      	ldr	r3, [r3, #20]
 8003e38:	1c59      	adds	r1, r3, #1
 8003e3a:	9a03      	ldr	r2, [sp, #12]
 8003e3c:	6151      	str	r1, [r2, #20]
 8003e3e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8003e42:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003e44:	9b03      	ldr	r3, [sp, #12]
 8003e46:	695a      	ldr	r2, [r3, #20]
 8003e48:	9b03      	ldr	r3, [sp, #12]
 8003e4a:	691b      	ldr	r3, [r3, #16]
 8003e4c:	429a      	cmp	r2, r3
 8003e4e:	d303      	bcc.n	8003e58 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 8003e50:	9b03      	ldr	r3, [sp, #12]
 8003e52:	68da      	ldr	r2, [r3, #12]
 8003e54:	9b03      	ldr	r3, [sp, #12]
 8003e56:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 8003e58:	9b03      	ldr	r3, [sp, #12]
 8003e5a:	69db      	ldr	r3, [r3, #28]
 8003e5c:	2b00      	cmp	r3, #0
 8003e5e:	d003      	beq.n	8003e68 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 8003e60:	9b03      	ldr	r3, [sp, #12]
 8003e62:	69db      	ldr	r3, [r3, #28]
 8003e64:	9803      	ldr	r0, [sp, #12]
 8003e66:	4798      	blx	r3
  }
  chSysUnlock();
 8003e68:	f7ff fe3a 	bl	8003ae0 <chSysUnlock.6969.4404>

  return Q_OK;
 8003e6c:	2300      	movs	r3, #0
}
 8003e6e:	4618      	mov	r0, r3
 8003e70:	b007      	add	sp, #28
 8003e72:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e76:	bf00      	nop
 8003e78:	f3af 8000 	nop.w
 8003e7c:	f3af 8000 	nop.w

08003e80 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8003e80:	b500      	push	{lr}
 8003e82:	b085      	sub	sp, #20
 8003e84:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 8003e86:	9801      	ldr	r0, [sp, #4]
 8003e88:	f7ff fe6a 	bl	8003b60 <chOQIsEmptyI.6994.4392>
 8003e8c:	4603      	mov	r3, r0
 8003e8e:	2b00      	cmp	r3, #0
 8003e90:	d002      	beq.n	8003e98 <chOQGetI+0x18>
    return Q_EMPTY;
 8003e92:	f06f 0302 	mvn.w	r3, #2
 8003e96:	e01d      	b.n	8003ed4 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	689b      	ldr	r3, [r3, #8]
 8003e9c:	1c5a      	adds	r2, r3, #1
 8003e9e:	9b01      	ldr	r3, [sp, #4]
 8003ea0:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003ea2:	9b01      	ldr	r3, [sp, #4]
 8003ea4:	699b      	ldr	r3, [r3, #24]
 8003ea6:	1c59      	adds	r1, r3, #1
 8003ea8:	9a01      	ldr	r2, [sp, #4]
 8003eaa:	6191      	str	r1, [r2, #24]
 8003eac:	781b      	ldrb	r3, [r3, #0]
 8003eae:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003eb2:	9b01      	ldr	r3, [sp, #4]
 8003eb4:	699a      	ldr	r2, [r3, #24]
 8003eb6:	9b01      	ldr	r3, [sp, #4]
 8003eb8:	691b      	ldr	r3, [r3, #16]
 8003eba:	429a      	cmp	r2, r3
 8003ebc:	d303      	bcc.n	8003ec6 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 8003ebe:	9b01      	ldr	r3, [sp, #4]
 8003ec0:	68da      	ldr	r2, [r3, #12]
 8003ec2:	9b01      	ldr	r3, [sp, #4]
 8003ec4:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8003ec6:	9b01      	ldr	r3, [sp, #4]
 8003ec8:	4618      	mov	r0, r3
 8003eca:	2100      	movs	r1, #0
 8003ecc:	f001 fe10 	bl	8005af0 <chThdDequeueNextI>

  return (msg_t)b;
 8003ed0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8003ed4:	4618      	mov	r0, r3
 8003ed6:	b005      	add	sp, #20
 8003ed8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003edc:	f3af 8000 	nop.w

08003ee0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003ee0:	b500      	push	{lr}
 8003ee2:	b087      	sub	sp, #28
 8003ee4:	9003      	str	r0, [sp, #12]
 8003ee6:	9102      	str	r1, [sp, #8]
 8003ee8:	9201      	str	r2, [sp, #4]
 8003eea:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 8003eec:	9b03      	ldr	r3, [sp, #12]
 8003eee:	69db      	ldr	r3, [r3, #28]
 8003ef0:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003ef2:	2300      	movs	r3, #0
 8003ef4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003ef6:	f7ff fdeb 	bl	8003ad0 <chSysLock.6967.4406>
 8003efa:	e00b      	b.n	8003f14 <chOQWriteTimeout+0x34>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8003efc:	9b03      	ldr	r3, [sp, #12]
 8003efe:	4618      	mov	r0, r3
 8003f00:	9900      	ldr	r1, [sp, #0]
 8003f02:	f001 fdd5 	bl	8005ab0 <chThdEnqueueTimeoutS>
 8003f06:	4603      	mov	r3, r0
 8003f08:	2b00      	cmp	r3, #0
 8003f0a:	d003      	beq.n	8003f14 <chOQWriteTimeout+0x34>
        chSysUnlock();
 8003f0c:	f7ff fde8 	bl	8003ae0 <chSysUnlock.6969.4404>
        return w;
 8003f10:	9b05      	ldr	r3, [sp, #20]
 8003f12:	e034      	b.n	8003f7e <chOQWriteTimeout+0x9e>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003f14:	9803      	ldr	r0, [sp, #12]
 8003f16:	f7ff fe3b 	bl	8003b90 <chOQIsFullI.6998.4388>
 8003f1a:	4603      	mov	r3, r0
 8003f1c:	2b00      	cmp	r3, #0
 8003f1e:	d1ed      	bne.n	8003efc <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003f20:	9b03      	ldr	r3, [sp, #12]
 8003f22:	689b      	ldr	r3, [r3, #8]
 8003f24:	1e5a      	subs	r2, r3, #1
 8003f26:	9b03      	ldr	r3, [sp, #12]
 8003f28:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8003f2a:	9b03      	ldr	r3, [sp, #12]
 8003f2c:	695b      	ldr	r3, [r3, #20]
 8003f2e:	1c59      	adds	r1, r3, #1
 8003f30:	9a03      	ldr	r2, [sp, #12]
 8003f32:	6151      	str	r1, [r2, #20]
 8003f34:	9a02      	ldr	r2, [sp, #8]
 8003f36:	1c51      	adds	r1, r2, #1
 8003f38:	9102      	str	r1, [sp, #8]
 8003f3a:	7812      	ldrb	r2, [r2, #0]
 8003f3c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8003f3e:	9b03      	ldr	r3, [sp, #12]
 8003f40:	695a      	ldr	r2, [r3, #20]
 8003f42:	9b03      	ldr	r3, [sp, #12]
 8003f44:	691b      	ldr	r3, [r3, #16]
 8003f46:	429a      	cmp	r2, r3
 8003f48:	d303      	bcc.n	8003f52 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 8003f4a:	9b03      	ldr	r3, [sp, #12]
 8003f4c:	68da      	ldr	r2, [r3, #12]
 8003f4e:	9b03      	ldr	r3, [sp, #12]
 8003f50:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 8003f52:	9b04      	ldr	r3, [sp, #16]
 8003f54:	2b00      	cmp	r3, #0
 8003f56:	d002      	beq.n	8003f5e <chOQWriteTimeout+0x7e>
      nfy(oqp);
 8003f58:	9b04      	ldr	r3, [sp, #16]
 8003f5a:	9803      	ldr	r0, [sp, #12]
 8003f5c:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003f5e:	f7ff fdbf 	bl	8003ae0 <chSysUnlock.6969.4404>

    w++;
 8003f62:	9b05      	ldr	r3, [sp, #20]
 8003f64:	3301      	adds	r3, #1
 8003f66:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8003f68:	9b01      	ldr	r3, [sp, #4]
 8003f6a:	3b01      	subs	r3, #1
 8003f6c:	9301      	str	r3, [sp, #4]
 8003f6e:	9b01      	ldr	r3, [sp, #4]
 8003f70:	2b00      	cmp	r3, #0
 8003f72:	d101      	bne.n	8003f78 <chOQWriteTimeout+0x98>
      return w;
 8003f74:	9b05      	ldr	r3, [sp, #20]
 8003f76:	e002      	b.n	8003f7e <chOQWriteTimeout+0x9e>
    }
    chSysLock();
 8003f78:	f7ff fdaa 	bl	8003ad0 <chSysLock.6967.4406>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  chDbgCheck(n > 0U);

  chSysLock();
 8003f7c:	e7ca      	b.n	8003f14 <chOQWriteTimeout+0x34>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8003f7e:	4618      	mov	r0, r3
 8003f80:	b007      	add	sp, #28
 8003f82:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f86:	bf00      	nop
 8003f88:	f3af 8000 	nop.w
 8003f8c:	f3af 8000 	nop.w

08003f90 <port_lock.7069.4324>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003f90:	b082      	sub	sp, #8
 8003f92:	2320      	movs	r3, #32
 8003f94:	9301      	str	r3, [sp, #4]
 8003f96:	9b01      	ldr	r3, [sp, #4]
 8003f98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003f9c:	b002      	add	sp, #8
 8003f9e:	4770      	bx	lr

08003fa0 <port_unlock.7072.4322>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003fa0:	b082      	sub	sp, #8
 8003fa2:	2300      	movs	r3, #0
 8003fa4:	9301      	str	r3, [sp, #4]
 8003fa6:	9b01      	ldr	r3, [sp, #4]
 8003fa8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003fac:	b002      	add	sp, #8
 8003fae:	4770      	bx	lr

08003fb0 <chSysLock.7074.4320>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003fb0:	b508      	push	{r3, lr}

  port_lock();
 8003fb2:	f7ff ffed 	bl	8003f90 <port_lock.7069.4324>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003fb6:	bd08      	pop	{r3, pc}
 8003fb8:	f3af 8000 	nop.w
 8003fbc:	f3af 8000 	nop.w

08003fc0 <chSysUnlock.7076.4318>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003fc0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003fc2:	f7ff ffed 	bl	8003fa0 <port_unlock.7072.4322>
}
 8003fc6:	bd08      	pop	{r3, pc}
 8003fc8:	f3af 8000 	nop.w
 8003fcc:	f3af 8000 	nop.w

08003fd0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003fd0:	4b06      	ldr	r3, [pc, #24]	; (8003fec <_core_init+0x1c>)
 8003fd2:	3307      	adds	r3, #7
 8003fd4:	f023 0307 	bic.w	r3, r3, #7
 8003fd8:	461a      	mov	r2, r3
 8003fda:	4b05      	ldr	r3, [pc, #20]	; (8003ff0 <_core_init+0x20>)
 8003fdc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003fde:	4b05      	ldr	r3, [pc, #20]	; (8003ff4 <_core_init+0x24>)
 8003fe0:	f023 0307 	bic.w	r3, r3, #7
 8003fe4:	461a      	mov	r2, r3
 8003fe6:	4b04      	ldr	r3, [pc, #16]	; (8003ff8 <_core_init+0x28>)
 8003fe8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8003fea:	4770      	bx	lr
 8003fec:	20001f58 	.word	0x20001f58
 8003ff0:	20000aa8 	.word	0x20000aa8
 8003ff4:	2000a000 	.word	0x2000a000
 8003ff8:	20000aac 	.word	0x20000aac
 8003ffc:	f3af 8000 	nop.w

08004000 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8004000:	b500      	push	{lr}
 8004002:	b085      	sub	sp, #20
 8004004:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8004006:	f7ff ffd3 	bl	8003fb0 <chSysLock.7074.4320>
  p = chCoreAllocI(size);
 800400a:	9801      	ldr	r0, [sp, #4]
 800400c:	f000 f808 	bl	8004020 <chCoreAllocI.4313>
 8004010:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8004012:	f7ff ffd5 	bl	8003fc0 <chSysUnlock.7076.4318>

  return p;
 8004016:	9b03      	ldr	r3, [sp, #12]
}
 8004018:	4618      	mov	r0, r3
 800401a:	b005      	add	sp, #20
 800401c:	f85d fb04 	ldr.w	pc, [sp], #4

08004020 <chCoreAllocI.4313>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8004020:	b084      	sub	sp, #16
 8004022:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8004024:	9b01      	ldr	r3, [sp, #4]
 8004026:	3307      	adds	r3, #7
 8004028:	f023 0307 	bic.w	r3, r3, #7
 800402c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800402e:	4b0c      	ldr	r3, [pc, #48]	; (8004060 <chCoreAllocI.4313+0x40>)
 8004030:	681b      	ldr	r3, [r3, #0]
 8004032:	461a      	mov	r2, r3
 8004034:	4b0b      	ldr	r3, [pc, #44]	; (8004064 <chCoreAllocI.4313+0x44>)
 8004036:	681b      	ldr	r3, [r3, #0]
 8004038:	1ad3      	subs	r3, r2, r3
 800403a:	461a      	mov	r2, r3
 800403c:	9b01      	ldr	r3, [sp, #4]
 800403e:	429a      	cmp	r2, r3
 8004040:	d201      	bcs.n	8004046 <chCoreAllocI.4313+0x26>
  /*lint -restore*/
    return NULL;
 8004042:	2300      	movs	r3, #0
 8004044:	e009      	b.n	800405a <chCoreAllocI.4313+0x3a>
  }
  p = nextmem;
 8004046:	4b07      	ldr	r3, [pc, #28]	; (8004064 <chCoreAllocI.4313+0x44>)
 8004048:	681b      	ldr	r3, [r3, #0]
 800404a:	9303      	str	r3, [sp, #12]
  nextmem += size;
 800404c:	4b05      	ldr	r3, [pc, #20]	; (8004064 <chCoreAllocI.4313+0x44>)
 800404e:	681a      	ldr	r2, [r3, #0]
 8004050:	9b01      	ldr	r3, [sp, #4]
 8004052:	441a      	add	r2, r3
 8004054:	4b03      	ldr	r3, [pc, #12]	; (8004064 <chCoreAllocI.4313+0x44>)
 8004056:	601a      	str	r2, [r3, #0]

  return p;
 8004058:	9b03      	ldr	r3, [sp, #12]
}
 800405a:	4618      	mov	r0, r3
 800405c:	b004      	add	sp, #16
 800405e:	4770      	bx	lr
 8004060:	20000aac 	.word	0x20000aac
 8004064:	20000aa8 	.word	0x20000aa8
 8004068:	f3af 8000 	nop.w
 800406c:	f3af 8000 	nop.w

08004070 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8004070:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8004072:	4b06      	ldr	r3, [pc, #24]	; (800408c <_heap_init+0x1c>)
 8004074:	4a06      	ldr	r2, [pc, #24]	; (8004090 <_heap_init+0x20>)
 8004076:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8004078:	4b04      	ldr	r3, [pc, #16]	; (800408c <_heap_init+0x1c>)
 800407a:	2200      	movs	r2, #0
 800407c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800407e:	4b03      	ldr	r3, [pc, #12]	; (800408c <_heap_init+0x1c>)
 8004080:	2200      	movs	r2, #0
 8004082:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8004084:	4803      	ldr	r0, [pc, #12]	; (8004094 <_heap_init+0x24>)
 8004086:	f000 fb83 	bl	8004790 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800408a:	bd08      	pop	{r3, pc}
 800408c:	20000ab0 	.word	0x20000ab0
 8004090:	08004001 	.word	0x08004001
 8004094:	20000ac0 	.word	0x20000ac0
 8004098:	f3af 8000 	nop.w
 800409c:	f3af 8000 	nop.w

080040a0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80040a0:	b500      	push	{lr}
 80040a2:	b087      	sub	sp, #28
 80040a4:	9001      	str	r0, [sp, #4]
 80040a6:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 80040a8:	9b01      	ldr	r3, [sp, #4]
 80040aa:	2b00      	cmp	r3, #0
 80040ac:	d101      	bne.n	80040b2 <chHeapAlloc+0x12>
    heapp = &default_heap;
 80040ae:	4b37      	ldr	r3, [pc, #220]	; (800418c <chHeapAlloc+0xec>)
 80040b0:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 80040b2:	9b00      	ldr	r3, [sp, #0]
 80040b4:	3307      	adds	r3, #7
 80040b6:	f023 0307 	bic.w	r3, r3, #7
 80040ba:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 80040bc:	9b01      	ldr	r3, [sp, #4]
 80040be:	3308      	adds	r3, #8
 80040c0:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 80040c2:	9b01      	ldr	r3, [sp, #4]
 80040c4:	3310      	adds	r3, #16
 80040c6:	4618      	mov	r0, r3
 80040c8:	f000 fb72 	bl	80047b0 <chMtxLock>
 80040cc:	e036      	b.n	800413c <chHeapAlloc+0x9c>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
 80040ce:	9b05      	ldr	r3, [sp, #20]
 80040d0:	681b      	ldr	r3, [r3, #0]
 80040d2:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 80040d4:	9b04      	ldr	r3, [sp, #16]
 80040d6:	685a      	ldr	r2, [r3, #4]
 80040d8:	9b00      	ldr	r3, [sp, #0]
 80040da:	429a      	cmp	r2, r3
 80040dc:	d32c      	bcc.n	8004138 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 80040de:	9b04      	ldr	r3, [sp, #16]
 80040e0:	685a      	ldr	r2, [r3, #4]
 80040e2:	9b00      	ldr	r3, [sp, #0]
 80040e4:	3308      	adds	r3, #8
 80040e6:	429a      	cmp	r2, r3
 80040e8:	d204      	bcs.n	80040f4 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80040ea:	9b04      	ldr	r3, [sp, #16]
 80040ec:	681a      	ldr	r2, [r3, #0]
 80040ee:	9b05      	ldr	r3, [sp, #20]
 80040f0:	601a      	str	r2, [r3, #0]
 80040f2:	e016      	b.n	8004122 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80040f4:	9b00      	ldr	r3, [sp, #0]
 80040f6:	3308      	adds	r3, #8
 80040f8:	9a04      	ldr	r2, [sp, #16]
 80040fa:	4413      	add	r3, r2
 80040fc:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80040fe:	9b04      	ldr	r3, [sp, #16]
 8004100:	681a      	ldr	r2, [r3, #0]
 8004102:	9b03      	ldr	r3, [sp, #12]
 8004104:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8004106:	9b04      	ldr	r3, [sp, #16]
 8004108:	685a      	ldr	r2, [r3, #4]
 800410a:	9b00      	ldr	r3, [sp, #0]
 800410c:	1ad3      	subs	r3, r2, r3
 800410e:	f1a3 0208 	sub.w	r2, r3, #8
 8004112:	9b03      	ldr	r3, [sp, #12]
 8004114:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 8004116:	9b05      	ldr	r3, [sp, #20]
 8004118:	9a03      	ldr	r2, [sp, #12]
 800411a:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 800411c:	9b04      	ldr	r3, [sp, #16]
 800411e:	9a00      	ldr	r2, [sp, #0]
 8004120:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 8004122:	9b04      	ldr	r3, [sp, #16]
 8004124:	9a01      	ldr	r2, [sp, #4]
 8004126:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 8004128:	9b01      	ldr	r3, [sp, #4]
 800412a:	3310      	adds	r3, #16
 800412c:	4618      	mov	r0, r3
 800412e:	f000 fbaf 	bl	8004890 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 8004132:	9b04      	ldr	r3, [sp, #16]
 8004134:	3308      	adds	r3, #8
 8004136:	e024      	b.n	8004182 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 8004138:	9b04      	ldr	r3, [sp, #16]
 800413a:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800413c:	9b05      	ldr	r3, [sp, #20]
 800413e:	681b      	ldr	r3, [r3, #0]
 8004140:	2b00      	cmp	r3, #0
 8004142:	d1c4      	bne.n	80040ce <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8004144:	9b01      	ldr	r3, [sp, #4]
 8004146:	3310      	adds	r3, #16
 8004148:	4618      	mov	r0, r3
 800414a:	f000 fba1 	bl	8004890 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800414e:	9b01      	ldr	r3, [sp, #4]
 8004150:	681b      	ldr	r3, [r3, #0]
 8004152:	2b00      	cmp	r3, #0
 8004154:	d014      	beq.n	8004180 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8004156:	9b01      	ldr	r3, [sp, #4]
 8004158:	681b      	ldr	r3, [r3, #0]
 800415a:	9a00      	ldr	r2, [sp, #0]
 800415c:	3208      	adds	r2, #8
 800415e:	4610      	mov	r0, r2
 8004160:	4798      	blx	r3
 8004162:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8004164:	9b04      	ldr	r3, [sp, #16]
 8004166:	2b00      	cmp	r3, #0
 8004168:	d00a      	beq.n	8004180 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800416a:	9b04      	ldr	r3, [sp, #16]
 800416c:	9a01      	ldr	r2, [sp, #4]
 800416e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8004170:	9b04      	ldr	r3, [sp, #16]
 8004172:	9a00      	ldr	r2, [sp, #0]
 8004174:	605a      	str	r2, [r3, #4]
      hp++;
 8004176:	9b04      	ldr	r3, [sp, #16]
 8004178:	3308      	adds	r3, #8
 800417a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800417c:	9b04      	ldr	r3, [sp, #16]
 800417e:	e000      	b.n	8004182 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 8004180:	2300      	movs	r3, #0
}
 8004182:	4618      	mov	r0, r3
 8004184:	b007      	add	sp, #28
 8004186:	f85d fb04 	ldr.w	pc, [sp], #4
 800418a:	bf00      	nop
 800418c:	20000ab0 	.word	0x20000ab0

08004190 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8004190:	b500      	push	{lr}
 8004192:	b087      	sub	sp, #28
 8004194:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8004196:	9b01      	ldr	r3, [sp, #4]
 8004198:	3b08      	subs	r3, #8
 800419a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800419c:	9b04      	ldr	r3, [sp, #16]
 800419e:	681b      	ldr	r3, [r3, #0]
 80041a0:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 80041a2:	9b03      	ldr	r3, [sp, #12]
 80041a4:	3308      	adds	r3, #8
 80041a6:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 80041a8:	9b03      	ldr	r3, [sp, #12]
 80041aa:	3310      	adds	r3, #16
 80041ac:	4618      	mov	r0, r3
 80041ae:	f000 faff 	bl	80047b0 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80041b2:	9b03      	ldr	r3, [sp, #12]
 80041b4:	f103 0208 	add.w	r2, r3, #8
 80041b8:	9b05      	ldr	r3, [sp, #20]
 80041ba:	429a      	cmp	r2, r3
 80041bc:	d003      	beq.n	80041c6 <chHeapFree+0x36>
 80041be:	9a04      	ldr	r2, [sp, #16]
 80041c0:	9b05      	ldr	r3, [sp, #20]
 80041c2:	429a      	cmp	r2, r3
 80041c4:	d93d      	bls.n	8004242 <chHeapFree+0xb2>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80041c6:	9b05      	ldr	r3, [sp, #20]
 80041c8:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80041ca:	2b00      	cmp	r3, #0
 80041cc:	d004      	beq.n	80041d8 <chHeapFree+0x48>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80041ce:	9b05      	ldr	r3, [sp, #20]
 80041d0:	681a      	ldr	r2, [r3, #0]
 80041d2:	9b04      	ldr	r3, [sp, #16]
 80041d4:	429a      	cmp	r2, r3
 80041d6:	d934      	bls.n	8004242 <chHeapFree+0xb2>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 80041d8:	9b05      	ldr	r3, [sp, #20]
 80041da:	681a      	ldr	r2, [r3, #0]
 80041dc:	9b04      	ldr	r3, [sp, #16]
 80041de:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 80041e0:	9b05      	ldr	r3, [sp, #20]
 80041e2:	9a04      	ldr	r2, [sp, #16]
 80041e4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80041e6:	9b04      	ldr	r3, [sp, #16]
 80041e8:	685b      	ldr	r3, [r3, #4]
 80041ea:	3308      	adds	r3, #8
 80041ec:	9a04      	ldr	r2, [sp, #16]
 80041ee:	441a      	add	r2, r3
 80041f0:	9b04      	ldr	r3, [sp, #16]
 80041f2:	681b      	ldr	r3, [r3, #0]
 80041f4:	429a      	cmp	r2, r3
 80041f6:	d10e      	bne.n	8004216 <chHeapFree+0x86>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80041f8:	9b04      	ldr	r3, [sp, #16]
 80041fa:	685a      	ldr	r2, [r3, #4]
 80041fc:	9b04      	ldr	r3, [sp, #16]
 80041fe:	681b      	ldr	r3, [r3, #0]
 8004200:	685b      	ldr	r3, [r3, #4]
 8004202:	4413      	add	r3, r2
 8004204:	f103 0208 	add.w	r2, r3, #8
 8004208:	9b04      	ldr	r3, [sp, #16]
 800420a:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 800420c:	9b04      	ldr	r3, [sp, #16]
 800420e:	681b      	ldr	r3, [r3, #0]
 8004210:	681a      	ldr	r2, [r3, #0]
 8004212:	9b04      	ldr	r3, [sp, #16]
 8004214:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 8004216:	9b05      	ldr	r3, [sp, #20]
 8004218:	685b      	ldr	r3, [r3, #4]
 800421a:	3308      	adds	r3, #8
 800421c:	9a05      	ldr	r2, [sp, #20]
 800421e:	441a      	add	r2, r3
 8004220:	9b04      	ldr	r3, [sp, #16]
 8004222:	429a      	cmp	r2, r3
 8004224:	d111      	bne.n	800424a <chHeapFree+0xba>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8004226:	9b05      	ldr	r3, [sp, #20]
 8004228:	685a      	ldr	r2, [r3, #4]
 800422a:	9b04      	ldr	r3, [sp, #16]
 800422c:	685b      	ldr	r3, [r3, #4]
 800422e:	4413      	add	r3, r2
 8004230:	f103 0208 	add.w	r2, r3, #8
 8004234:	9b05      	ldr	r3, [sp, #20]
 8004236:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8004238:	9b04      	ldr	r3, [sp, #16]
 800423a:	681a      	ldr	r2, [r3, #0]
 800423c:	9b05      	ldr	r3, [sp, #20]
 800423e:	601a      	str	r2, [r3, #0]
 8004240:	e003      	b.n	800424a <chHeapFree+0xba>
      }
      break;
    }
    qp = qp->h.u.next;
 8004242:	9b05      	ldr	r3, [sp, #20]
 8004244:	681b      	ldr	r3, [r3, #0]
 8004246:	9305      	str	r3, [sp, #20]
 8004248:	e7b3      	b.n	80041b2 <chHeapFree+0x22>
  }
  H_UNLOCK(heapp);
 800424a:	9b03      	ldr	r3, [sp, #12]
 800424c:	3310      	adds	r3, #16
 800424e:	4618      	mov	r0, r3
 8004250:	f000 fb1e 	bl	8004890 <chMtxUnlock>

  return;
}
 8004254:	b007      	add	sp, #28
 8004256:	f85d fb04 	ldr.w	pc, [sp], #4
 800425a:	bf00      	nop
 800425c:	f3af 8000 	nop.w

08004260 <port_lock.7295.4272>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004260:	b082      	sub	sp, #8
 8004262:	2320      	movs	r3, #32
 8004264:	9301      	str	r3, [sp, #4]
 8004266:	9b01      	ldr	r3, [sp, #4]
 8004268:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800426c:	b002      	add	sp, #8
 800426e:	4770      	bx	lr

08004270 <port_unlock.7298.4270>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004270:	b082      	sub	sp, #8
 8004272:	2300      	movs	r3, #0
 8004274:	9301      	str	r3, [sp, #4]
 8004276:	9b01      	ldr	r3, [sp, #4]
 8004278:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800427c:	b002      	add	sp, #8
 800427e:	4770      	bx	lr

08004280 <chSysLock.7300.4268>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004280:	b508      	push	{r3, lr}

  port_lock();
 8004282:	f7ff ffed 	bl	8004260 <port_lock.7295.4272>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004286:	bd08      	pop	{r3, pc}
 8004288:	f3af 8000 	nop.w
 800428c:	f3af 8000 	nop.w

08004290 <chSysUnlock.7302.4266>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004290:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004292:	f7ff ffed 	bl	8004270 <port_unlock.7298.4270>
}
 8004296:	bd08      	pop	{r3, pc}
 8004298:	f3af 8000 	nop.w
 800429c:	f3af 8000 	nop.w

080042a0 <chPoolFreeI.4242>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 80042a0:	b084      	sub	sp, #16
 80042a2:	9001      	str	r0, [sp, #4]
 80042a4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 80042a6:	9b00      	ldr	r3, [sp, #0]
 80042a8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 80042aa:	9b01      	ldr	r3, [sp, #4]
 80042ac:	681a      	ldr	r2, [r3, #0]
 80042ae:	9b03      	ldr	r3, [sp, #12]
 80042b0:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 80042b2:	9b01      	ldr	r3, [sp, #4]
 80042b4:	9a03      	ldr	r2, [sp, #12]
 80042b6:	601a      	str	r2, [r3, #0]
}
 80042b8:	b004      	add	sp, #16
 80042ba:	4770      	bx	lr
 80042bc:	f3af 8000 	nop.w

080042c0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
 80042c4:	9001      	str	r0, [sp, #4]
 80042c6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80042c8:	f7ff ffda 	bl	8004280 <chSysLock.7300.4268>
  chPoolFreeI(mp, objp);
 80042cc:	9801      	ldr	r0, [sp, #4]
 80042ce:	9900      	ldr	r1, [sp, #0]
 80042d0:	f7ff ffe6 	bl	80042a0 <chPoolFreeI.4242>
  chSysUnlock();
 80042d4:	f7ff ffdc 	bl	8004290 <chSysUnlock.7302.4266>
}
 80042d8:	b003      	add	sp, #12
 80042da:	f85d fb04 	ldr.w	pc, [sp], #4
 80042de:	bf00      	nop

080042e0 <port_lock.7426.4226>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80042e0:	b082      	sub	sp, #8
 80042e2:	2320      	movs	r3, #32
 80042e4:	9301      	str	r3, [sp, #4]
 80042e6:	9b01      	ldr	r3, [sp, #4]
 80042e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80042ec:	b002      	add	sp, #8
 80042ee:	4770      	bx	lr

080042f0 <port_unlock.7429.4224>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80042f0:	b082      	sub	sp, #8
 80042f2:	2300      	movs	r3, #0
 80042f4:	9301      	str	r3, [sp, #4]
 80042f6:	9b01      	ldr	r3, [sp, #4]
 80042f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80042fc:	b002      	add	sp, #8
 80042fe:	4770      	bx	lr

08004300 <port_lock_from_isr.7431.4222>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004300:	b508      	push	{r3, lr}

  port_lock();
 8004302:	f7ff ffed 	bl	80042e0 <port_lock.7426.4226>
}
 8004306:	bd08      	pop	{r3, pc}
 8004308:	f3af 8000 	nop.w
 800430c:	f3af 8000 	nop.w

08004310 <port_unlock_from_isr.7433.4220>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004310:	b508      	push	{r3, lr}

  port_unlock();
 8004312:	f7ff ffed 	bl	80042f0 <port_unlock.7429.4224>
}
 8004316:	bd08      	pop	{r3, pc}
 8004318:	f3af 8000 	nop.w
 800431c:	f3af 8000 	nop.w

08004320 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004320:	b510      	push	{r4, lr}
 8004322:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004324:	f3ef 8309 	mrs	r3, PSP
 8004328:	461c      	mov	r4, r3
  return(result);
 800432a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 800432c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800432e:	9b01      	ldr	r3, [sp, #4]
 8004330:	3320      	adds	r3, #32
 8004332:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8004334:	9b01      	ldr	r3, [sp, #4]
 8004336:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8004338:	9b00      	ldr	r3, [sp, #0]
 800433a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800433e:	f7ff ffe7 	bl	8004310 <port_unlock_from_isr.7433.4220>
}
 8004342:	b002      	add	sp, #8
 8004344:	bd10      	pop	{r4, pc}
 8004346:	bf00      	nop
 8004348:	f3af 8000 	nop.w
 800434c:	f3af 8000 	nop.w

08004350 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8004350:	b510      	push	{r4, lr}
 8004352:	b082      	sub	sp, #8

  port_lock_from_isr();
 8004354:	f7ff ffd4 	bl	8004300 <port_lock_from_isr.7431.4222>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004358:	4b13      	ldr	r3, [pc, #76]	; (80043a8 <_port_irq_epilogue+0x58>)
 800435a:	685b      	ldr	r3, [r3, #4]
 800435c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004360:	2b00      	cmp	r3, #0
 8004362:	d01d      	beq.n	80043a0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004364:	f3ef 8309 	mrs	r3, PSP
 8004368:	461c      	mov	r4, r3
  return(result);
 800436a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 800436c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800436e:	9b01      	ldr	r3, [sp, #4]
 8004370:	3b20      	subs	r3, #32
 8004372:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8004374:	9b01      	ldr	r3, [sp, #4]
 8004376:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800437a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 800437c:	9b01      	ldr	r3, [sp, #4]
 800437e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8004380:	9b00      	ldr	r3, [sp, #0]
 8004382:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004386:	f001 f913 	bl	80055b0 <chSchIsPreemptionRequired>
 800438a:	4603      	mov	r3, r0
 800438c:	2b00      	cmp	r3, #0
 800438e:	d003      	beq.n	8004398 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8004390:	9b01      	ldr	r3, [sp, #4]
 8004392:	4a06      	ldr	r2, [pc, #24]	; (80043ac <_port_irq_epilogue+0x5c>)
 8004394:	619a      	str	r2, [r3, #24]
 8004396:	e005      	b.n	80043a4 <_port_irq_epilogue+0x54>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8004398:	9b01      	ldr	r3, [sp, #4]
 800439a:	4a05      	ldr	r2, [pc, #20]	; (80043b0 <_port_irq_epilogue+0x60>)
 800439c:	619a      	str	r2, [r3, #24]
 800439e:	e001      	b.n	80043a4 <_port_irq_epilogue+0x54>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80043a0:	f7ff ffb6 	bl	8004310 <port_unlock_from_isr.7433.4220>
}
 80043a4:	b002      	add	sp, #8
 80043a6:	bd10      	pop	{r4, pc}
 80043a8:	e000ed00 	.word	0xe000ed00
 80043ac:	08000301 	.word	0x08000301
 80043b0:	08000304 	.word	0x08000304
 80043b4:	f3af 8000 	nop.w
 80043b8:	f3af 8000 	nop.w
 80043bc:	f3af 8000 	nop.w

080043c0 <osalInit.7492.4211>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 80043c0:	4770      	bx	lr
 80043c2:	bf00      	nop
 80043c4:	f3af 8000 	nop.w
 80043c8:	f3af 8000 	nop.w
 80043cc:	f3af 8000 	nop.w

080043d0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80043d0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80043d2:	f7ff fff5 	bl	80043c0 <osalInit.7492.4211>

  /* Platform low level initializations.*/
  hal_lld_init();
 80043d6:	f7ff fb23 	bl	8003a20 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 80043da:	4807      	ldr	r0, [pc, #28]	; (80043f8 <halInit+0x28>)
 80043dc:	f7fd fb28 	bl	8001a30 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 80043e0:	f7fe ffce 	bl	8003380 <extInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80043e4:	f7ff f8fc 	bl	80035e0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 80043e8:	f7ff f9ea 	bl	80037c0 <spiInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80043ec:	f7fe f860 	bl	80024b0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80043f0:	f000 f826 	bl	8004440 <stInit.4196>
#endif
}
 80043f4:	bd08      	pop	{r3, pc}
 80043f6:	bf00      	nop
 80043f8:	080069e0 	.word	0x080069e0
 80043fc:	f3af 8000 	nop.w

08004400 <st_lld_start_alarm.7524.4205>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8004400:	b082      	sub	sp, #8
 8004402:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004404:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004408:	9a01      	ldr	r2, [sp, #4]
 800440a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800440c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004410:	2200      	movs	r2, #0
 8004412:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004414:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004418:	2202      	movs	r2, #2
 800441a:	60da      	str	r2, [r3, #12]
}
 800441c:	b002      	add	sp, #8
 800441e:	4770      	bx	lr

08004420 <st_lld_stop_alarm.7531.4203>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8004420:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004424:	2200      	movs	r2, #0
 8004426:	60da      	str	r2, [r3, #12]
}
 8004428:	4770      	bx	lr
 800442a:	bf00      	nop
 800442c:	f3af 8000 	nop.w

08004430 <st_lld_set_alarm.7533.4200>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8004430:	b082      	sub	sp, #8
 8004432:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004434:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004438:	9a01      	ldr	r2, [sp, #4]
 800443a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800443c:	b002      	add	sp, #8
 800443e:	4770      	bx	lr

08004440 <stInit.4196>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8004440:	b508      	push	{r3, lr}

  st_lld_init();
 8004442:	f7fe fc4d 	bl	8002ce0 <st_lld_init>
}
 8004446:	bd08      	pop	{r3, pc}
 8004448:	f3af 8000 	nop.w
 800444c:	f3af 8000 	nop.w

08004450 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8004450:	b500      	push	{lr}
 8004452:	b083      	sub	sp, #12
 8004454:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8004456:	9801      	ldr	r0, [sp, #4]
 8004458:	f7ff ffd2 	bl	8004400 <st_lld_start_alarm.7524.4205>
}
 800445c:	b003      	add	sp, #12
 800445e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004462:	bf00      	nop
 8004464:	f3af 8000 	nop.w
 8004468:	f3af 8000 	nop.w
 800446c:	f3af 8000 	nop.w

08004470 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8004470:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8004472:	f7ff ffd5 	bl	8004420 <st_lld_stop_alarm.7531.4203>
}
 8004476:	bd08      	pop	{r3, pc}
 8004478:	f3af 8000 	nop.w
 800447c:	f3af 8000 	nop.w

08004480 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8004480:	b500      	push	{lr}
 8004482:	b083      	sub	sp, #12
 8004484:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8004486:	9801      	ldr	r0, [sp, #4]
 8004488:	f7ff ffd2 	bl	8004430 <st_lld_set_alarm.7533.4200>
}
 800448c:	b003      	add	sp, #12
 800448e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004492:	bf00      	nop
 8004494:	f3af 8000 	nop.w
 8004498:	f3af 8000 	nop.w
 800449c:	f3af 8000 	nop.w

080044a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80044a0:	b082      	sub	sp, #8
 80044a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80044a4:	9b01      	ldr	r3, [sp, #4]
 80044a6:	f04f 32ff 	mov.w	r2, #4294967295
 80044aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80044ac:	9b01      	ldr	r3, [sp, #4]
 80044ae:	2200      	movs	r2, #0
 80044b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80044b2:	9b01      	ldr	r3, [sp, #4]
 80044b4:	2200      	movs	r2, #0
 80044b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80044b8:	9b01      	ldr	r3, [sp, #4]
 80044ba:	2200      	movs	r2, #0
 80044bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80044be:	9901      	ldr	r1, [sp, #4]
 80044c0:	f04f 0200 	mov.w	r2, #0
 80044c4:	f04f 0300 	mov.w	r3, #0
 80044c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80044cc:	b002      	add	sp, #8
 80044ce:	4770      	bx	lr

080044d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80044d0:	b500      	push	{lr}
 80044d2:	b083      	sub	sp, #12
 80044d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80044d6:	f001 fb23 	bl	8005b20 <port_rt_get_counter_value.5255>
 80044da:	4602      	mov	r2, r0
 80044dc:	9b01      	ldr	r3, [sp, #4]
 80044de:	609a      	str	r2, [r3, #8]
}
 80044e0:	b003      	add	sp, #12
 80044e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80044e6:	bf00      	nop
 80044e8:	f3af 8000 	nop.w
 80044ec:	f3af 8000 	nop.w

080044f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80044f0:	b500      	push	{lr}
 80044f2:	b083      	sub	sp, #12
 80044f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80044f6:	f001 fb13 	bl	8005b20 <port_rt_get_counter_value.5255>
 80044fa:	4602      	mov	r2, r0
 80044fc:	4b04      	ldr	r3, [pc, #16]	; (8004510 <chTMStopMeasurementX+0x20>)
 80044fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004500:	9801      	ldr	r0, [sp, #4]
 8004502:	4611      	mov	r1, r2
 8004504:	461a      	mov	r2, r3
 8004506:	f001 fb13 	bl	8005b30 <tm_stop.5261>
}
 800450a:	b003      	add	sp, #12
 800450c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004510:	20000958 	.word	0x20000958
 8004514:	f3af 8000 	nop.w
 8004518:	f3af 8000 	nop.w
 800451c:	f3af 8000 	nop.w

08004520 <port_lock.5427.4441>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004520:	b082      	sub	sp, #8
 8004522:	2320      	movs	r3, #32
 8004524:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004526:	9b01      	ldr	r3, [sp, #4]
 8004528:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800452c:	b002      	add	sp, #8
 800452e:	4770      	bx	lr

08004530 <port_unlock.5430.4439>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004530:	b082      	sub	sp, #8
 8004532:	2300      	movs	r3, #0
 8004534:	9301      	str	r3, [sp, #4]
 8004536:	9b01      	ldr	r3, [sp, #4]
 8004538:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800453c:	b002      	add	sp, #8
 800453e:	4770      	bx	lr

08004540 <chSysLock.5432.4437>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004540:	b508      	push	{r3, lr}

  port_lock();
 8004542:	f7ff ffed 	bl	8004520 <port_lock.5427.4441>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004546:	bd08      	pop	{r3, pc}
 8004548:	f3af 8000 	nop.w
 800454c:	f3af 8000 	nop.w

08004550 <chSysUnlock.5434.4435>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004550:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004552:	f7ff ffed 	bl	8004530 <port_unlock.5430.4439>
}
 8004556:	bd08      	pop	{r3, pc}
 8004558:	f3af 8000 	nop.w
 800455c:	f3af 8000 	nop.w

08004560 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8004560:	b500      	push	{lr}
 8004562:	b085      	sub	sp, #20
 8004564:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 8004566:	f7ff ffeb 	bl	8004540 <chSysLock.5432.4437>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 800456a:	9b01      	ldr	r3, [sp, #4]
 800456c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8004570:	3b01      	subs	r3, #1
 8004572:	b2da      	uxtb	r2, r3
 8004574:	9b01      	ldr	r3, [sp, #4]
 8004576:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  refs = tp->p_refs;
 800457a:	9b01      	ldr	r3, [sp, #4]
 800457c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8004580:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8004584:	f7ff ffe4 	bl	8004550 <chSysUnlock.5434.4435>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8004588:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800458c:	2b00      	cmp	r3, #0
 800458e:	d12c      	bne.n	80045ea <chThdRelease+0x8a>
 8004590:	9b01      	ldr	r3, [sp, #4]
 8004592:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004596:	2b0f      	cmp	r3, #15
 8004598:	d127      	bne.n	80045ea <chThdRelease+0x8a>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 800459a:	9b01      	ldr	r3, [sp, #4]
 800459c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80045a0:	f003 0303 	and.w	r3, r3, #3
 80045a4:	2b01      	cmp	r3, #1
 80045a6:	d002      	beq.n	80045ae <chThdRelease+0x4e>
 80045a8:	2b02      	cmp	r3, #2
 80045aa:	d00e      	beq.n	80045ca <chThdRelease+0x6a>
 80045ac:	e01d      	b.n	80045ea <chThdRelease+0x8a>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 80045ae:	9b01      	ldr	r3, [sp, #4]
 80045b0:	695b      	ldr	r3, [r3, #20]
 80045b2:	9a01      	ldr	r2, [sp, #4]
 80045b4:	6912      	ldr	r2, [r2, #16]
 80045b6:	611a      	str	r2, [r3, #16]
 80045b8:	9b01      	ldr	r3, [sp, #4]
 80045ba:	691b      	ldr	r3, [r3, #16]
 80045bc:	9a01      	ldr	r2, [sp, #4]
 80045be:	6952      	ldr	r2, [r2, #20]
 80045c0:	615a      	str	r2, [r3, #20]
#endif
      chHeapFree(tp);
 80045c2:	9801      	ldr	r0, [sp, #4]
 80045c4:	f7ff fde4 	bl	8004190 <chHeapFree>
 80045c8:	e00f      	b.n	80045ea <chThdRelease+0x8a>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 80045ca:	9b01      	ldr	r3, [sp, #4]
 80045cc:	695b      	ldr	r3, [r3, #20]
 80045ce:	9a01      	ldr	r2, [sp, #4]
 80045d0:	6912      	ldr	r2, [r2, #16]
 80045d2:	611a      	str	r2, [r3, #16]
 80045d4:	9b01      	ldr	r3, [sp, #4]
 80045d6:	691b      	ldr	r3, [r3, #16]
 80045d8:	9a01      	ldr	r2, [sp, #4]
 80045da:	6952      	ldr	r2, [r2, #20]
 80045dc:	615a      	str	r2, [r3, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 80045de:	9b01      	ldr	r3, [sp, #4]
 80045e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80045e2:	4618      	mov	r0, r3
 80045e4:	9901      	ldr	r1, [sp, #4]
 80045e6:	f7ff fe6b 	bl	80042c0 <chPoolFree>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 80045ea:	b005      	add	sp, #20
 80045ec:	f85d fb04 	ldr.w	pc, [sp], #4

080045f0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 80045f0:	b500      	push	{lr}
 80045f2:	b089      	sub	sp, #36	; 0x24
 80045f4:	9005      	str	r0, [sp, #20]
 80045f6:	9104      	str	r1, [sp, #16]
 80045f8:	9203      	str	r2, [sp, #12]
 80045fa:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80045fc:	9805      	ldr	r0, [sp, #20]
 80045fe:	9904      	ldr	r1, [sp, #16]
 8004600:	f7ff fd4e 	bl	80040a0 <chHeapAlloc>
 8004604:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 8004606:	9b07      	ldr	r3, [sp, #28]
 8004608:	2b00      	cmp	r3, #0
 800460a:	d101      	bne.n	8004610 <chThdCreateFromHeap+0x20>
    return NULL;
 800460c:	2300      	movs	r3, #0
 800460e:	e015      	b.n	800463c <chThdCreateFromHeap+0x4c>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
 8004610:	f7ff ff96 	bl	8004540 <chSysLock.5432.4437>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8004614:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004616:	9300      	str	r3, [sp, #0]
 8004618:	9807      	ldr	r0, [sp, #28]
 800461a:	9904      	ldr	r1, [sp, #16]
 800461c:	9a03      	ldr	r2, [sp, #12]
 800461e:	9b02      	ldr	r3, [sp, #8]
 8004620:	f001 f94e 	bl	80058c0 <chThdCreateI>
 8004624:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8004626:	9b06      	ldr	r3, [sp, #24]
 8004628:	2201      	movs	r2, #1
 800462a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 800462e:	9806      	ldr	r0, [sp, #24]
 8004630:	2100      	movs	r1, #0
 8004632:	f000 ff75 	bl	8005520 <chSchWakeupS>
  chSysUnlock();
 8004636:	f7ff ff8b 	bl	8004550 <chSysUnlock.5434.4435>

  return tp;
 800463a:	9b06      	ldr	r3, [sp, #24]
}
 800463c:	4618      	mov	r0, r3
 800463e:	b009      	add	sp, #36	; 0x24
 8004640:	f85d fb04 	ldr.w	pc, [sp], #4
 8004644:	f3af 8000 	nop.w
 8004648:	f3af 8000 	nop.w
 800464c:	f3af 8000 	nop.w

08004650 <port_lock.5934.4310>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004650:	b082      	sub	sp, #8
 8004652:	2320      	movs	r3, #32
 8004654:	9301      	str	r3, [sp, #4]
 8004656:	9b01      	ldr	r3, [sp, #4]
 8004658:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800465c:	b002      	add	sp, #8
 800465e:	4770      	bx	lr

08004660 <port_unlock.5937.4308>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004660:	b082      	sub	sp, #8
 8004662:	2300      	movs	r3, #0
 8004664:	9301      	str	r3, [sp, #4]
 8004666:	9b01      	ldr	r3, [sp, #4]
 8004668:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800466c:	b002      	add	sp, #8
 800466e:	4770      	bx	lr

08004670 <queue_init.5939.4305>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8004670:	b082      	sub	sp, #8
 8004672:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8004674:	9b01      	ldr	r3, [sp, #4]
 8004676:	9a01      	ldr	r2, [sp, #4]
 8004678:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800467a:	9b01      	ldr	r3, [sp, #4]
 800467c:	9a01      	ldr	r2, [sp, #4]
 800467e:	605a      	str	r2, [r3, #4]
}
 8004680:	b002      	add	sp, #8
 8004682:	4770      	bx	lr
 8004684:	f3af 8000 	nop.w
 8004688:	f3af 8000 	nop.w
 800468c:	f3af 8000 	nop.w

08004690 <queue_notempty.6017.4302>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8004690:	b082      	sub	sp, #8
 8004692:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004694:	9b01      	ldr	r3, [sp, #4]
 8004696:	681a      	ldr	r2, [r3, #0]
 8004698:	9b01      	ldr	r3, [sp, #4]
 800469a:	429a      	cmp	r2, r3
 800469c:	bf0c      	ite	eq
 800469e:	2300      	moveq	r3, #0
 80046a0:	2301      	movne	r3, #1
 80046a2:	b2db      	uxtb	r3, r3
}
 80046a4:	4618      	mov	r0, r3
 80046a6:	b002      	add	sp, #8
 80046a8:	4770      	bx	lr
 80046aa:	bf00      	nop
 80046ac:	f3af 8000 	nop.w

080046b0 <queue_prio_insert.6021.4298>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 80046b0:	b084      	sub	sp, #16
 80046b2:	9001      	str	r0, [sp, #4]
 80046b4:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 80046b6:	9b00      	ldr	r3, [sp, #0]
 80046b8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 80046ba:	9b03      	ldr	r3, [sp, #12]
 80046bc:	681b      	ldr	r3, [r3, #0]
 80046be:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80046c0:	9a03      	ldr	r2, [sp, #12]
 80046c2:	9b00      	ldr	r3, [sp, #0]
 80046c4:	429a      	cmp	r2, r3
 80046c6:	d005      	beq.n	80046d4 <queue_prio_insert.6021.4298+0x24>
 80046c8:	9b03      	ldr	r3, [sp, #12]
 80046ca:	689a      	ldr	r2, [r3, #8]
 80046cc:	9b01      	ldr	r3, [sp, #4]
 80046ce:	689b      	ldr	r3, [r3, #8]
 80046d0:	429a      	cmp	r2, r3
 80046d2:	d2f2      	bcs.n	80046ba <queue_prio_insert.6021.4298+0xa>
  tp->p_next = cp;
 80046d4:	9b01      	ldr	r3, [sp, #4]
 80046d6:	9a03      	ldr	r2, [sp, #12]
 80046d8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80046da:	9b03      	ldr	r3, [sp, #12]
 80046dc:	685a      	ldr	r2, [r3, #4]
 80046de:	9b01      	ldr	r3, [sp, #4]
 80046e0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80046e2:	9b01      	ldr	r3, [sp, #4]
 80046e4:	685b      	ldr	r3, [r3, #4]
 80046e6:	9a01      	ldr	r2, [sp, #4]
 80046e8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80046ea:	9b03      	ldr	r3, [sp, #12]
 80046ec:	9a01      	ldr	r2, [sp, #4]
 80046ee:	605a      	str	r2, [r3, #4]
}
 80046f0:	b004      	add	sp, #16
 80046f2:	4770      	bx	lr
 80046f4:	f3af 8000 	nop.w
 80046f8:	f3af 8000 	nop.w
 80046fc:	f3af 8000 	nop.w

08004700 <queue_fifo_remove.6025.4295>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8004700:	b084      	sub	sp, #16
 8004702:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8004704:	9b01      	ldr	r3, [sp, #4]
 8004706:	681b      	ldr	r3, [r3, #0]
 8004708:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800470a:	9b03      	ldr	r3, [sp, #12]
 800470c:	681a      	ldr	r2, [r3, #0]
 800470e:	9b01      	ldr	r3, [sp, #4]
 8004710:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004712:	9b01      	ldr	r3, [sp, #4]
 8004714:	681b      	ldr	r3, [r3, #0]
 8004716:	9a01      	ldr	r2, [sp, #4]
 8004718:	605a      	str	r2, [r3, #4]

  return tp;
 800471a:	9b03      	ldr	r3, [sp, #12]
}
 800471c:	4618      	mov	r0, r3
 800471e:	b004      	add	sp, #16
 8004720:	4770      	bx	lr
 8004722:	bf00      	nop
 8004724:	f3af 8000 	nop.w
 8004728:	f3af 8000 	nop.w
 800472c:	f3af 8000 	nop.w

08004730 <queue_dequeue.6028.4292>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8004730:	b082      	sub	sp, #8
 8004732:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8004734:	9b01      	ldr	r3, [sp, #4]
 8004736:	685b      	ldr	r3, [r3, #4]
 8004738:	9a01      	ldr	r2, [sp, #4]
 800473a:	6812      	ldr	r2, [r2, #0]
 800473c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800473e:	9b01      	ldr	r3, [sp, #4]
 8004740:	681b      	ldr	r3, [r3, #0]
 8004742:	9a01      	ldr	r2, [sp, #4]
 8004744:	6852      	ldr	r2, [r2, #4]
 8004746:	605a      	str	r2, [r3, #4]

  return tp;
 8004748:	9b01      	ldr	r3, [sp, #4]
}
 800474a:	4618      	mov	r0, r3
 800474c:	b002      	add	sp, #8
 800474e:	4770      	bx	lr

08004750 <chSysLock.6031.4290>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004750:	b508      	push	{r3, lr}

  port_lock();
 8004752:	f7ff ff7d 	bl	8004650 <port_lock.5934.4310>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004756:	bd08      	pop	{r3, pc}
 8004758:	f3af 8000 	nop.w
 800475c:	f3af 8000 	nop.w

08004760 <chSysUnlock.6033.4288>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004760:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004762:	f7ff ff7d 	bl	8004660 <port_unlock.5937.4308>
}
 8004766:	bd08      	pop	{r3, pc}
 8004768:	f3af 8000 	nop.w
 800476c:	f3af 8000 	nop.w

08004770 <chMtxQueueNotEmptyS.6035.4285>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8004770:	b500      	push	{lr}
 8004772:	b083      	sub	sp, #12
 8004774:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->m_queue);
 8004776:	9b01      	ldr	r3, [sp, #4]
 8004778:	4618      	mov	r0, r3
 800477a:	f7ff ff89 	bl	8004690 <queue_notempty.6017.4302>
 800477e:	4603      	mov	r3, r0
}
 8004780:	4618      	mov	r0, r3
 8004782:	b003      	add	sp, #12
 8004784:	f85d fb04 	ldr.w	pc, [sp], #4
 8004788:	f3af 8000 	nop.w
 800478c:	f3af 8000 	nop.w

08004790 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004790:	b500      	push	{lr}
 8004792:	b083      	sub	sp, #12
 8004794:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8004796:	9b01      	ldr	r3, [sp, #4]
 8004798:	4618      	mov	r0, r3
 800479a:	f7ff ff69 	bl	8004670 <queue_init.5939.4305>
  mp->m_owner = NULL;
 800479e:	9b01      	ldr	r3, [sp, #4]
 80047a0:	2200      	movs	r2, #0
 80047a2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 80047a4:	b003      	add	sp, #12
 80047a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80047aa:	bf00      	nop
 80047ac:	f3af 8000 	nop.w

080047b0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80047b0:	b500      	push	{lr}
 80047b2:	b083      	sub	sp, #12
 80047b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80047b6:	f7ff ffcb 	bl	8004750 <chSysLock.6031.4290>
  chMtxLockS(mp);
 80047ba:	9801      	ldr	r0, [sp, #4]
 80047bc:	f000 f808 	bl	80047d0 <chMtxLockS.4276>
  chSysUnlock();
 80047c0:	f7ff ffce 	bl	8004760 <chSysUnlock.6033.4288>
}
 80047c4:	b003      	add	sp, #12
 80047c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80047ca:	bf00      	nop
 80047cc:	f3af 8000 	nop.w

080047d0 <chMtxLockS.4276>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80047d0:	b500      	push	{lr}
 80047d2:	b085      	sub	sp, #20
 80047d4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80047d6:	4b2d      	ldr	r3, [pc, #180]	; (800488c <chMtxLockS.4276+0xbc>)
 80047d8:	699b      	ldr	r3, [r3, #24]
 80047da:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80047dc:	9b01      	ldr	r3, [sp, #4]
 80047de:	689b      	ldr	r3, [r3, #8]
 80047e0:	2b00      	cmp	r3, #0
 80047e2:	d045      	beq.n	8004870 <chMtxLockS.4276+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 80047e4:	9b01      	ldr	r3, [sp, #4]
 80047e6:	689b      	ldr	r3, [r3, #8]
 80047e8:	9303      	str	r3, [sp, #12]
 80047ea:	e02f      	b.n	800484c <chMtxLockS.4276+0x7c>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 80047ec:	9b02      	ldr	r3, [sp, #8]
 80047ee:	689a      	ldr	r2, [r3, #8]
 80047f0:	9b03      	ldr	r3, [sp, #12]
 80047f2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80047f4:	9b03      	ldr	r3, [sp, #12]
 80047f6:	f893 3020 	ldrb.w	r3, [r3, #32]
 80047fa:	2b06      	cmp	r3, #6
 80047fc:	d004      	beq.n	8004808 <chMtxLockS.4276+0x38>
 80047fe:	2b07      	cmp	r3, #7
 8004800:	d011      	beq.n	8004826 <chMtxLockS.4276+0x56>
 8004802:	2b00      	cmp	r3, #0
 8004804:	d01a      	beq.n	800483c <chMtxLockS.4276+0x6c>
 8004806:	e027      	b.n	8004858 <chMtxLockS.4276+0x88>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8004808:	9803      	ldr	r0, [sp, #12]
 800480a:	f7ff ff91 	bl	8004730 <queue_dequeue.6028.4292>
 800480e:	4602      	mov	r2, r0
 8004810:	9b03      	ldr	r3, [sp, #12]
 8004812:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004814:	4610      	mov	r0, r2
 8004816:	4619      	mov	r1, r3
 8004818:	f7ff ff4a 	bl	80046b0 <queue_prio_insert.6021.4298>
          tp = tp->p_u.wtmtxp->m_owner;
 800481c:	9b03      	ldr	r3, [sp, #12]
 800481e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004820:	689b      	ldr	r3, [r3, #8]
 8004822:	9303      	str	r3, [sp, #12]
 8004824:	e012      	b.n	800484c <chMtxLockS.4276+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8004826:	9803      	ldr	r0, [sp, #12]
 8004828:	f7ff ff82 	bl	8004730 <queue_dequeue.6028.4292>
 800482c:	4602      	mov	r2, r0
 800482e:	9b03      	ldr	r3, [sp, #12]
 8004830:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004832:	4610      	mov	r0, r2
 8004834:	4619      	mov	r1, r3
 8004836:	f7ff ff3b 	bl	80046b0 <queue_prio_insert.6021.4298>
 800483a:	e00d      	b.n	8004858 <chMtxLockS.4276+0x88>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800483c:	9803      	ldr	r0, [sp, #12]
 800483e:	f7ff ff77 	bl	8004730 <queue_dequeue.6028.4292>
 8004842:	4603      	mov	r3, r0
 8004844:	4618      	mov	r0, r3
 8004846:	f000 fd93 	bl	8005370 <chSchReadyI>
 800484a:	e005      	b.n	8004858 <chMtxLockS.4276+0x88>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800484c:	9b03      	ldr	r3, [sp, #12]
 800484e:	689a      	ldr	r2, [r3, #8]
 8004850:	9b02      	ldr	r3, [sp, #8]
 8004852:	689b      	ldr	r3, [r3, #8]
 8004854:	429a      	cmp	r2, r3
 8004856:	d3c9      	bcc.n	80047ec <chMtxLockS.4276+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8004858:	9b01      	ldr	r3, [sp, #4]
 800485a:	9802      	ldr	r0, [sp, #8]
 800485c:	4619      	mov	r1, r3
 800485e:	f7ff ff27 	bl	80046b0 <queue_prio_insert.6021.4298>
      ctp->p_u.wtmtxp = mp;
 8004862:	9b02      	ldr	r3, [sp, #8]
 8004864:	9a01      	ldr	r2, [sp, #4]
 8004866:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8004868:	2006      	movs	r0, #6
 800486a:	f000 fda9 	bl	80053c0 <chSchGoSleepS>
 800486e:	e009      	b.n	8004884 <chMtxLockS.4276+0xb4>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8004870:	9b01      	ldr	r3, [sp, #4]
 8004872:	9a02      	ldr	r2, [sp, #8]
 8004874:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8004876:	9b02      	ldr	r3, [sp, #8]
 8004878:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800487a:	9b01      	ldr	r3, [sp, #4]
 800487c:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 800487e:	9b02      	ldr	r3, [sp, #8]
 8004880:	9a01      	ldr	r2, [sp, #4]
 8004882:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8004884:	b005      	add	sp, #20
 8004886:	f85d fb04 	ldr.w	pc, [sp], #4
 800488a:	bf00      	nop
 800488c:	20000958 	.word	0x20000958

08004890 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8004890:	b500      	push	{lr}
 8004892:	b087      	sub	sp, #28
 8004894:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8004896:	4b26      	ldr	r3, [pc, #152]	; (8004930 <chMtxUnlock+0xa0>)
 8004898:	699b      	ldr	r3, [r3, #24]
 800489a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 800489c:	f7ff ff58 	bl	8004750 <chSysLock.6031.4290>
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80048a0:	9b01      	ldr	r3, [sp, #4]
 80048a2:	68da      	ldr	r2, [r3, #12]
 80048a4:	9b03      	ldr	r3, [sp, #12]
 80048a6:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80048a8:	9801      	ldr	r0, [sp, #4]
 80048aa:	f7ff ff61 	bl	8004770 <chMtxQueueNotEmptyS.6035.4285>
 80048ae:	4603      	mov	r3, r0
 80048b0:	2b00      	cmp	r3, #0
 80048b2:	d034      	beq.n	800491e <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 80048b4:	9b03      	ldr	r3, [sp, #12]
 80048b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80048b8:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 80048ba:	9b03      	ldr	r3, [sp, #12]
 80048bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80048be:	9305      	str	r3, [sp, #20]
 80048c0:	e012      	b.n	80048e8 <chMtxUnlock+0x58>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80048c2:	9805      	ldr	r0, [sp, #20]
 80048c4:	f7ff ff54 	bl	8004770 <chMtxQueueNotEmptyS.6035.4285>
 80048c8:	4603      	mov	r3, r0
 80048ca:	2b00      	cmp	r3, #0
 80048cc:	d009      	beq.n	80048e2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80048ce:	9b05      	ldr	r3, [sp, #20]
 80048d0:	681b      	ldr	r3, [r3, #0]
 80048d2:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80048d4:	9b04      	ldr	r3, [sp, #16]
 80048d6:	429a      	cmp	r2, r3
 80048d8:	d903      	bls.n	80048e2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 80048da:	9b05      	ldr	r3, [sp, #20]
 80048dc:	681b      	ldr	r3, [r3, #0]
 80048de:	689b      	ldr	r3, [r3, #8]
 80048e0:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 80048e2:	9b05      	ldr	r3, [sp, #20]
 80048e4:	68db      	ldr	r3, [r3, #12]
 80048e6:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80048e8:	9b05      	ldr	r3, [sp, #20]
 80048ea:	2b00      	cmp	r3, #0
 80048ec:	d1e9      	bne.n	80048c2 <chMtxUnlock+0x32>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80048ee:	9b03      	ldr	r3, [sp, #12]
 80048f0:	9a04      	ldr	r2, [sp, #16]
 80048f2:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 80048f4:	9b01      	ldr	r3, [sp, #4]
 80048f6:	4618      	mov	r0, r3
 80048f8:	f7ff ff02 	bl	8004700 <queue_fifo_remove.6025.4295>
 80048fc:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 80048fe:	9b01      	ldr	r3, [sp, #4]
 8004900:	9a02      	ldr	r2, [sp, #8]
 8004902:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8004904:	9b02      	ldr	r3, [sp, #8]
 8004906:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004908:	9b01      	ldr	r3, [sp, #4]
 800490a:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 800490c:	9b02      	ldr	r3, [sp, #8]
 800490e:	9a01      	ldr	r2, [sp, #4]
 8004910:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004912:	9802      	ldr	r0, [sp, #8]
 8004914:	f000 fd2c 	bl	8005370 <chSchReadyI>
      chSchRescheduleS();
 8004918:	f000 fe3a 	bl	8005590 <chSchRescheduleS>
 800491c:	e002      	b.n	8004924 <chMtxUnlock+0x94>
    }
    else {
      mp->m_owner = NULL;
 800491e:	9b01      	ldr	r3, [sp, #4]
 8004920:	2200      	movs	r2, #0
 8004922:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8004924:	f7ff ff1c 	bl	8004760 <chSysUnlock.6033.4288>
}
 8004928:	b007      	add	sp, #28
 800492a:	f85d fb04 	ldr.w	pc, [sp], #4
 800492e:	bf00      	nop
 8004930:	20000958 	.word	0x20000958
 8004934:	f3af 8000 	nop.w
 8004938:	f3af 8000 	nop.w
 800493c:	f3af 8000 	nop.w

08004940 <port_lock.6320.4199>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004940:	b082      	sub	sp, #8
 8004942:	2320      	movs	r3, #32
 8004944:	9301      	str	r3, [sp, #4]
 8004946:	9b01      	ldr	r3, [sp, #4]
 8004948:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800494c:	b002      	add	sp, #8
 800494e:	4770      	bx	lr

08004950 <port_unlock.6323.4197>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004950:	b082      	sub	sp, #8
 8004952:	2300      	movs	r3, #0
 8004954:	9301      	str	r3, [sp, #4]
 8004956:	9b01      	ldr	r3, [sp, #4]
 8004958:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800495c:	b002      	add	sp, #8
 800495e:	4770      	bx	lr

08004960 <chSysLock.6325.4195>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004960:	b508      	push	{r3, lr}

  port_lock();
 8004962:	f7ff ffed 	bl	8004940 <port_lock.6320.4199>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004966:	bd08      	pop	{r3, pc}
 8004968:	f3af 8000 	nop.w
 800496c:	f3af 8000 	nop.w

08004970 <chSysUnlock.6327.4193>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004970:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004972:	f7ff ffed 	bl	8004950 <port_unlock.6323.4197>
}
 8004976:	bd08      	pop	{r3, pc}
 8004978:	f3af 8000 	nop.w
 800497c:	f3af 8000 	nop.w

08004980 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8004980:	b500      	push	{lr}
 8004982:	b085      	sub	sp, #20
 8004984:	9003      	str	r0, [sp, #12]
 8004986:	9102      	str	r1, [sp, #8]
 8004988:	9201      	str	r2, [sp, #4]
 800498a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800498c:	f7ff ffe8 	bl	8004960 <chSysLock.6325.4195>
  elp->el_next     = esp->es_next;
 8004990:	9b03      	ldr	r3, [sp, #12]
 8004992:	681a      	ldr	r2, [r3, #0]
 8004994:	9b02      	ldr	r3, [sp, #8]
 8004996:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 8004998:	9b03      	ldr	r3, [sp, #12]
 800499a:	9a02      	ldr	r2, [sp, #8]
 800499c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800499e:	4b09      	ldr	r3, [pc, #36]	; (80049c4 <chEvtRegisterMaskWithFlags+0x44>)
 80049a0:	699a      	ldr	r2, [r3, #24]
 80049a2:	9b02      	ldr	r3, [sp, #8]
 80049a4:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 80049a6:	9b02      	ldr	r3, [sp, #8]
 80049a8:	9a01      	ldr	r2, [sp, #4]
 80049aa:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 80049ac:	9b02      	ldr	r3, [sp, #8]
 80049ae:	2200      	movs	r2, #0
 80049b0:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 80049b2:	9b02      	ldr	r3, [sp, #8]
 80049b4:	9a00      	ldr	r2, [sp, #0]
 80049b6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 80049b8:	f7ff ffda 	bl	8004970 <chSysUnlock.6327.4193>
}
 80049bc:	b005      	add	sp, #20
 80049be:	f85d fb04 	ldr.w	pc, [sp], #4
 80049c2:	bf00      	nop
 80049c4:	20000958 	.word	0x20000958
 80049c8:	f3af 8000 	nop.w
 80049cc:	f3af 8000 	nop.w

080049d0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80049d0:	b500      	push	{lr}
 80049d2:	b085      	sub	sp, #20
 80049d4:	9001      	str	r0, [sp, #4]
 80049d6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 80049d8:	9b01      	ldr	r3, [sp, #4]
 80049da:	681b      	ldr	r3, [r3, #0]
 80049dc:	9303      	str	r3, [sp, #12]
 80049de:	e01a      	b.n	8004a16 <chEvtBroadcastFlagsI+0x46>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 80049e0:	9b03      	ldr	r3, [sp, #12]
 80049e2:	68da      	ldr	r2, [r3, #12]
 80049e4:	9b00      	ldr	r3, [sp, #0]
 80049e6:	431a      	orrs	r2, r3
 80049e8:	9b03      	ldr	r3, [sp, #12]
 80049ea:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80049ec:	9b00      	ldr	r3, [sp, #0]
 80049ee:	2b00      	cmp	r3, #0
 80049f0:	d006      	beq.n	8004a00 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80049f2:	9b03      	ldr	r3, [sp, #12]
 80049f4:	68da      	ldr	r2, [r3, #12]
 80049f6:	9b03      	ldr	r3, [sp, #12]
 80049f8:	691b      	ldr	r3, [r3, #16]
 80049fa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80049fc:	2b00      	cmp	r3, #0
 80049fe:	d007      	beq.n	8004a10 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8004a00:	9b03      	ldr	r3, [sp, #12]
 8004a02:	685a      	ldr	r2, [r3, #4]
 8004a04:	9b03      	ldr	r3, [sp, #12]
 8004a06:	689b      	ldr	r3, [r3, #8]
 8004a08:	4610      	mov	r0, r2
 8004a0a:	4619      	mov	r1, r3
 8004a0c:	f000 f810 	bl	8004a30 <chEvtSignalI.4162>
    }
    elp = elp->el_next;
 8004a10:	9b03      	ldr	r3, [sp, #12]
 8004a12:	681b      	ldr	r3, [r3, #0]
 8004a14:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8004a16:	9a03      	ldr	r2, [sp, #12]
 8004a18:	9b01      	ldr	r3, [sp, #4]
 8004a1a:	429a      	cmp	r2, r3
 8004a1c:	d1e0      	bne.n	80049e0 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8004a1e:	b005      	add	sp, #20
 8004a20:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a24:	f3af 8000 	nop.w
 8004a28:	f3af 8000 	nop.w
 8004a2c:	f3af 8000 	nop.w

08004a30 <chEvtSignalI.4162>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8004a30:	b500      	push	{lr}
 8004a32:	b083      	sub	sp, #12
 8004a34:	9001      	str	r0, [sp, #4]
 8004a36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8004a38:	9b01      	ldr	r3, [sp, #4]
 8004a3a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004a3c:	9b00      	ldr	r3, [sp, #0]
 8004a3e:	431a      	orrs	r2, r3
 8004a40:	9b01      	ldr	r3, [sp, #4]
 8004a42:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8004a44:	9b01      	ldr	r3, [sp, #4]
 8004a46:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004a4a:	2b0a      	cmp	r3, #10
 8004a4c:	d106      	bne.n	8004a5c <chEvtSignalI.4162+0x2c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8004a4e:	9b01      	ldr	r3, [sp, #4]
 8004a50:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004a52:	9b01      	ldr	r3, [sp, #4]
 8004a54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004a56:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8004a58:	2b00      	cmp	r3, #0
 8004a5a:	d10d      	bne.n	8004a78 <chEvtSignalI.4162+0x48>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8004a5c:	9b01      	ldr	r3, [sp, #4]
 8004a5e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8004a62:	2b0b      	cmp	r3, #11
 8004a64:	d10e      	bne.n	8004a84 <chEvtSignalI.4162+0x54>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8004a66:	9b01      	ldr	r3, [sp, #4]
 8004a68:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004a6a:	9b01      	ldr	r3, [sp, #4]
 8004a6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004a6e:	401a      	ands	r2, r3
 8004a70:	9b01      	ldr	r3, [sp, #4]
 8004a72:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8004a74:	429a      	cmp	r2, r3
 8004a76:	d105      	bne.n	8004a84 <chEvtSignalI.4162+0x54>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8004a78:	9b01      	ldr	r3, [sp, #4]
 8004a7a:	2200      	movs	r2, #0
 8004a7c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004a7e:	9801      	ldr	r0, [sp, #4]
 8004a80:	f000 fc76 	bl	8005370 <chSchReadyI>
  }
}
 8004a84:	b003      	add	sp, #12
 8004a86:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a8a:	bf00      	nop
 8004a8c:	f3af 8000 	nop.w

08004a90 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8004a90:	b500      	push	{lr}
 8004a92:	b085      	sub	sp, #20
 8004a94:	9001      	str	r0, [sp, #4]
 8004a96:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8004a98:	2300      	movs	r3, #0
 8004a9a:	9303      	str	r3, [sp, #12]
 8004a9c:	e019      	b.n	8004ad2 <chEvtDispatch+0x42>
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004a9e:	9a00      	ldr	r2, [sp, #0]
 8004aa0:	9b03      	ldr	r3, [sp, #12]
 8004aa2:	fa22 f303 	lsr.w	r3, r2, r3
 8004aa6:	f003 0301 	and.w	r3, r3, #1
 8004aaa:	2b00      	cmp	r3, #0
 8004aac:	d00e      	beq.n	8004acc <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8004aae:	2201      	movs	r2, #1
 8004ab0:	9b03      	ldr	r3, [sp, #12]
 8004ab2:	fa02 f303 	lsl.w	r3, r2, r3
 8004ab6:	43db      	mvns	r3, r3
 8004ab8:	9a00      	ldr	r2, [sp, #0]
 8004aba:	4013      	ands	r3, r2
 8004abc:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 8004abe:	9b03      	ldr	r3, [sp, #12]
 8004ac0:	009b      	lsls	r3, r3, #2
 8004ac2:	9a01      	ldr	r2, [sp, #4]
 8004ac4:	4413      	add	r3, r2
 8004ac6:	681b      	ldr	r3, [r3, #0]
 8004ac8:	9803      	ldr	r0, [sp, #12]
 8004aca:	4798      	blx	r3
    }
    eid++;
 8004acc:	9b03      	ldr	r3, [sp, #12]
 8004ace:	3301      	adds	r3, #1
 8004ad0:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8004ad2:	9b00      	ldr	r3, [sp, #0]
 8004ad4:	2b00      	cmp	r3, #0
 8004ad6:	d1e2      	bne.n	8004a9e <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8004ad8:	b005      	add	sp, #20
 8004ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ade:	bf00      	nop

08004ae0 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8004ae0:	b500      	push	{lr}
 8004ae2:	b085      	sub	sp, #20
 8004ae4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8004ae6:	4b15      	ldr	r3, [pc, #84]	; (8004b3c <chEvtWaitOne+0x5c>)
 8004ae8:	699b      	ldr	r3, [r3, #24]
 8004aea:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 8004aec:	f7ff ff38 	bl	8004960 <chSysLock.6325.4195>
  m = ctp->p_epending & events;
 8004af0:	9b02      	ldr	r3, [sp, #8]
 8004af2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004af4:	9b01      	ldr	r3, [sp, #4]
 8004af6:	4013      	ands	r3, r2
 8004af8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 8004afa:	9b03      	ldr	r3, [sp, #12]
 8004afc:	2b00      	cmp	r3, #0
 8004afe:	d10a      	bne.n	8004b16 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8004b00:	9b02      	ldr	r3, [sp, #8]
 8004b02:	9a01      	ldr	r2, [sp, #4]
 8004b04:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8004b06:	200a      	movs	r0, #10
 8004b08:	f000 fc5a 	bl	80053c0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 8004b0c:	9b02      	ldr	r3, [sp, #8]
 8004b0e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004b10:	9b01      	ldr	r3, [sp, #4]
 8004b12:	4013      	ands	r3, r2
 8004b14:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8004b16:	9b03      	ldr	r3, [sp, #12]
 8004b18:	425b      	negs	r3, r3
 8004b1a:	9a03      	ldr	r2, [sp, #12]
 8004b1c:	4013      	ands	r3, r2
 8004b1e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8004b20:	9b02      	ldr	r3, [sp, #8]
 8004b22:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004b24:	9b03      	ldr	r3, [sp, #12]
 8004b26:	43db      	mvns	r3, r3
 8004b28:	401a      	ands	r2, r3
 8004b2a:	9b02      	ldr	r3, [sp, #8]
 8004b2c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8004b2e:	f7ff ff1f 	bl	8004970 <chSysUnlock.6327.4193>

  return m;
 8004b32:	9b03      	ldr	r3, [sp, #12]
}
 8004b34:	4618      	mov	r0, r3
 8004b36:	b005      	add	sp, #20
 8004b38:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b3c:	20000958 	.word	0x20000958

08004b40 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8004b40:	4770      	bx	lr
 8004b42:	bf00      	nop
 8004b44:	f3af 8000 	nop.w
 8004b48:	f3af 8000 	nop.w
 8004b4c:	f3af 8000 	nop.w

08004b50 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8004b50:	4770      	bx	lr
 8004b52:	bf00      	nop
 8004b54:	f3af 8000 	nop.w
 8004b58:	f3af 8000 	nop.w
 8004b5c:	f3af 8000 	nop.w

08004b60 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8004b60:	e7fe      	b.n	8004b60 <__default_exit>
 8004b62:	bf00      	nop
 8004b64:	f3af 8000 	nop.w
 8004b68:	f3af 8000 	nop.w
 8004b6c:	f3af 8000 	nop.w

08004b70 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8004b70:	b084      	sub	sp, #16
  const ram_init_area_t *rap = ram_areas;
 8004b72:	4b16      	ldr	r3, [pc, #88]	; (8004bcc <__init_ram_areas+0x5c>)
 8004b74:	9303      	str	r3, [sp, #12]

#if CRT1_AREAS_NUMBER > 0
  do {
    uint32_t *tp = rap->init_text_area;
 8004b76:	9b03      	ldr	r3, [sp, #12]
 8004b78:	681b      	ldr	r3, [r3, #0]
 8004b7a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8004b7c:	9b03      	ldr	r3, [sp, #12]
 8004b7e:	685b      	ldr	r3, [r3, #4]
 8004b80:	9301      	str	r3, [sp, #4]
 8004b82:	e009      	b.n	8004b98 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8004b84:	9b02      	ldr	r3, [sp, #8]
 8004b86:	681a      	ldr	r2, [r3, #0]
 8004b88:	9b01      	ldr	r3, [sp, #4]
 8004b8a:	601a      	str	r2, [r3, #0]
      p++;
 8004b8c:	9b01      	ldr	r3, [sp, #4]
 8004b8e:	3304      	adds	r3, #4
 8004b90:	9301      	str	r3, [sp, #4]
      tp++;
 8004b92:	9b02      	ldr	r3, [sp, #8]
 8004b94:	3304      	adds	r3, #4
 8004b96:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8004b98:	9b03      	ldr	r3, [sp, #12]
 8004b9a:	689a      	ldr	r2, [r3, #8]
 8004b9c:	9b01      	ldr	r3, [sp, #4]
 8004b9e:	429a      	cmp	r2, r3
 8004ba0:	d8f0      	bhi.n	8004b84 <__init_ram_areas+0x14>
 8004ba2:	e005      	b.n	8004bb0 <__init_ram_areas+0x40>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8004ba4:	9b01      	ldr	r3, [sp, #4]
 8004ba6:	2200      	movs	r2, #0
 8004ba8:	601a      	str	r2, [r3, #0]
      p++;
 8004baa:	9b01      	ldr	r3, [sp, #4]
 8004bac:	3304      	adds	r3, #4
 8004bae:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8004bb0:	9b03      	ldr	r3, [sp, #12]
 8004bb2:	68da      	ldr	r2, [r3, #12]
 8004bb4:	9b01      	ldr	r3, [sp, #4]
 8004bb6:	429a      	cmp	r2, r3
 8004bb8:	d8f4      	bhi.n	8004ba4 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 8004bba:	9b03      	ldr	r3, [sp, #12]
 8004bbc:	3310      	adds	r3, #16
 8004bbe:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8004bc0:	9a03      	ldr	r2, [sp, #12]
 8004bc2:	4b03      	ldr	r3, [pc, #12]	; (8004bd0 <__init_ram_areas+0x60>)
 8004bc4:	429a      	cmp	r2, r3
 8004bc6:	d3d6      	bcc.n	8004b76 <__init_ram_areas+0x6>
#endif
}
 8004bc8:	b004      	add	sp, #16
 8004bca:	4770      	bx	lr
 8004bcc:	08006810 	.word	0x08006810
 8004bd0:	08006890 	.word	0x08006890
 8004bd4:	f3af 8000 	nop.w
 8004bd8:	f3af 8000 	nop.w
 8004bdc:	f3af 8000 	nop.w

08004be0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8004be0:	e7fe      	b.n	8004be0 <BusFault_Handler>
 8004be2:	bf00      	nop
 8004be4:	f3af 8000 	nop.w
 8004be8:	f3af 8000 	nop.w
 8004bec:	f3af 8000 	nop.w

08004bf0 <NVIC_SetPriorityGrouping.4196.4441>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004bf0:	b084      	sub	sp, #16
 8004bf2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004bf4:	9b01      	ldr	r3, [sp, #4]
 8004bf6:	f003 0307 	and.w	r3, r3, #7
 8004bfa:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004bfc:	4b0a      	ldr	r3, [pc, #40]	; (8004c28 <NVIC_SetPriorityGrouping.4196.4441+0x38>)
 8004bfe:	68db      	ldr	r3, [r3, #12]
 8004c00:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8004c02:	9a02      	ldr	r2, [sp, #8]
 8004c04:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8004c08:	4013      	ands	r3, r2
 8004c0a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 8004c0c:	9b03      	ldr	r3, [sp, #12]
 8004c0e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004c10:	9b02      	ldr	r3, [sp, #8]
 8004c12:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8004c14:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8004c18:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004c1c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8004c1e:	4b02      	ldr	r3, [pc, #8]	; (8004c28 <NVIC_SetPriorityGrouping.4196.4441+0x38>)
 8004c20:	9a02      	ldr	r2, [sp, #8]
 8004c22:	60da      	str	r2, [r3, #12]
}
 8004c24:	b004      	add	sp, #16
 8004c26:	4770      	bx	lr
 8004c28:	e000ed00 	.word	0xe000ed00
 8004c2c:	f3af 8000 	nop.w

08004c30 <NVIC_SetPriority.4202.4435>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004c30:	b082      	sub	sp, #8
 8004c32:	4603      	mov	r3, r0
 8004c34:	9100      	str	r1, [sp, #0]
 8004c36:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 8004c3a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004c3e:	2b00      	cmp	r3, #0
 8004c40:	da0c      	bge.n	8004c5c <NVIC_SetPriority.4202.4435+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004c42:	490c      	ldr	r1, [pc, #48]	; (8004c74 <NVIC_SetPriority.4202.4435+0x44>)
 8004c44:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004c48:	f003 030f 	and.w	r3, r3, #15
 8004c4c:	3b04      	subs	r3, #4
 8004c4e:	9a00      	ldr	r2, [sp, #0]
 8004c50:	b2d2      	uxtb	r2, r2
 8004c52:	0112      	lsls	r2, r2, #4
 8004c54:	b2d2      	uxtb	r2, r2
 8004c56:	440b      	add	r3, r1
 8004c58:	761a      	strb	r2, [r3, #24]
 8004c5a:	e009      	b.n	8004c70 <NVIC_SetPriority.4202.4435+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004c5c:	4906      	ldr	r1, [pc, #24]	; (8004c78 <NVIC_SetPriority.4202.4435+0x48>)
 8004c5e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004c62:	9a00      	ldr	r2, [sp, #0]
 8004c64:	b2d2      	uxtb	r2, r2
 8004c66:	0112      	lsls	r2, r2, #4
 8004c68:	b2d2      	uxtb	r2, r2
 8004c6a:	440b      	add	r3, r1
 8004c6c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8004c70:	b002      	add	sp, #8
 8004c72:	4770      	bx	lr
 8004c74:	e000ed00 	.word	0xe000ed00
 8004c78:	e000e100 	.word	0xe000e100
 8004c7c:	f3af 8000 	nop.w

08004c80 <port_init.4208.4433>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8004c80:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8004c82:	4b0e      	ldr	r3, [pc, #56]	; (8004cbc <port_init.4208.4433+0x3c>)
 8004c84:	2200      	movs	r2, #0
 8004c86:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004c88:	2003      	movs	r0, #3
 8004c8a:	f7ff ffb1 	bl	8004bf0 <NVIC_SetPriorityGrouping.4196.4441>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004c8e:	4b0c      	ldr	r3, [pc, #48]	; (8004cc0 <port_init.4208.4433+0x40>)
 8004c90:	4a0b      	ldr	r2, [pc, #44]	; (8004cc0 <port_init.4208.4433+0x40>)
 8004c92:	68d2      	ldr	r2, [r2, #12]
 8004c94:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8004c98:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004c9a:	4b0a      	ldr	r3, [pc, #40]	; (8004cc4 <port_init.4208.4433+0x44>)
 8004c9c:	4a09      	ldr	r2, [pc, #36]	; (8004cc4 <port_init.4208.4433+0x44>)
 8004c9e:	6812      	ldr	r2, [r2, #0]
 8004ca0:	f042 0201 	orr.w	r2, r2, #1
 8004ca4:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004ca6:	f06f 0004 	mvn.w	r0, #4
 8004caa:	2101      	movs	r1, #1
 8004cac:	f7ff ffc0 	bl	8004c30 <NVIC_SetPriority.4202.4435>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004cb0:	f06f 0001 	mvn.w	r0, #1
 8004cb4:	2102      	movs	r1, #2
 8004cb6:	f7ff ffbb 	bl	8004c30 <NVIC_SetPriority.4202.4435>
}
 8004cba:	bd08      	pop	{r3, pc}
 8004cbc:	e000ed00 	.word	0xe000ed00
 8004cc0:	e000edf0 	.word	0xe000edf0
 8004cc4:	e0001000 	.word	0xe0001000
 8004cc8:	f3af 8000 	nop.w
 8004ccc:	f3af 8000 	nop.w

08004cd0 <port_lock.4219.4424>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004cd0:	b082      	sub	sp, #8
 8004cd2:	2320      	movs	r3, #32
 8004cd4:	9301      	str	r3, [sp, #4]
 8004cd6:	9b01      	ldr	r3, [sp, #4]
 8004cd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004cdc:	b002      	add	sp, #8
 8004cde:	4770      	bx	lr

08004ce0 <port_unlock.4221.4422>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004ce0:	b082      	sub	sp, #8
 8004ce2:	2300      	movs	r3, #0
 8004ce4:	9301      	str	r3, [sp, #4]
 8004ce6:	9b01      	ldr	r3, [sp, #4]
 8004ce8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004cec:	b002      	add	sp, #8
 8004cee:	4770      	bx	lr

08004cf0 <port_lock_from_isr.4223.4420>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004cf0:	b508      	push	{r3, lr}

  port_lock();
 8004cf2:	f7ff ffed 	bl	8004cd0 <port_lock.4219.4424>
}
 8004cf6:	bd08      	pop	{r3, pc}
 8004cf8:	f3af 8000 	nop.w
 8004cfc:	f3af 8000 	nop.w

08004d00 <port_unlock_from_isr.4225.4418>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004d00:	b508      	push	{r3, lr}

  port_unlock();
 8004d02:	f7ff ffed 	bl	8004ce0 <port_unlock.4221.4422>
}
 8004d06:	bd08      	pop	{r3, pc}
 8004d08:	f3af 8000 	nop.w
 8004d0c:	f3af 8000 	nop.w

08004d10 <port_disable.4227.4416>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d10:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8004d12:	4770      	bx	lr
 8004d14:	f3af 8000 	nop.w
 8004d18:	f3af 8000 	nop.w
 8004d1c:	f3af 8000 	nop.w

08004d20 <port_enable.4229.4414>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8004d20:	b082      	sub	sp, #8
 8004d22:	2300      	movs	r3, #0
 8004d24:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004d26:	9b01      	ldr	r3, [sp, #4]
 8004d28:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d2c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 8004d2e:	b002      	add	sp, #8
 8004d30:	4770      	bx	lr
 8004d32:	bf00      	nop
 8004d34:	f3af 8000 	nop.w
 8004d38:	f3af 8000 	nop.w
 8004d3c:	f3af 8000 	nop.w

08004d40 <port_wait_for_interrupt.4231.4412>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8004d40:	4770      	bx	lr
 8004d42:	bf00      	nop
 8004d44:	f3af 8000 	nop.w
 8004d48:	f3af 8000 	nop.w
 8004d4c:	f3af 8000 	nop.w

08004d50 <st_lld_get_counter.4236.4408>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004d50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004d54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004d56:	4618      	mov	r0, r3
 8004d58:	4770      	bx	lr
 8004d5a:	bf00      	nop
 8004d5c:	f3af 8000 	nop.w

08004d60 <port_timer_stop_alarm.4336.4406>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8004d60:	b508      	push	{r3, lr}

  stStopAlarm();
 8004d62:	f7ff fb85 	bl	8004470 <stStopAlarm>
}
 8004d66:	bd08      	pop	{r3, pc}
 8004d68:	f3af 8000 	nop.w
 8004d6c:	f3af 8000 	nop.w

08004d70 <port_timer_set_alarm.4338.4403>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8004d70:	b500      	push	{lr}
 8004d72:	b083      	sub	sp, #12
 8004d74:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8004d76:	9801      	ldr	r0, [sp, #4]
 8004d78:	f7ff fb82 	bl	8004480 <stSetAlarm>
}
 8004d7c:	b003      	add	sp, #12
 8004d7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d82:	bf00      	nop
 8004d84:	f3af 8000 	nop.w
 8004d88:	f3af 8000 	nop.w
 8004d8c:	f3af 8000 	nop.w

08004d90 <port_timer_get_time.4239.4401>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8004d90:	b508      	push	{r3, lr}

  return stGetCounter();
 8004d92:	f7ff ffdd 	bl	8004d50 <st_lld_get_counter.4236.4408>
 8004d96:	4603      	mov	r3, r0
}
 8004d98:	4618      	mov	r0, r3
 8004d9a:	bd08      	pop	{r3, pc}
 8004d9c:	f3af 8000 	nop.w

08004da0 <chSysEnable.4241.4399>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8004da0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8004da2:	f7ff ffbd 	bl	8004d20 <port_enable.4229.4414>
}
 8004da6:	bd08      	pop	{r3, pc}
 8004da8:	f3af 8000 	nop.w
 8004dac:	f3af 8000 	nop.w

08004db0 <chSysLockFromISR.4247.4393>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8004db0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8004db2:	f7ff ff9d 	bl	8004cf0 <port_lock_from_isr.4223.4420>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8004db6:	bd08      	pop	{r3, pc}
 8004db8:	f3af 8000 	nop.w
 8004dbc:	f3af 8000 	nop.w

08004dc0 <chSysUnlockFromISR.4249.4391>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8004dc0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8004dc2:	f7ff ff9d 	bl	8004d00 <port_unlock_from_isr.4225.4418>
}
 8004dc6:	bd08      	pop	{r3, pc}
 8004dc8:	f3af 8000 	nop.w
 8004dcc:	f3af 8000 	nop.w

08004dd0 <chVTGetSystemTimeX.4251.4389>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8004dd0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8004dd2:	f7ff ffdd 	bl	8004d90 <port_timer_get_time.4239.4401>
 8004dd6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004dd8:	4618      	mov	r0, r3
 8004dda:	bd08      	pop	{r3, pc}
 8004ddc:	f3af 8000 	nop.w

08004de0 <chVTDoTickI.4341.4387>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8004de0:	b500      	push	{lr}
 8004de2:	b085      	sub	sp, #20
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8004de4:	4b2a      	ldr	r3, [pc, #168]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004de6:	69db      	ldr	r3, [r3, #28]
 8004de8:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8004dea:	f7ff fff1 	bl	8004dd0 <chVTGetSystemTimeX.4251.4389>
 8004dee:	9002      	str	r0, [sp, #8]
 8004df0:	e02a      	b.n	8004e48 <chVTDoTickI.4341.4387+0x68>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8004df2:	4b27      	ldr	r3, [pc, #156]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004df4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004df6:	9b03      	ldr	r3, [sp, #12]
 8004df8:	689b      	ldr	r3, [r3, #8]
 8004dfa:	441a      	add	r2, r3
 8004dfc:	4b24      	ldr	r3, [pc, #144]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004dfe:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8004e00:	9b03      	ldr	r3, [sp, #12]
 8004e02:	681b      	ldr	r3, [r3, #0]
 8004e04:	4a23      	ldr	r2, [pc, #140]	; (8004e94 <chVTDoTickI.4341.4387+0xb4>)
 8004e06:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8004e08:	9b03      	ldr	r3, [sp, #12]
 8004e0a:	681a      	ldr	r2, [r3, #0]
 8004e0c:	4b20      	ldr	r3, [pc, #128]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e0e:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 8004e10:	9b03      	ldr	r3, [sp, #12]
 8004e12:	68db      	ldr	r3, [r3, #12]
 8004e14:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 8004e16:	9b03      	ldr	r3, [sp, #12]
 8004e18:	2200      	movs	r2, #0
 8004e1a:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8004e1c:	4b1c      	ldr	r3, [pc, #112]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e1e:	69da      	ldr	r2, [r3, #28]
 8004e20:	4b1c      	ldr	r3, [pc, #112]	; (8004e94 <chVTDoTickI.4341.4387+0xb4>)
 8004e22:	429a      	cmp	r2, r3
 8004e24:	d101      	bne.n	8004e2a <chVTDoTickI.4341.4387+0x4a>
      port_timer_stop_alarm();
 8004e26:	f7ff ff9b 	bl	8004d60 <port_timer_stop_alarm.4336.4406>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8004e2a:	f7ff ffc9 	bl	8004dc0 <chSysUnlockFromISR.4249.4391>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8004e2e:	9b03      	ldr	r3, [sp, #12]
 8004e30:	691a      	ldr	r2, [r3, #16]
 8004e32:	9b00      	ldr	r3, [sp, #0]
 8004e34:	4610      	mov	r0, r2
 8004e36:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8004e38:	f7ff ffba 	bl	8004db0 <chSysLockFromISR.4247.4393>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8004e3c:	4b14      	ldr	r3, [pc, #80]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e3e:	69db      	ldr	r3, [r3, #28]
 8004e40:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8004e42:	f7ff ffc5 	bl	8004dd0 <chVTGetSystemTimeX.4251.4389>
 8004e46:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8004e48:	9b03      	ldr	r3, [sp, #12]
 8004e4a:	689a      	ldr	r2, [r3, #8]
 8004e4c:	4b10      	ldr	r3, [pc, #64]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e50:	9902      	ldr	r1, [sp, #8]
 8004e52:	1acb      	subs	r3, r1, r3
 8004e54:	429a      	cmp	r2, r3
 8004e56:	d9cc      	bls.n	8004df2 <chVTDoTickI.4341.4387+0x12>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8004e58:	4b0d      	ldr	r3, [pc, #52]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e5a:	69da      	ldr	r2, [r3, #28]
 8004e5c:	4b0d      	ldr	r3, [pc, #52]	; (8004e94 <chVTDoTickI.4341.4387+0xb4>)
 8004e5e:	429a      	cmp	r2, r3
 8004e60:	d012      	beq.n	8004e88 <chVTDoTickI.4341.4387+0xa8>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8004e62:	4b0b      	ldr	r3, [pc, #44]	; (8004e90 <chVTDoTickI.4341.4387+0xb0>)
 8004e64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004e66:	9b03      	ldr	r3, [sp, #12]
 8004e68:	689b      	ldr	r3, [r3, #8]
 8004e6a:	441a      	add	r2, r3
 8004e6c:	9b02      	ldr	r3, [sp, #8]
 8004e6e:	1ad3      	subs	r3, r2, r3
 8004e70:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004e72:	9b01      	ldr	r3, [sp, #4]
 8004e74:	2b01      	cmp	r3, #1
 8004e76:	d801      	bhi.n	8004e7c <chVTDoTickI.4341.4387+0x9c>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004e78:	2302      	movs	r3, #2
 8004e7a:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8004e7c:	9a02      	ldr	r2, [sp, #8]
 8004e7e:	9b01      	ldr	r3, [sp, #4]
 8004e80:	4413      	add	r3, r2
 8004e82:	4618      	mov	r0, r3
 8004e84:	f7ff ff74 	bl	8004d70 <port_timer_set_alarm.4338.4403>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004e88:	b005      	add	sp, #20
 8004e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e8e:	bf00      	nop
 8004e90:	20000958 	.word	0x20000958
 8004e94:	20000974 	.word	0x20000974
 8004e98:	f3af 8000 	nop.w
 8004e9c:	f3af 8000 	nop.w

08004ea0 <chRegSetThreadName.4253.4384>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004ea0:	b082      	sub	sp, #8
 8004ea2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8004ea4:	4b02      	ldr	r3, [pc, #8]	; (8004eb0 <chRegSetThreadName.4253.4384+0x10>)
 8004ea6:	699b      	ldr	r3, [r3, #24]
 8004ea8:	9a01      	ldr	r2, [sp, #4]
 8004eaa:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8004eac:	b002      	add	sp, #8
 8004eae:	4770      	bx	lr
 8004eb0:	20000958 	.word	0x20000958
 8004eb4:	f3af 8000 	nop.w
 8004eb8:	f3af 8000 	nop.w
 8004ebc:	f3af 8000 	nop.w

08004ec0 <chRegSetThreadNameX.4257.4380>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8004ec0:	b082      	sub	sp, #8
 8004ec2:	9001      	str	r0, [sp, #4]
 8004ec4:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8004ec6:	9b01      	ldr	r3, [sp, #4]
 8004ec8:	9a00      	ldr	r2, [sp, #0]
 8004eca:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 8004ecc:	b002      	add	sp, #8
 8004ece:	4770      	bx	lr

08004ed0 <_idle_thread.4333.4377>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8004ed0:	b500      	push	{lr}
 8004ed2:	b083      	sub	sp, #12
 8004ed4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8004ed6:	f7ff ff33 	bl	8004d40 <port_wait_for_interrupt.4231.4412>
 8004eda:	e7fc      	b.n	8004ed6 <_idle_thread.4333.4377+0x6>
 8004edc:	f3af 8000 	nop.w

08004ee0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8004ee0:	b500      	push	{lr}
 8004ee2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8004ee4:	f7ff fecc 	bl	8004c80 <port_init.4208.4433>
  _scheduler_init();
 8004ee8:	f000 fa32 	bl	8005350 <_scheduler_init.4286>
  _vt_init();
 8004eec:	f000 f898 	bl	8005020 <_vt_init.4337>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8004ef0:	f000 fe56 	bl	8005ba0 <_tm_init.4013>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8004ef4:	f7ff f86c 	bl	8003fd0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8004ef8:	f7ff f8ba 	bl	8004070 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8004efc:	4812      	ldr	r0, [pc, #72]	; (8004f48 <chSysInit+0x68>)
 8004efe:	2140      	movs	r1, #64	; 0x40
 8004f00:	f000 fc96 	bl	8005830 <_thread_init.4191>
 8004f04:	4602      	mov	r2, r0
 8004f06:	4b11      	ldr	r3, [pc, #68]	; (8004f4c <chSysInit+0x6c>)
 8004f08:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8004f0a:	4b10      	ldr	r3, [pc, #64]	; (8004f4c <chSysInit+0x6c>)
 8004f0c:	699b      	ldr	r3, [r3, #24]
 8004f0e:	2201      	movs	r2, #1
 8004f10:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8004f14:	4b0d      	ldr	r3, [pc, #52]	; (8004f4c <chSysInit+0x6c>)
 8004f16:	699b      	ldr	r3, [r3, #24]
 8004f18:	4a0d      	ldr	r2, [pc, #52]	; (8004f50 <chSysInit+0x70>)
 8004f1a:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
 8004f1c:	f7ff ff40 	bl	8004da0 <chSysEnable.4241.4399>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 8004f20:	480c      	ldr	r0, [pc, #48]	; (8004f54 <chSysInit+0x74>)
 8004f22:	f7ff ffbd 	bl	8004ea0 <chRegSetThreadName.4253.4384>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8004f26:	2300      	movs	r3, #0
 8004f28:	9300      	str	r3, [sp, #0]
 8004f2a:	480b      	ldr	r0, [pc, #44]	; (8004f58 <chSysInit+0x78>)
 8004f2c:	21d8      	movs	r1, #216	; 0xd8
 8004f2e:	2201      	movs	r2, #1
 8004f30:	4b0a      	ldr	r3, [pc, #40]	; (8004f5c <chSysInit+0x7c>)
 8004f32:	f000 fced 	bl	8005910 <chThdCreateStatic>
 8004f36:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 8004f38:	9803      	ldr	r0, [sp, #12]
 8004f3a:	4909      	ldr	r1, [pc, #36]	; (8004f60 <chSysInit+0x80>)
 8004f3c:	f7ff ffc0 	bl	8004ec0 <chRegSetThreadNameX.4257.4380>
  }
#endif
}
 8004f40:	b005      	add	sp, #20
 8004f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f46:	bf00      	nop
 8004f48:	20000988 	.word	0x20000988
 8004f4c:	20000958 	.word	0x20000958
 8004f50:	20000400 	.word	0x20000400
 8004f54:	08006890 	.word	0x08006890
 8004f58:	200009d0 	.word	0x200009d0
 8004f5c:	08004ed1 	.word	0x08004ed1
 8004f60:	080067f0 	.word	0x080067f0
 8004f64:	f3af 8000 	nop.w
 8004f68:	f3af 8000 	nop.w
 8004f6c:	f3af 8000 	nop.w

08004f70 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8004f70:	b500      	push	{lr}
 8004f72:	b083      	sub	sp, #12
 8004f74:	9001      	str	r0, [sp, #4]

  port_disable();
 8004f76:	f7ff fecb 	bl	8004d10 <port_disable.4227.4416>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8004f7a:	4b02      	ldr	r3, [pc, #8]	; (8004f84 <chSysHalt+0x14>)
 8004f7c:	9a01      	ldr	r2, [sp, #4]
 8004f7e:	62da      	str	r2, [r3, #44]	; 0x2c
 8004f80:	e7fe      	b.n	8004f80 <chSysHalt+0x10>
 8004f82:	bf00      	nop
 8004f84:	20000958 	.word	0x20000958
 8004f88:	f3af 8000 	nop.w
 8004f8c:	f3af 8000 	nop.w

08004f90 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8004f90:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8004f92:	f7ff ff25 	bl	8004de0 <chVTDoTickI.4341.4387>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8004f96:	bd08      	pop	{r3, pc}
 8004f98:	f3af 8000 	nop.w
 8004f9c:	f3af 8000 	nop.w

08004fa0 <st_lld_get_counter.4556.4351>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004fa0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004fa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004fa6:	4618      	mov	r0, r3
 8004fa8:	4770      	bx	lr
 8004faa:	bf00      	nop
 8004fac:	f3af 8000 	nop.w

08004fb0 <port_timer_start_alarm.4566.4348>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8004fb0:	b500      	push	{lr}
 8004fb2:	b083      	sub	sp, #12
 8004fb4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8004fb6:	9801      	ldr	r0, [sp, #4]
 8004fb8:	f7ff fa4a 	bl	8004450 <stStartAlarm>
}
 8004fbc:	b003      	add	sp, #12
 8004fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fc2:	bf00      	nop
 8004fc4:	f3af 8000 	nop.w
 8004fc8:	f3af 8000 	nop.w
 8004fcc:	f3af 8000 	nop.w

08004fd0 <port_timer_stop_alarm.4572.4346>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8004fd0:	b508      	push	{r3, lr}

  stStopAlarm();
 8004fd2:	f7ff fa4d 	bl	8004470 <stStopAlarm>
}
 8004fd6:	bd08      	pop	{r3, pc}
 8004fd8:	f3af 8000 	nop.w
 8004fdc:	f3af 8000 	nop.w

08004fe0 <port_timer_set_alarm.4569.4343>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8004fe0:	b500      	push	{lr}
 8004fe2:	b083      	sub	sp, #12
 8004fe4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8004fe6:	9801      	ldr	r0, [sp, #4]
 8004fe8:	f7ff fa4a 	bl	8004480 <stSetAlarm>
}
 8004fec:	b003      	add	sp, #12
 8004fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ff2:	bf00      	nop
 8004ff4:	f3af 8000 	nop.w
 8004ff8:	f3af 8000 	nop.w
 8004ffc:	f3af 8000 	nop.w

08005000 <port_timer_get_time.4562.4341>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005000:	b508      	push	{r3, lr}

  return stGetCounter();
 8005002:	f7ff ffcd 	bl	8004fa0 <st_lld_get_counter.4556.4351>
 8005006:	4603      	mov	r3, r0
}
 8005008:	4618      	mov	r0, r3
 800500a:	bd08      	pop	{r3, pc}
 800500c:	f3af 8000 	nop.w

08005010 <chVTGetSystemTimeX.4564.4339>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005010:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005012:	f7ff fff5 	bl	8005000 <port_timer_get_time.4562.4341>
 8005016:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005018:	4618      	mov	r0, r3
 800501a:	bd08      	pop	{r3, pc}
 800501c:	f3af 8000 	nop.w

08005020 <_vt_init.4337>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8005020:	4b06      	ldr	r3, [pc, #24]	; (800503c <_vt_init.4337+0x1c>)
 8005022:	4a07      	ldr	r2, [pc, #28]	; (8005040 <_vt_init.4337+0x20>)
 8005024:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005026:	4b05      	ldr	r3, [pc, #20]	; (800503c <_vt_init.4337+0x1c>)
 8005028:	4a05      	ldr	r2, [pc, #20]	; (8005040 <_vt_init.4337+0x20>)
 800502a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800502c:	4b03      	ldr	r3, [pc, #12]	; (800503c <_vt_init.4337+0x1c>)
 800502e:	f04f 32ff 	mov.w	r2, #4294967295
 8005032:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8005034:	4b01      	ldr	r3, [pc, #4]	; (800503c <_vt_init.4337+0x1c>)
 8005036:	2200      	movs	r2, #0
 8005038:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800503a:	4770      	bx	lr
 800503c:	20000958 	.word	0x20000958
 8005040:	20000974 	.word	0x20000974
 8005044:	f3af 8000 	nop.w
 8005048:	f3af 8000 	nop.w
 800504c:	f3af 8000 	nop.w

08005050 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8005050:	b500      	push	{lr}
 8005052:	b089      	sub	sp, #36	; 0x24
 8005054:	9003      	str	r0, [sp, #12]
 8005056:	9102      	str	r1, [sp, #8]
 8005058:	9201      	str	r2, [sp, #4]
 800505a:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800505c:	9b03      	ldr	r3, [sp, #12]
 800505e:	9a00      	ldr	r2, [sp, #0]
 8005060:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8005062:	9b03      	ldr	r3, [sp, #12]
 8005064:	9a01      	ldr	r2, [sp, #4]
 8005066:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8005068:	f7ff ffd2 	bl	8005010 <chVTGetSystemTimeX.4564.4339>
 800506c:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800506e:	9b02      	ldr	r3, [sp, #8]
 8005070:	2b01      	cmp	r3, #1
 8005072:	d801      	bhi.n	8005078 <chVTDoSetI+0x28>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005074:	2302      	movs	r3, #2
 8005076:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8005078:	4b31      	ldr	r3, [pc, #196]	; (8005140 <chVTDoSetI+0xf0>)
 800507a:	69da      	ldr	r2, [r3, #28]
 800507c:	4b31      	ldr	r3, [pc, #196]	; (8005144 <chVTDoSetI+0xf4>)
 800507e:	429a      	cmp	r2, r3
 8005080:	d119      	bne.n	80050b6 <chVTDoSetI+0x66>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8005082:	4b2f      	ldr	r3, [pc, #188]	; (8005140 <chVTDoSetI+0xf0>)
 8005084:	9a05      	ldr	r2, [sp, #20]
 8005086:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8005088:	4b2d      	ldr	r3, [pc, #180]	; (8005140 <chVTDoSetI+0xf0>)
 800508a:	9a03      	ldr	r2, [sp, #12]
 800508c:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 800508e:	4b2c      	ldr	r3, [pc, #176]	; (8005140 <chVTDoSetI+0xf0>)
 8005090:	9a03      	ldr	r2, [sp, #12]
 8005092:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8005094:	9b03      	ldr	r3, [sp, #12]
 8005096:	4a2b      	ldr	r2, [pc, #172]	; (8005144 <chVTDoSetI+0xf4>)
 8005098:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800509a:	9b03      	ldr	r3, [sp, #12]
 800509c:	4a29      	ldr	r2, [pc, #164]	; (8005144 <chVTDoSetI+0xf4>)
 800509e:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 80050a0:	9b03      	ldr	r3, [sp, #12]
 80050a2:	9a02      	ldr	r2, [sp, #8]
 80050a4:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 80050a6:	4b26      	ldr	r3, [pc, #152]	; (8005140 <chVTDoSetI+0xf0>)
 80050a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80050aa:	9b02      	ldr	r3, [sp, #8]
 80050ac:	4413      	add	r3, r2
 80050ae:	4618      	mov	r0, r3
 80050b0:	f7ff ff7e 	bl	8004fb0 <port_timer_start_alarm.4566.4348>
 80050b4:	e040      	b.n	8005138 <chVTDoSetI+0xe8>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80050b6:	9a05      	ldr	r2, [sp, #20]
 80050b8:	9b02      	ldr	r3, [sp, #8]
 80050ba:	441a      	add	r2, r3
 80050bc:	4b20      	ldr	r3, [pc, #128]	; (8005140 <chVTDoSetI+0xf0>)
 80050be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80050c0:	1ad3      	subs	r3, r2, r3
 80050c2:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80050c4:	4b1e      	ldr	r3, [pc, #120]	; (8005140 <chVTDoSetI+0xf0>)
 80050c6:	69db      	ldr	r3, [r3, #28]
 80050c8:	689a      	ldr	r2, [r3, #8]
 80050ca:	9b06      	ldr	r3, [sp, #24]
 80050cc:	429a      	cmp	r2, r3
 80050ce:	d906      	bls.n	80050de <chVTDoSetI+0x8e>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 80050d0:	4b1b      	ldr	r3, [pc, #108]	; (8005140 <chVTDoSetI+0xf0>)
 80050d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80050d4:	9b06      	ldr	r3, [sp, #24]
 80050d6:	4413      	add	r3, r2
 80050d8:	4618      	mov	r0, r3
 80050da:	f7ff ff81 	bl	8004fe0 <port_timer_set_alarm.4569.4343>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 80050de:	4b18      	ldr	r3, [pc, #96]	; (8005140 <chVTDoSetI+0xf0>)
 80050e0:	69db      	ldr	r3, [r3, #28]
 80050e2:	9307      	str	r3, [sp, #28]
 80050e4:	e007      	b.n	80050f6 <chVTDoSetI+0xa6>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80050e6:	9b07      	ldr	r3, [sp, #28]
 80050e8:	689b      	ldr	r3, [r3, #8]
 80050ea:	9a06      	ldr	r2, [sp, #24]
 80050ec:	1ad3      	subs	r3, r2, r3
 80050ee:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 80050f0:	9b07      	ldr	r3, [sp, #28]
 80050f2:	681b      	ldr	r3, [r3, #0]
 80050f4:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80050f6:	9b07      	ldr	r3, [sp, #28]
 80050f8:	689a      	ldr	r2, [r3, #8]
 80050fa:	9b06      	ldr	r3, [sp, #24]
 80050fc:	429a      	cmp	r2, r3
 80050fe:	d3f2      	bcc.n	80050e6 <chVTDoSetI+0x96>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8005100:	9b03      	ldr	r3, [sp, #12]
 8005102:	9a07      	ldr	r2, [sp, #28]
 8005104:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8005106:	9b03      	ldr	r3, [sp, #12]
 8005108:	681b      	ldr	r3, [r3, #0]
 800510a:	685a      	ldr	r2, [r3, #4]
 800510c:	9b03      	ldr	r3, [sp, #12]
 800510e:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 8005110:	9b03      	ldr	r3, [sp, #12]
 8005112:	685b      	ldr	r3, [r3, #4]
 8005114:	9a03      	ldr	r2, [sp, #12]
 8005116:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8005118:	9b07      	ldr	r3, [sp, #28]
 800511a:	9a03      	ldr	r2, [sp, #12]
 800511c:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 800511e:	9b03      	ldr	r3, [sp, #12]
 8005120:	9a06      	ldr	r2, [sp, #24]
 8005122:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8005124:	9b07      	ldr	r3, [sp, #28]
 8005126:	689a      	ldr	r2, [r3, #8]
 8005128:	9b06      	ldr	r3, [sp, #24]
 800512a:	1ad2      	subs	r2, r2, r3
 800512c:	9b07      	ldr	r3, [sp, #28]
 800512e:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8005130:	4b03      	ldr	r3, [pc, #12]	; (8005140 <chVTDoSetI+0xf0>)
 8005132:	f04f 32ff 	mov.w	r2, #4294967295
 8005136:	625a      	str	r2, [r3, #36]	; 0x24
}
 8005138:	b009      	add	sp, #36	; 0x24
 800513a:	f85d fb04 	ldr.w	pc, [sp], #4
 800513e:	bf00      	nop
 8005140:	20000958 	.word	0x20000958
 8005144:	20000974 	.word	0x20000974
 8005148:	f3af 8000 	nop.w
 800514c:	f3af 8000 	nop.w

08005150 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8005150:	b500      	push	{lr}
 8005152:	b085      	sub	sp, #20
 8005154:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8005156:	4b30      	ldr	r3, [pc, #192]	; (8005218 <chVTDoResetI+0xc8>)
 8005158:	69da      	ldr	r2, [r3, #28]
 800515a:	9b01      	ldr	r3, [sp, #4]
 800515c:	429a      	cmp	r2, r3
 800515e:	d01b      	beq.n	8005198 <chVTDoResetI+0x48>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8005160:	9b01      	ldr	r3, [sp, #4]
 8005162:	685b      	ldr	r3, [r3, #4]
 8005164:	9a01      	ldr	r2, [sp, #4]
 8005166:	6812      	ldr	r2, [r2, #0]
 8005168:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800516a:	9b01      	ldr	r3, [sp, #4]
 800516c:	681b      	ldr	r3, [r3, #0]
 800516e:	9a01      	ldr	r2, [sp, #4]
 8005170:	6852      	ldr	r2, [r2, #4]
 8005172:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8005174:	9b01      	ldr	r3, [sp, #4]
 8005176:	2200      	movs	r2, #0
 8005178:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800517a:	9b01      	ldr	r3, [sp, #4]
 800517c:	681a      	ldr	r2, [r3, #0]
 800517e:	4b27      	ldr	r3, [pc, #156]	; (800521c <chVTDoResetI+0xcc>)
 8005180:	429a      	cmp	r2, r3
 8005182:	d046      	beq.n	8005212 <chVTDoResetI+0xc2>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8005184:	9b01      	ldr	r3, [sp, #4]
 8005186:	681b      	ldr	r3, [r3, #0]
 8005188:	9a01      	ldr	r2, [sp, #4]
 800518a:	6812      	ldr	r2, [r2, #0]
 800518c:	6891      	ldr	r1, [r2, #8]
 800518e:	9a01      	ldr	r2, [sp, #4]
 8005190:	6892      	ldr	r2, [r2, #8]
 8005192:	440a      	add	r2, r1
 8005194:	609a      	str	r2, [r3, #8]
 8005196:	e03c      	b.n	8005212 <chVTDoResetI+0xc2>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8005198:	9b01      	ldr	r3, [sp, #4]
 800519a:	681a      	ldr	r2, [r3, #0]
 800519c:	4b1e      	ldr	r3, [pc, #120]	; (8005218 <chVTDoResetI+0xc8>)
 800519e:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80051a0:	4b1d      	ldr	r3, [pc, #116]	; (8005218 <chVTDoResetI+0xc8>)
 80051a2:	69db      	ldr	r3, [r3, #28]
 80051a4:	4a1d      	ldr	r2, [pc, #116]	; (800521c <chVTDoResetI+0xcc>)
 80051a6:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 80051a8:	9b01      	ldr	r3, [sp, #4]
 80051aa:	2200      	movs	r2, #0
 80051ac:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80051ae:	4b1a      	ldr	r3, [pc, #104]	; (8005218 <chVTDoResetI+0xc8>)
 80051b0:	69da      	ldr	r2, [r3, #28]
 80051b2:	4b1a      	ldr	r3, [pc, #104]	; (800521c <chVTDoResetI+0xcc>)
 80051b4:	429a      	cmp	r2, r3
 80051b6:	d102      	bne.n	80051be <chVTDoResetI+0x6e>
    port_timer_stop_alarm();
 80051b8:	f7ff ff0a 	bl	8004fd0 <port_timer_stop_alarm.4572.4346>
 80051bc:	e029      	b.n	8005212 <chVTDoResetI+0xc2>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80051be:	4b16      	ldr	r3, [pc, #88]	; (8005218 <chVTDoResetI+0xc8>)
 80051c0:	69db      	ldr	r3, [r3, #28]
 80051c2:	4a15      	ldr	r2, [pc, #84]	; (8005218 <chVTDoResetI+0xc8>)
 80051c4:	69d2      	ldr	r2, [r2, #28]
 80051c6:	6891      	ldr	r1, [r2, #8]
 80051c8:	9a01      	ldr	r2, [sp, #4]
 80051ca:	6892      	ldr	r2, [r2, #8]
 80051cc:	440a      	add	r2, r1
 80051ce:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80051d0:	f7ff ff1e 	bl	8005010 <chVTGetSystemTimeX.4564.4339>
 80051d4:	4602      	mov	r2, r0
 80051d6:	4b10      	ldr	r3, [pc, #64]	; (8005218 <chVTDoResetI+0xc8>)
 80051d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80051da:	1ad3      	subs	r3, r2, r3
 80051dc:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80051de:	4b0e      	ldr	r3, [pc, #56]	; (8005218 <chVTDoResetI+0xc8>)
 80051e0:	69db      	ldr	r3, [r3, #28]
 80051e2:	689a      	ldr	r2, [r3, #8]
 80051e4:	9b02      	ldr	r3, [sp, #8]
 80051e6:	429a      	cmp	r2, r3
 80051e8:	d913      	bls.n	8005212 <chVTDoResetI+0xc2>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80051ea:	4b0b      	ldr	r3, [pc, #44]	; (8005218 <chVTDoResetI+0xc8>)
 80051ec:	69db      	ldr	r3, [r3, #28]
 80051ee:	689a      	ldr	r2, [r3, #8]
 80051f0:	9b02      	ldr	r3, [sp, #8]
 80051f2:	1ad3      	subs	r3, r2, r3
 80051f4:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80051f6:	9b03      	ldr	r3, [sp, #12]
 80051f8:	2b01      	cmp	r3, #1
 80051fa:	d801      	bhi.n	8005200 <chVTDoResetI+0xb0>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80051fc:	2302      	movs	r3, #2
 80051fe:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8005200:	4b05      	ldr	r3, [pc, #20]	; (8005218 <chVTDoResetI+0xc8>)
 8005202:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005204:	9b02      	ldr	r3, [sp, #8]
 8005206:	441a      	add	r2, r3
 8005208:	9b03      	ldr	r3, [sp, #12]
 800520a:	4413      	add	r3, r2
 800520c:	4618      	mov	r0, r3
 800520e:	f7ff fee7 	bl	8004fe0 <port_timer_set_alarm.4569.4343>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005212:	b005      	add	sp, #20
 8005214:	f85d fb04 	ldr.w	pc, [sp], #4
 8005218:	20000958 	.word	0x20000958
 800521c:	20000974 	.word	0x20000974

08005220 <port_lock.4728.4325>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005220:	b082      	sub	sp, #8
 8005222:	2320      	movs	r3, #32
 8005224:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005226:	9b01      	ldr	r3, [sp, #4]
 8005228:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800522c:	b002      	add	sp, #8
 800522e:	4770      	bx	lr

08005230 <port_unlock.4731.4323>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005230:	b082      	sub	sp, #8
 8005232:	2300      	movs	r3, #0
 8005234:	9301      	str	r3, [sp, #4]
 8005236:	9b01      	ldr	r3, [sp, #4]
 8005238:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800523c:	b002      	add	sp, #8
 800523e:	4770      	bx	lr

08005240 <port_lock_from_isr.4733.4321>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8005240:	b508      	push	{r3, lr}

  port_lock();
 8005242:	f7ff ffed 	bl	8005220 <port_lock.4728.4325>
}
 8005246:	bd08      	pop	{r3, pc}
 8005248:	f3af 8000 	nop.w
 800524c:	f3af 8000 	nop.w

08005250 <port_unlock_from_isr.4735.4319>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8005250:	b508      	push	{r3, lr}

  port_unlock();
 8005252:	f7ff ffed 	bl	8005230 <port_unlock.4731.4323>
}
 8005256:	bd08      	pop	{r3, pc}
 8005258:	f3af 8000 	nop.w
 800525c:	f3af 8000 	nop.w

08005260 <queue_init.4737.4316>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8005260:	b082      	sub	sp, #8
 8005262:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8005264:	9b01      	ldr	r3, [sp, #4]
 8005266:	9a01      	ldr	r2, [sp, #4]
 8005268:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800526a:	9b01      	ldr	r3, [sp, #4]
 800526c:	9a01      	ldr	r2, [sp, #4]
 800526e:	605a      	str	r2, [r3, #4]
}
 8005270:	b002      	add	sp, #8
 8005272:	4770      	bx	lr
 8005274:	f3af 8000 	nop.w
 8005278:	f3af 8000 	nop.w
 800527c:	f3af 8000 	nop.w

08005280 <queue_fifo_remove.4815.4313>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8005280:	b084      	sub	sp, #16
 8005282:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8005284:	9b01      	ldr	r3, [sp, #4]
 8005286:	681b      	ldr	r3, [r3, #0]
 8005288:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800528a:	9b03      	ldr	r3, [sp, #12]
 800528c:	681a      	ldr	r2, [r3, #0]
 800528e:	9b01      	ldr	r3, [sp, #4]
 8005290:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005292:	9b01      	ldr	r3, [sp, #4]
 8005294:	681b      	ldr	r3, [r3, #0]
 8005296:	9a01      	ldr	r2, [sp, #4]
 8005298:	605a      	str	r2, [r3, #4]

  return tp;
 800529a:	9b03      	ldr	r3, [sp, #12]
}
 800529c:	4618      	mov	r0, r3
 800529e:	b004      	add	sp, #16
 80052a0:	4770      	bx	lr
 80052a2:	bf00      	nop
 80052a4:	f3af 8000 	nop.w
 80052a8:	f3af 8000 	nop.w
 80052ac:	f3af 8000 	nop.w

080052b0 <queue_dequeue.4818.4310>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 80052b0:	b082      	sub	sp, #8
 80052b2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 80052b4:	9b01      	ldr	r3, [sp, #4]
 80052b6:	685b      	ldr	r3, [r3, #4]
 80052b8:	9a01      	ldr	r2, [sp, #4]
 80052ba:	6812      	ldr	r2, [r2, #0]
 80052bc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80052be:	9b01      	ldr	r3, [sp, #4]
 80052c0:	681b      	ldr	r3, [r3, #0]
 80052c2:	9a01      	ldr	r2, [sp, #4]
 80052c4:	6852      	ldr	r2, [r2, #4]
 80052c6:	605a      	str	r2, [r3, #4]

  return tp;
 80052c8:	9b01      	ldr	r3, [sp, #4]
}
 80052ca:	4618      	mov	r0, r3
 80052cc:	b002      	add	sp, #8
 80052ce:	4770      	bx	lr

080052d0 <chSchIsRescRequiredI.4821.4308>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 80052d0:	4b06      	ldr	r3, [pc, #24]	; (80052ec <chSchIsRescRequiredI.4821.4308+0x1c>)
 80052d2:	681b      	ldr	r3, [r3, #0]
 80052d4:	689a      	ldr	r2, [r3, #8]
 80052d6:	4b05      	ldr	r3, [pc, #20]	; (80052ec <chSchIsRescRequiredI.4821.4308+0x1c>)
 80052d8:	699b      	ldr	r3, [r3, #24]
 80052da:	689b      	ldr	r3, [r3, #8]
 80052dc:	429a      	cmp	r2, r3
 80052de:	bf94      	ite	ls
 80052e0:	2300      	movls	r3, #0
 80052e2:	2301      	movhi	r3, #1
 80052e4:	b2db      	uxtb	r3, r3
}
 80052e6:	4618      	mov	r0, r3
 80052e8:	4770      	bx	lr
 80052ea:	bf00      	nop
 80052ec:	20000958 	.word	0x20000958

080052f0 <chSysLockFromISR.4824.4306>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80052f0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80052f2:	f7ff ffa5 	bl	8005240 <port_lock_from_isr.4733.4321>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80052f6:	bd08      	pop	{r3, pc}
 80052f8:	f3af 8000 	nop.w
 80052fc:	f3af 8000 	nop.w

08005300 <chSysUnlockFromISR.4826.4304>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8005300:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8005302:	f7ff ffa5 	bl	8005250 <port_unlock_from_isr.4735.4319>
}
 8005306:	bd08      	pop	{r3, pc}
 8005308:	f3af 8000 	nop.w
 800530c:	f3af 8000 	nop.w

08005310 <chVTIsArmedI.4828.4293>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8005310:	b082      	sub	sp, #8
 8005312:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8005314:	9b01      	ldr	r3, [sp, #4]
 8005316:	68db      	ldr	r3, [r3, #12]
 8005318:	2b00      	cmp	r3, #0
 800531a:	bf0c      	ite	eq
 800531c:	2300      	moveq	r3, #0
 800531e:	2301      	movne	r3, #1
 8005320:	b2db      	uxtb	r3, r3
}
 8005322:	4618      	mov	r0, r3
 8005324:	b002      	add	sp, #8
 8005326:	4770      	bx	lr
 8005328:	f3af 8000 	nop.w
 800532c:	f3af 8000 	nop.w

08005330 <chSemFastSignalI.4840.4288>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8005330:	b082      	sub	sp, #8
 8005332:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8005334:	9b01      	ldr	r3, [sp, #4]
 8005336:	689b      	ldr	r3, [r3, #8]
 8005338:	1c5a      	adds	r2, r3, #1
 800533a:	9b01      	ldr	r3, [sp, #4]
 800533c:	609a      	str	r2, [r3, #8]
}
 800533e:	b002      	add	sp, #8
 8005340:	4770      	bx	lr
 8005342:	bf00      	nop
 8005344:	f3af 8000 	nop.w
 8005348:	f3af 8000 	nop.w
 800534c:	f3af 8000 	nop.w

08005350 <_scheduler_init.4286>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8005350:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8005352:	4806      	ldr	r0, [pc, #24]	; (800536c <_scheduler_init.4286+0x1c>)
 8005354:	f7ff ff84 	bl	8005260 <queue_init.4737.4316>
  ch.rlist.r_prio = NOPRIO;
 8005358:	4b04      	ldr	r3, [pc, #16]	; (800536c <_scheduler_init.4286+0x1c>)
 800535a:	2200      	movs	r2, #0
 800535c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800535e:	4b03      	ldr	r3, [pc, #12]	; (800536c <_scheduler_init.4286+0x1c>)
 8005360:	4a02      	ldr	r2, [pc, #8]	; (800536c <_scheduler_init.4286+0x1c>)
 8005362:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8005364:	4b01      	ldr	r3, [pc, #4]	; (800536c <_scheduler_init.4286+0x1c>)
 8005366:	4a01      	ldr	r2, [pc, #4]	; (800536c <_scheduler_init.4286+0x1c>)
 8005368:	615a      	str	r2, [r3, #20]
#endif
}
 800536a:	bd08      	pop	{r3, pc}
 800536c:	20000958 	.word	0x20000958

08005370 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8005370:	b084      	sub	sp, #16
 8005372:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8005374:	9b01      	ldr	r3, [sp, #4]
 8005376:	2200      	movs	r2, #0
 8005378:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 800537c:	4b0e      	ldr	r3, [pc, #56]	; (80053b8 <chSchReadyI+0x48>)
 800537e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8005380:	9b03      	ldr	r3, [sp, #12]
 8005382:	681b      	ldr	r3, [r3, #0]
 8005384:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8005386:	9b03      	ldr	r3, [sp, #12]
 8005388:	689a      	ldr	r2, [r3, #8]
 800538a:	9b01      	ldr	r3, [sp, #4]
 800538c:	689b      	ldr	r3, [r3, #8]
 800538e:	429a      	cmp	r2, r3
 8005390:	d2f6      	bcs.n	8005380 <chSchReadyI+0x10>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8005392:	9b01      	ldr	r3, [sp, #4]
 8005394:	9a03      	ldr	r2, [sp, #12]
 8005396:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8005398:	9b03      	ldr	r3, [sp, #12]
 800539a:	685a      	ldr	r2, [r3, #4]
 800539c:	9b01      	ldr	r3, [sp, #4]
 800539e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80053a0:	9b01      	ldr	r3, [sp, #4]
 80053a2:	685b      	ldr	r3, [r3, #4]
 80053a4:	9a01      	ldr	r2, [sp, #4]
 80053a6:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80053a8:	9b03      	ldr	r3, [sp, #12]
 80053aa:	9a01      	ldr	r2, [sp, #4]
 80053ac:	605a      	str	r2, [r3, #4]

  return tp;
 80053ae:	9b01      	ldr	r3, [sp, #4]
}
 80053b0:	4618      	mov	r0, r3
 80053b2:	b004      	add	sp, #16
 80053b4:	4770      	bx	lr
 80053b6:	bf00      	nop
 80053b8:	20000958 	.word	0x20000958
 80053bc:	f3af 8000 	nop.w

080053c0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80053c0:	b510      	push	{r4, lr}
 80053c2:	b084      	sub	sp, #16
 80053c4:	4603      	mov	r3, r0
 80053c6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80053ca:	4b15      	ldr	r3, [pc, #84]	; (8005420 <chSchGoSleepS+0x60>)
 80053cc:	699b      	ldr	r3, [r3, #24]
 80053ce:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 80053d0:	9b03      	ldr	r3, [sp, #12]
 80053d2:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80053d6:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80053da:	4811      	ldr	r0, [pc, #68]	; (8005420 <chSchGoSleepS+0x60>)
 80053dc:	f7ff ff50 	bl	8005280 <queue_fifo_remove.4815.4313>
 80053e0:	4602      	mov	r2, r0
 80053e2:	4b0f      	ldr	r3, [pc, #60]	; (8005420 <chSchGoSleepS+0x60>)
 80053e4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80053e6:	4b0e      	ldr	r3, [pc, #56]	; (8005420 <chSchGoSleepS+0x60>)
 80053e8:	699b      	ldr	r3, [r3, #24]
 80053ea:	2201      	movs	r2, #1
 80053ec:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80053f0:	f3ef 8309 	mrs	r3, PSP
 80053f4:	461c      	mov	r4, r3
  return(result);
 80053f6:	4623      	mov	r3, r4
  chSysSwitch(currp, otp);
 80053f8:	9302      	str	r3, [sp, #8]
 80053fa:	9b02      	ldr	r3, [sp, #8]
 80053fc:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8005400:	9b03      	ldr	r3, [sp, #12]
 8005402:	69db      	ldr	r3, [r3, #28]
 8005404:	429a      	cmp	r2, r3
 8005406:	d202      	bcs.n	800540e <chSchGoSleepS+0x4e>
 8005408:	4806      	ldr	r0, [pc, #24]	; (8005424 <chSchGoSleepS+0x64>)
 800540a:	f7ff fdb1 	bl	8004f70 <chSysHalt>
 800540e:	4b04      	ldr	r3, [pc, #16]	; (8005420 <chSchGoSleepS+0x60>)
 8005410:	699b      	ldr	r3, [r3, #24]
 8005412:	4618      	mov	r0, r3
 8005414:	9903      	ldr	r1, [sp, #12]
 8005416:	f7fa ff63 	bl	80002e0 <_port_switch>
}
 800541a:	b004      	add	sp, #16
 800541c:	bd10      	pop	{r4, pc}
 800541e:	bf00      	nop
 8005420:	20000958 	.word	0x20000958
 8005424:	080067f8 	.word	0x080067f8
 8005428:	f3af 8000 	nop.w
 800542c:	f3af 8000 	nop.w

08005430 <wakeup.4849.4277>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8005430:	b500      	push	{lr}
 8005432:	b085      	sub	sp, #20
 8005434:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8005436:	9b01      	ldr	r3, [sp, #4]
 8005438:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800543a:	f7ff ff59 	bl	80052f0 <chSysLockFromISR.4824.4306>
  switch (tp->p_state) {
 800543e:	9b03      	ldr	r3, [sp, #12]
 8005440:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005444:	2b07      	cmp	r3, #7
 8005446:	d823      	bhi.n	8005490 <wakeup.4849.4277+0x60>
 8005448:	a201      	add	r2, pc, #4	; (adr r2, 8005450 <wakeup.4849.4277+0x20>)
 800544a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800544e:	bf00      	nop
 8005450:	08005471 	.word	0x08005471
 8005454:	08005491 	.word	0x08005491
 8005458:	08005491 	.word	0x08005491
 800545c:	08005477 	.word	0x08005477
 8005460:	0800548b 	.word	0x0800548b
 8005464:	08005481 	.word	0x08005481
 8005468:	08005491 	.word	0x08005491
 800546c:	0800548b 	.word	0x0800548b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8005470:	f7ff ff46 	bl	8005300 <chSysUnlockFromISR.4826.4304>
 8005474:	e015      	b.n	80054a2 <wakeup.4849.4277+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8005476:	9b03      	ldr	r3, [sp, #12]
 8005478:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800547a:	2200      	movs	r2, #0
 800547c:	601a      	str	r2, [r3, #0]
 800547e:	e007      	b.n	8005490 <wakeup.4849.4277+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8005480:	9b03      	ldr	r3, [sp, #12]
 8005482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005484:	4618      	mov	r0, r3
 8005486:	f7ff ff53 	bl	8005330 <chSemFastSignalI.4840.4288>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800548a:	9803      	ldr	r0, [sp, #12]
 800548c:	f7ff ff10 	bl	80052b0 <queue_dequeue.4818.4310>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8005490:	9b03      	ldr	r3, [sp, #12]
 8005492:	f04f 32ff 	mov.w	r2, #4294967295
 8005496:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8005498:	9803      	ldr	r0, [sp, #12]
 800549a:	f7ff ff69 	bl	8005370 <chSchReadyI>
  chSysUnlockFromISR();
 800549e:	f7ff ff2f 	bl	8005300 <chSysUnlockFromISR.4826.4304>
}
 80054a2:	b005      	add	sp, #20
 80054a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80054a8:	f3af 8000 	nop.w
 80054ac:	f3af 8000 	nop.w

080054b0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80054b0:	b500      	push	{lr}
 80054b2:	b089      	sub	sp, #36	; 0x24
 80054b4:	4603      	mov	r3, r0
 80054b6:	9100      	str	r1, [sp, #0]
 80054b8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80054bc:	9b00      	ldr	r3, [sp, #0]
 80054be:	f1b3 3fff 	cmp.w	r3, #4294967295
 80054c2:	d018      	beq.n	80054f6 <chSchGoSleepTimeoutS+0x46>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80054c4:	4b12      	ldr	r3, [pc, #72]	; (8005510 <chSchGoSleepTimeoutS+0x60>)
 80054c6:	699b      	ldr	r3, [r3, #24]
 80054c8:	aa03      	add	r2, sp, #12
 80054ca:	4610      	mov	r0, r2
 80054cc:	9900      	ldr	r1, [sp, #0]
 80054ce:	4a11      	ldr	r2, [pc, #68]	; (8005514 <chSchGoSleepTimeoutS+0x64>)
 80054d0:	f7ff fdbe 	bl	8005050 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80054d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80054d8:	4618      	mov	r0, r3
 80054da:	f7ff ff71 	bl	80053c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80054de:	ab03      	add	r3, sp, #12
 80054e0:	4618      	mov	r0, r3
 80054e2:	f7ff ff15 	bl	8005310 <chVTIsArmedI.4828.4293>
 80054e6:	4603      	mov	r3, r0
 80054e8:	2b00      	cmp	r3, #0
 80054ea:	d009      	beq.n	8005500 <chSchGoSleepTimeoutS+0x50>
      chVTDoResetI(&vt);
 80054ec:	ab03      	add	r3, sp, #12
 80054ee:	4618      	mov	r0, r3
 80054f0:	f7ff fe2e 	bl	8005150 <chVTDoResetI>
 80054f4:	e004      	b.n	8005500 <chSchGoSleepTimeoutS+0x50>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80054f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80054fa:	4618      	mov	r0, r3
 80054fc:	f7ff ff60 	bl	80053c0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8005500:	4b03      	ldr	r3, [pc, #12]	; (8005510 <chSchGoSleepTimeoutS+0x60>)
 8005502:	699b      	ldr	r3, [r3, #24]
 8005504:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005506:	4618      	mov	r0, r3
 8005508:	b009      	add	sp, #36	; 0x24
 800550a:	f85d fb04 	ldr.w	pc, [sp], #4
 800550e:	bf00      	nop
 8005510:	20000958 	.word	0x20000958
 8005514:	08005431 	.word	0x08005431
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005520:	b510      	push	{r4, lr}
 8005522:	b084      	sub	sp, #16
 8005524:	9001      	str	r0, [sp, #4]
 8005526:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8005528:	9b01      	ldr	r3, [sp, #4]
 800552a:	9a00      	ldr	r2, [sp, #0]
 800552c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800552e:	9b01      	ldr	r3, [sp, #4]
 8005530:	689a      	ldr	r2, [r3, #8]
 8005532:	4b15      	ldr	r3, [pc, #84]	; (8005588 <chSchWakeupS+0x68>)
 8005534:	699b      	ldr	r3, [r3, #24]
 8005536:	689b      	ldr	r3, [r3, #8]
 8005538:	429a      	cmp	r2, r3
 800553a:	d803      	bhi.n	8005544 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 800553c:	9801      	ldr	r0, [sp, #4]
 800553e:	f7ff ff17 	bl	8005370 <chSchReadyI>
 8005542:	e01f      	b.n	8005584 <chSchWakeupS+0x64>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8005544:	4b10      	ldr	r3, [pc, #64]	; (8005588 <chSchWakeupS+0x68>)
 8005546:	699b      	ldr	r3, [r3, #24]
 8005548:	4618      	mov	r0, r3
 800554a:	f7ff ff11 	bl	8005370 <chSchReadyI>
 800554e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8005550:	4b0d      	ldr	r3, [pc, #52]	; (8005588 <chSchWakeupS+0x68>)
 8005552:	9a01      	ldr	r2, [sp, #4]
 8005554:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8005556:	9b01      	ldr	r3, [sp, #4]
 8005558:	2201      	movs	r2, #1
 800555a:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800555e:	f3ef 8309 	mrs	r3, PSP
 8005562:	461c      	mov	r4, r3
  return(result);
 8005564:	4623      	mov	r3, r4
    chSysSwitch(ntp, otp);
 8005566:	9302      	str	r3, [sp, #8]
 8005568:	9b02      	ldr	r3, [sp, #8]
 800556a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800556e:	9b03      	ldr	r3, [sp, #12]
 8005570:	69db      	ldr	r3, [r3, #28]
 8005572:	429a      	cmp	r2, r3
 8005574:	d202      	bcs.n	800557c <chSchWakeupS+0x5c>
 8005576:	4805      	ldr	r0, [pc, #20]	; (800558c <chSchWakeupS+0x6c>)
 8005578:	f7ff fcfa 	bl	8004f70 <chSysHalt>
 800557c:	9801      	ldr	r0, [sp, #4]
 800557e:	9903      	ldr	r1, [sp, #12]
 8005580:	f7fa feae 	bl	80002e0 <_port_switch>
  }
}
 8005584:	b004      	add	sp, #16
 8005586:	bd10      	pop	{r4, pc}
 8005588:	20000958 	.word	0x20000958
 800558c:	080067f8 	.word	0x080067f8

08005590 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8005590:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8005592:	f7ff fe9d 	bl	80052d0 <chSchIsRescRequiredI.4821.4308>
 8005596:	4603      	mov	r3, r0
 8005598:	2b00      	cmp	r3, #0
 800559a:	d001      	beq.n	80055a0 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 800559c:	f000 f820 	bl	80055e0 <chSchDoRescheduleAhead.4261>
  }
}
 80055a0:	bd08      	pop	{r3, pc}
 80055a2:	bf00      	nop
 80055a4:	f3af 8000 	nop.w
 80055a8:	f3af 8000 	nop.w
 80055ac:	f3af 8000 	nop.w

080055b0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80055b0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80055b2:	4b09      	ldr	r3, [pc, #36]	; (80055d8 <chSchIsPreemptionRequired+0x28>)
 80055b4:	681b      	ldr	r3, [r3, #0]
 80055b6:	689b      	ldr	r3, [r3, #8]
 80055b8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 80055ba:	4b07      	ldr	r3, [pc, #28]	; (80055d8 <chSchIsPreemptionRequired+0x28>)
 80055bc:	699b      	ldr	r3, [r3, #24]
 80055be:	689b      	ldr	r3, [r3, #8]
 80055c0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80055c2:	9a01      	ldr	r2, [sp, #4]
 80055c4:	9b00      	ldr	r3, [sp, #0]
 80055c6:	429a      	cmp	r2, r3
 80055c8:	bf94      	ite	ls
 80055ca:	2300      	movls	r3, #0
 80055cc:	2301      	movhi	r3, #1
 80055ce:	b2db      	uxtb	r3, r3
#endif
}
 80055d0:	4618      	mov	r0, r3
 80055d2:	b002      	add	sp, #8
 80055d4:	4770      	bx	lr
 80055d6:	bf00      	nop
 80055d8:	20000958 	.word	0x20000958
 80055dc:	f3af 8000 	nop.w

080055e0 <chSchDoRescheduleAhead.4261>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80055e0:	b510      	push	{r4, lr}
 80055e2:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 80055e4:	4b20      	ldr	r3, [pc, #128]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 80055e6:	699b      	ldr	r3, [r3, #24]
 80055e8:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80055ea:	481f      	ldr	r0, [pc, #124]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 80055ec:	f7ff fe48 	bl	8005280 <queue_fifo_remove.4815.4313>
 80055f0:	4602      	mov	r2, r0
 80055f2:	4b1d      	ldr	r3, [pc, #116]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 80055f4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80055f6:	4b1c      	ldr	r3, [pc, #112]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 80055f8:	699b      	ldr	r3, [r3, #24]
 80055fa:	2201      	movs	r2, #1
 80055fc:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 8005600:	9b02      	ldr	r3, [sp, #8]
 8005602:	2200      	movs	r2, #0
 8005604:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8005608:	4b17      	ldr	r3, [pc, #92]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 800560a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800560c:	9b03      	ldr	r3, [sp, #12]
 800560e:	681b      	ldr	r3, [r3, #0]
 8005610:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 8005612:	9b03      	ldr	r3, [sp, #12]
 8005614:	689a      	ldr	r2, [r3, #8]
 8005616:	9b02      	ldr	r3, [sp, #8]
 8005618:	689b      	ldr	r3, [r3, #8]
 800561a:	429a      	cmp	r2, r3
 800561c:	d8f6      	bhi.n	800560c <chSchDoRescheduleAhead.4261+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800561e:	9b02      	ldr	r3, [sp, #8]
 8005620:	9a03      	ldr	r2, [sp, #12]
 8005622:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8005624:	9b03      	ldr	r3, [sp, #12]
 8005626:	685a      	ldr	r2, [r3, #4]
 8005628:	9b02      	ldr	r3, [sp, #8]
 800562a:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 800562c:	9b02      	ldr	r3, [sp, #8]
 800562e:	685b      	ldr	r3, [r3, #4]
 8005630:	9a02      	ldr	r2, [sp, #8]
 8005632:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8005634:	9b03      	ldr	r3, [sp, #12]
 8005636:	9a02      	ldr	r2, [sp, #8]
 8005638:	605a      	str	r2, [r3, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800563a:	f3ef 8309 	mrs	r3, PSP
 800563e:	461c      	mov	r4, r3
  return(result);
 8005640:	4623      	mov	r3, r4

  chSysSwitch(currp, otp);
 8005642:	9301      	str	r3, [sp, #4]
 8005644:	9b01      	ldr	r3, [sp, #4]
 8005646:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800564a:	9b02      	ldr	r3, [sp, #8]
 800564c:	69db      	ldr	r3, [r3, #28]
 800564e:	429a      	cmp	r2, r3
 8005650:	d202      	bcs.n	8005658 <chSchDoRescheduleAhead.4261+0x78>
 8005652:	4806      	ldr	r0, [pc, #24]	; (800566c <chSchDoRescheduleAhead.4261+0x8c>)
 8005654:	f7ff fc8c 	bl	8004f70 <chSysHalt>
 8005658:	4b03      	ldr	r3, [pc, #12]	; (8005668 <chSchDoRescheduleAhead.4261+0x88>)
 800565a:	699b      	ldr	r3, [r3, #24]
 800565c:	4618      	mov	r0, r3
 800565e:	9902      	ldr	r1, [sp, #8]
 8005660:	f7fa fe3e 	bl	80002e0 <_port_switch>
}
 8005664:	b004      	add	sp, #16
 8005666:	bd10      	pop	{r4, pc}
 8005668:	20000958 	.word	0x20000958
 800566c:	080067f8 	.word	0x080067f8

08005670 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8005670:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8005672:	f7ff ffb5 	bl	80055e0 <chSchDoRescheduleAhead.4261>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8005676:	bd08      	pop	{r3, pc}
 8005678:	f3af 8000 	nop.w
 800567c:	f3af 8000 	nop.w

08005680 <port_lock.4931.4256>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005680:	b082      	sub	sp, #8
 8005682:	2320      	movs	r3, #32
 8005684:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005686:	9b01      	ldr	r3, [sp, #4]
 8005688:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800568c:	b002      	add	sp, #8
 800568e:	4770      	bx	lr

08005690 <port_unlock.4934.4254>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005690:	b082      	sub	sp, #8
 8005692:	2300      	movs	r3, #0
 8005694:	9301      	str	r3, [sp, #4]
 8005696:	9b01      	ldr	r3, [sp, #4]
 8005698:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800569c:	b002      	add	sp, #8
 800569e:	4770      	bx	lr

080056a0 <list_init.4943.4247>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 80056a0:	b082      	sub	sp, #8
 80056a2:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 80056a4:	9b01      	ldr	r3, [sp, #4]
 80056a6:	9a01      	ldr	r2, [sp, #4]
 80056a8:	601a      	str	r2, [r3, #0]
}
 80056aa:	b002      	add	sp, #8
 80056ac:	4770      	bx	lr
 80056ae:	bf00      	nop

080056b0 <list_notempty.5019.4244>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 80056b0:	b082      	sub	sp, #8
 80056b2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80056b4:	9b01      	ldr	r3, [sp, #4]
 80056b6:	681a      	ldr	r2, [r3, #0]
 80056b8:	9b01      	ldr	r3, [sp, #4]
 80056ba:	429a      	cmp	r2, r3
 80056bc:	bf0c      	ite	eq
 80056be:	2300      	moveq	r3, #0
 80056c0:	2301      	movne	r3, #1
 80056c2:	b2db      	uxtb	r3, r3
}
 80056c4:	4618      	mov	r0, r3
 80056c6:	b002      	add	sp, #8
 80056c8:	4770      	bx	lr
 80056ca:	bf00      	nop
 80056cc:	f3af 8000 	nop.w

080056d0 <queue_init.5023.4241>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80056d0:	b082      	sub	sp, #8
 80056d2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80056d4:	9b01      	ldr	r3, [sp, #4]
 80056d6:	9a01      	ldr	r2, [sp, #4]
 80056d8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80056da:	9b01      	ldr	r3, [sp, #4]
 80056dc:	9a01      	ldr	r2, [sp, #4]
 80056de:	605a      	str	r2, [r3, #4]
}
 80056e0:	b002      	add	sp, #8
 80056e2:	4770      	bx	lr
 80056e4:	f3af 8000 	nop.w
 80056e8:	f3af 8000 	nop.w
 80056ec:	f3af 8000 	nop.w

080056f0 <queue_notempty.5026.4237>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 80056f0:	b082      	sub	sp, #8
 80056f2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80056f4:	9b01      	ldr	r3, [sp, #4]
 80056f6:	681a      	ldr	r2, [r3, #0]
 80056f8:	9b01      	ldr	r3, [sp, #4]
 80056fa:	429a      	cmp	r2, r3
 80056fc:	bf0c      	ite	eq
 80056fe:	2300      	moveq	r3, #0
 8005700:	2301      	movne	r3, #1
 8005702:	b2db      	uxtb	r3, r3
}
 8005704:	4618      	mov	r0, r3
 8005706:	b002      	add	sp, #8
 8005708:	4770      	bx	lr
 800570a:	bf00      	nop
 800570c:	f3af 8000 	nop.w

08005710 <list_insert.5029.4233>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8005710:	b082      	sub	sp, #8
 8005712:	9001      	str	r0, [sp, #4]
 8005714:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 8005716:	9b00      	ldr	r3, [sp, #0]
 8005718:	681a      	ldr	r2, [r3, #0]
 800571a:	9b01      	ldr	r3, [sp, #4]
 800571c:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 800571e:	9b00      	ldr	r3, [sp, #0]
 8005720:	9a01      	ldr	r2, [sp, #4]
 8005722:	601a      	str	r2, [r3, #0]
}
 8005724:	b002      	add	sp, #8
 8005726:	4770      	bx	lr
 8005728:	f3af 8000 	nop.w
 800572c:	f3af 8000 	nop.w

08005730 <list_remove.5033.4230>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8005730:	b084      	sub	sp, #16
 8005732:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8005734:	9b01      	ldr	r3, [sp, #4]
 8005736:	681b      	ldr	r3, [r3, #0]
 8005738:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 800573a:	9b03      	ldr	r3, [sp, #12]
 800573c:	681a      	ldr	r2, [r3, #0]
 800573e:	9b01      	ldr	r3, [sp, #4]
 8005740:	601a      	str	r2, [r3, #0]

  return tp;
 8005742:	9b03      	ldr	r3, [sp, #12]
}
 8005744:	4618      	mov	r0, r3
 8005746:	b004      	add	sp, #16
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop
 800574c:	f3af 8000 	nop.w

08005750 <queue_insert.5036.4226>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8005750:	b082      	sub	sp, #8
 8005752:	9001      	str	r0, [sp, #4]
 8005754:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8005756:	9b01      	ldr	r3, [sp, #4]
 8005758:	9a00      	ldr	r2, [sp, #0]
 800575a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800575c:	9b00      	ldr	r3, [sp, #0]
 800575e:	685a      	ldr	r2, [r3, #4]
 8005760:	9b01      	ldr	r3, [sp, #4]
 8005762:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8005764:	9b01      	ldr	r3, [sp, #4]
 8005766:	685b      	ldr	r3, [r3, #4]
 8005768:	9a01      	ldr	r2, [sp, #4]
 800576a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 800576c:	9b00      	ldr	r3, [sp, #0]
 800576e:	9a01      	ldr	r2, [sp, #4]
 8005770:	605a      	str	r2, [r3, #4]
}
 8005772:	b002      	add	sp, #8
 8005774:	4770      	bx	lr
 8005776:	bf00      	nop
 8005778:	f3af 8000 	nop.w
 800577c:	f3af 8000 	nop.w

08005780 <queue_fifo_remove.5040.4223>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8005780:	b084      	sub	sp, #16
 8005782:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8005784:	9b01      	ldr	r3, [sp, #4]
 8005786:	681b      	ldr	r3, [r3, #0]
 8005788:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800578a:	9b03      	ldr	r3, [sp, #12]
 800578c:	681a      	ldr	r2, [r3, #0]
 800578e:	9b01      	ldr	r3, [sp, #4]
 8005790:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005792:	9b01      	ldr	r3, [sp, #4]
 8005794:	681b      	ldr	r3, [r3, #0]
 8005796:	9a01      	ldr	r2, [sp, #4]
 8005798:	605a      	str	r2, [r3, #4]

  return tp;
 800579a:	9b03      	ldr	r3, [sp, #12]
}
 800579c:	4618      	mov	r0, r3
 800579e:	b004      	add	sp, #16
 80057a0:	4770      	bx	lr
 80057a2:	bf00      	nop
 80057a4:	f3af 8000 	nop.w
 80057a8:	f3af 8000 	nop.w
 80057ac:	f3af 8000 	nop.w

080057b0 <chSysLock.5045.4217>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80057b0:	b508      	push	{r3, lr}

  port_lock();
 80057b2:	f7ff ff65 	bl	8005680 <port_lock.4931.4256>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80057b6:	bd08      	pop	{r3, pc}
 80057b8:	f3af 8000 	nop.w
 80057bc:	f3af 8000 	nop.w

080057c0 <chSysUnlock.5047.4215>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80057c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80057c2:	f7ff ff65 	bl	8005690 <port_unlock.4934.4254>
}
 80057c6:	bd08      	pop	{r3, pc}
 80057c8:	f3af 8000 	nop.w
 80057cc:	f3af 8000 	nop.w

080057d0 <chThdGetSelfX.5056.4205>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80057d0:	4b01      	ldr	r3, [pc, #4]	; (80057d8 <chThdGetSelfX.5056.4205+0x8>)
 80057d2:	699b      	ldr	r3, [r3, #24]
}
 80057d4:	4618      	mov	r0, r3
 80057d6:	4770      	bx	lr
 80057d8:	20000958 	.word	0x20000958
 80057dc:	f3af 8000 	nop.w

080057e0 <chThdSleepS.5065.4199>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80057e0:	b500      	push	{lr}
 80057e2:	b083      	sub	sp, #12
 80057e4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80057e6:	2008      	movs	r0, #8
 80057e8:	9901      	ldr	r1, [sp, #4]
 80057ea:	f7ff fe61 	bl	80054b0 <chSchGoSleepTimeoutS>
}
 80057ee:	b003      	add	sp, #12
 80057f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80057f4:	f3af 8000 	nop.w
 80057f8:	f3af 8000 	nop.w
 80057fc:	f3af 8000 	nop.w

08005800 <chThdDoDequeueNextI.5061.4195>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8005800:	b500      	push	{lr}
 8005802:	b085      	sub	sp, #20
 8005804:	9001      	str	r0, [sp, #4]
 8005806:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8005808:	9801      	ldr	r0, [sp, #4]
 800580a:	f7ff ffb9 	bl	8005780 <queue_fifo_remove.5040.4223>
 800580e:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8005810:	9b03      	ldr	r3, [sp, #12]
 8005812:	9a00      	ldr	r2, [sp, #0]
 8005814:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8005816:	9803      	ldr	r0, [sp, #12]
 8005818:	f7ff fdaa 	bl	8005370 <chSchReadyI>
}
 800581c:	b005      	add	sp, #20
 800581e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005822:	bf00      	nop
 8005824:	f3af 8000 	nop.w
 8005828:	f3af 8000 	nop.w
 800582c:	f3af 8000 	nop.w

08005830 <_thread_init.4191>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8005830:	b500      	push	{lr}
 8005832:	b083      	sub	sp, #12
 8005834:	9001      	str	r0, [sp, #4]
 8005836:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8005838:	9b01      	ldr	r3, [sp, #4]
 800583a:	9a00      	ldr	r2, [sp, #0]
 800583c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800583e:	9b01      	ldr	r3, [sp, #4]
 8005840:	2202      	movs	r2, #2
 8005842:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8005846:	9b01      	ldr	r3, [sp, #4]
 8005848:	2200      	movs	r2, #0
 800584a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800584e:	9b01      	ldr	r3, [sp, #4]
 8005850:	9a00      	ldr	r2, [sp, #0]
 8005852:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8005854:	9b01      	ldr	r3, [sp, #4]
 8005856:	2200      	movs	r2, #0
 8005858:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800585a:	9b01      	ldr	r3, [sp, #4]
 800585c:	2200      	movs	r2, #0
 800585e:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005860:	9b01      	ldr	r3, [sp, #4]
 8005862:	2201      	movs	r2, #1
 8005864:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8005868:	9b01      	ldr	r3, [sp, #4]
 800586a:	2200      	movs	r2, #0
 800586c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800586e:	9b01      	ldr	r3, [sp, #4]
 8005870:	4a10      	ldr	r2, [pc, #64]	; (80058b4 <_thread_init.4191+0x84>)
 8005872:	611a      	str	r2, [r3, #16]
 8005874:	4b0f      	ldr	r3, [pc, #60]	; (80058b4 <_thread_init.4191+0x84>)
 8005876:	695a      	ldr	r2, [r3, #20]
 8005878:	9b01      	ldr	r3, [sp, #4]
 800587a:	615a      	str	r2, [r3, #20]
 800587c:	9b01      	ldr	r3, [sp, #4]
 800587e:	695b      	ldr	r3, [r3, #20]
 8005880:	9a01      	ldr	r2, [sp, #4]
 8005882:	611a      	str	r2, [r3, #16]
 8005884:	4b0b      	ldr	r3, [pc, #44]	; (80058b4 <_thread_init.4191+0x84>)
 8005886:	9a01      	ldr	r2, [sp, #4]
 8005888:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800588a:	9b01      	ldr	r3, [sp, #4]
 800588c:	3328      	adds	r3, #40	; 0x28
 800588e:	4618      	mov	r0, r3
 8005890:	f7ff ff06 	bl	80056a0 <list_init.4943.4247>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8005894:	9b01      	ldr	r3, [sp, #4]
 8005896:	332c      	adds	r3, #44	; 0x2c
 8005898:	4618      	mov	r0, r3
 800589a:	f7ff ff19 	bl	80056d0 <queue_init.5023.4241>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800589e:	9b01      	ldr	r3, [sp, #4]
 80058a0:	f103 0244 	add.w	r2, r3, #68	; 0x44
 80058a4:	9b01      	ldr	r3, [sp, #4]
 80058a6:	61da      	str	r2, [r3, #28]
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 80058a8:	9b01      	ldr	r3, [sp, #4]
}
 80058aa:	4618      	mov	r0, r3
 80058ac:	b003      	add	sp, #12
 80058ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80058b2:	bf00      	nop
 80058b4:	20000958 	.word	0x20000958
 80058b8:	f3af 8000 	nop.w
 80058bc:	f3af 8000 	nop.w

080058c0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80058c0:	b500      	push	{lr}
 80058c2:	b087      	sub	sp, #28
 80058c4:	9003      	str	r0, [sp, #12]
 80058c6:	9102      	str	r1, [sp, #8]
 80058c8:	9201      	str	r2, [sp, #4]
 80058ca:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 80058cc:	9b03      	ldr	r3, [sp, #12]
 80058ce:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80058d0:	9b02      	ldr	r3, [sp, #8]
 80058d2:	3b24      	subs	r3, #36	; 0x24
 80058d4:	9a03      	ldr	r2, [sp, #12]
 80058d6:	441a      	add	r2, r3
 80058d8:	9b05      	ldr	r3, [sp, #20]
 80058da:	60da      	str	r2, [r3, #12]
 80058dc:	9b05      	ldr	r3, [sp, #20]
 80058de:	68db      	ldr	r3, [r3, #12]
 80058e0:	9a00      	ldr	r2, [sp, #0]
 80058e2:	601a      	str	r2, [r3, #0]
 80058e4:	9b05      	ldr	r3, [sp, #20]
 80058e6:	68db      	ldr	r3, [r3, #12]
 80058e8:	9a08      	ldr	r2, [sp, #32]
 80058ea:	605a      	str	r2, [r3, #4]
 80058ec:	9b05      	ldr	r3, [sp, #20]
 80058ee:	68db      	ldr	r3, [r3, #12]
 80058f0:	4a05      	ldr	r2, [pc, #20]	; (8005908 <chThdCreateI+0x48>)
 80058f2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 80058f4:	9805      	ldr	r0, [sp, #20]
 80058f6:	9901      	ldr	r1, [sp, #4]
 80058f8:	f7ff ff9a 	bl	8005830 <_thread_init.4191>
 80058fc:	4603      	mov	r3, r0
}
 80058fe:	4618      	mov	r0, r3
 8005900:	b007      	add	sp, #28
 8005902:	f85d fb04 	ldr.w	pc, [sp], #4
 8005906:	bf00      	nop
 8005908:	080002f1 	.word	0x080002f1
 800590c:	f3af 8000 	nop.w

08005910 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8005910:	b500      	push	{lr}
 8005912:	b089      	sub	sp, #36	; 0x24
 8005914:	9005      	str	r0, [sp, #20]
 8005916:	9104      	str	r1, [sp, #16]
 8005918:	9203      	str	r2, [sp, #12]
 800591a:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800591c:	f7ff ff48 	bl	80057b0 <chSysLock.5045.4217>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8005920:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005922:	9300      	str	r3, [sp, #0]
 8005924:	9805      	ldr	r0, [sp, #20]
 8005926:	9904      	ldr	r1, [sp, #16]
 8005928:	9a03      	ldr	r2, [sp, #12]
 800592a:	9b02      	ldr	r3, [sp, #8]
 800592c:	f7ff ffc8 	bl	80058c0 <chThdCreateI>
 8005930:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8005932:	9807      	ldr	r0, [sp, #28]
 8005934:	2100      	movs	r1, #0
 8005936:	f7ff fdf3 	bl	8005520 <chSchWakeupS>
  chSysUnlock();
 800593a:	f7ff ff41 	bl	80057c0 <chSysUnlock.5047.4215>

  return tp;
 800593e:	9b07      	ldr	r3, [sp, #28]
}
 8005940:	4618      	mov	r0, r3
 8005942:	b009      	add	sp, #36	; 0x24
 8005944:	f85d fb04 	ldr.w	pc, [sp], #4
 8005948:	f3af 8000 	nop.w
 800594c:	f3af 8000 	nop.w

08005950 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8005950:	b500      	push	{lr}
 8005952:	b083      	sub	sp, #12
 8005954:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005956:	f7ff ff2b 	bl	80057b0 <chSysLock.5045.4217>
  chThdSleepS(time);
 800595a:	9801      	ldr	r0, [sp, #4]
 800595c:	f7ff ff40 	bl	80057e0 <chThdSleepS.5065.4199>
  chSysUnlock();
 8005960:	f7ff ff2e 	bl	80057c0 <chSysUnlock.5047.4215>
}
 8005964:	b003      	add	sp, #12
 8005966:	f85d fb04 	ldr.w	pc, [sp], #4
 800596a:	bf00      	nop
 800596c:	f3af 8000 	nop.w

08005970 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8005970:	b500      	push	{lr}
 8005972:	b083      	sub	sp, #12
 8005974:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005976:	f7ff ff1b 	bl	80057b0 <chSysLock.5045.4217>
  chThdExitS(msg);
 800597a:	9801      	ldr	r0, [sp, #4]
 800597c:	f000 f808 	bl	8005990 <chThdExitS>
  /* The thread never returns here.*/
}
 8005980:	b003      	add	sp, #12
 8005982:	f85d fb04 	ldr.w	pc, [sp], #4
 8005986:	bf00      	nop
 8005988:	f3af 8000 	nop.w
 800598c:	f3af 8000 	nop.w

08005990 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8005990:	b500      	push	{lr}
 8005992:	b085      	sub	sp, #20
 8005994:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8005996:	4b17      	ldr	r3, [pc, #92]	; (80059f4 <chThdExitS+0x64>)
 8005998:	699b      	ldr	r3, [r3, #24]
 800599a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800599c:	9b03      	ldr	r3, [sp, #12]
 800599e:	9a01      	ldr	r2, [sp, #4]
 80059a0:	625a      	str	r2, [r3, #36]	; 0x24
 80059a2:	e008      	b.n	80059b6 <chThdExitS+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80059a4:	9b03      	ldr	r3, [sp, #12]
 80059a6:	3328      	adds	r3, #40	; 0x28
 80059a8:	4618      	mov	r0, r3
 80059aa:	f7ff fec1 	bl	8005730 <list_remove.5033.4230>
 80059ae:	4603      	mov	r3, r0
 80059b0:	4618      	mov	r0, r3
 80059b2:	f7ff fcdd 	bl	8005370 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80059b6:	9b03      	ldr	r3, [sp, #12]
 80059b8:	3328      	adds	r3, #40	; 0x28
 80059ba:	4618      	mov	r0, r3
 80059bc:	f7ff fe78 	bl	80056b0 <list_notempty.5019.4244>
 80059c0:	4603      	mov	r3, r0
 80059c2:	2b00      	cmp	r3, #0
 80059c4:	d1ee      	bne.n	80059a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80059c6:	9b03      	ldr	r3, [sp, #12]
 80059c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80059cc:	f003 0303 	and.w	r3, r3, #3
 80059d0:	2b00      	cmp	r3, #0
 80059d2:	d109      	bne.n	80059e8 <chThdExitS+0x58>
    REG_REMOVE(tp);
 80059d4:	9b03      	ldr	r3, [sp, #12]
 80059d6:	695b      	ldr	r3, [r3, #20]
 80059d8:	9a03      	ldr	r2, [sp, #12]
 80059da:	6912      	ldr	r2, [r2, #16]
 80059dc:	611a      	str	r2, [r3, #16]
 80059de:	9b03      	ldr	r3, [sp, #12]
 80059e0:	691b      	ldr	r3, [r3, #16]
 80059e2:	9a03      	ldr	r2, [sp, #12]
 80059e4:	6952      	ldr	r2, [r2, #20]
 80059e6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80059e8:	200f      	movs	r0, #15
 80059ea:	f7ff fce9 	bl	80053c0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80059ee:	b005      	add	sp, #20
 80059f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80059f4:	20000958 	.word	0x20000958
 80059f8:	f3af 8000 	nop.w
 80059fc:	f3af 8000 	nop.w

08005a00 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8005a00:	b500      	push	{lr}
 8005a02:	b085      	sub	sp, #20
 8005a04:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8005a06:	f7ff fed3 	bl	80057b0 <chSysLock.5045.4217>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 8005a0a:	9b01      	ldr	r3, [sp, #4]
 8005a0c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005a10:	2b0f      	cmp	r3, #15
 8005a12:	d00a      	beq.n	8005a2a <chThdWait+0x2a>
    list_insert(currp, &tp->p_waiting);
 8005a14:	4b0b      	ldr	r3, [pc, #44]	; (8005a44 <chThdWait+0x44>)
 8005a16:	699a      	ldr	r2, [r3, #24]
 8005a18:	9b01      	ldr	r3, [sp, #4]
 8005a1a:	3328      	adds	r3, #40	; 0x28
 8005a1c:	4610      	mov	r0, r2
 8005a1e:	4619      	mov	r1, r3
 8005a20:	f7ff fe76 	bl	8005710 <list_insert.5029.4233>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8005a24:	2009      	movs	r0, #9
 8005a26:	f7ff fccb 	bl	80053c0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8005a2a:	9b01      	ldr	r3, [sp, #4]
 8005a2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005a2e:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8005a30:	f7ff fec6 	bl	80057c0 <chSysUnlock.5047.4215>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8005a34:	9801      	ldr	r0, [sp, #4]
 8005a36:	f7fe fd93 	bl	8004560 <chThdRelease>
#endif

  return msg;
 8005a3a:	9b03      	ldr	r3, [sp, #12]
}
 8005a3c:	4618      	mov	r0, r3
 8005a3e:	b005      	add	sp, #20
 8005a40:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a44:	20000958 	.word	0x20000958
 8005a48:	f3af 8000 	nop.w
 8005a4c:	f3af 8000 	nop.w

08005a50 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8005a50:	b500      	push	{lr}
 8005a52:	b085      	sub	sp, #20
 8005a54:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8005a56:	f7ff febb 	bl	80057d0 <chThdGetSelfX.5056.4205>
 8005a5a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8005a5c:	9b01      	ldr	r3, [sp, #4]
 8005a5e:	9a03      	ldr	r2, [sp, #12]
 8005a60:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8005a62:	9b03      	ldr	r3, [sp, #12]
 8005a64:	9a01      	ldr	r2, [sp, #4]
 8005a66:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8005a68:	2003      	movs	r0, #3
 8005a6a:	f7ff fca9 	bl	80053c0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 8005a6e:	f7ff feaf 	bl	80057d0 <chThdGetSelfX.5056.4205>
 8005a72:	4603      	mov	r3, r0
 8005a74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005a76:	4618      	mov	r0, r3
 8005a78:	b005      	add	sp, #20
 8005a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a7e:	bf00      	nop

08005a80 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8005a80:	b500      	push	{lr}
 8005a82:	b085      	sub	sp, #20
 8005a84:	9001      	str	r0, [sp, #4]
 8005a86:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8005a88:	9b01      	ldr	r3, [sp, #4]
 8005a8a:	681b      	ldr	r3, [r3, #0]
 8005a8c:	2b00      	cmp	r3, #0
 8005a8e:	d00b      	beq.n	8005aa8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8005a90:	9b01      	ldr	r3, [sp, #4]
 8005a92:	681b      	ldr	r3, [r3, #0]
 8005a94:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8005a96:	9b01      	ldr	r3, [sp, #4]
 8005a98:	2200      	movs	r2, #0
 8005a9a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 8005a9c:	9b03      	ldr	r3, [sp, #12]
 8005a9e:	9a00      	ldr	r2, [sp, #0]
 8005aa0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8005aa2:	9803      	ldr	r0, [sp, #12]
 8005aa4:	f7ff fc64 	bl	8005370 <chSchReadyI>
  }
}
 8005aa8:	b005      	add	sp, #20
 8005aaa:	f85d fb04 	ldr.w	pc, [sp], #4
 8005aae:	bf00      	nop

08005ab0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	9001      	str	r0, [sp, #4]
 8005ab6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8005ab8:	9b00      	ldr	r3, [sp, #0]
 8005aba:	2b00      	cmp	r3, #0
 8005abc:	d102      	bne.n	8005ac4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8005abe:	f04f 33ff 	mov.w	r3, #4294967295
 8005ac2:	e00a      	b.n	8005ada <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8005ac4:	4b07      	ldr	r3, [pc, #28]	; (8005ae4 <chThdEnqueueTimeoutS+0x34>)
 8005ac6:	699b      	ldr	r3, [r3, #24]
 8005ac8:	4618      	mov	r0, r3
 8005aca:	9901      	ldr	r1, [sp, #4]
 8005acc:	f7ff fe40 	bl	8005750 <queue_insert.5036.4226>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005ad0:	2004      	movs	r0, #4
 8005ad2:	9900      	ldr	r1, [sp, #0]
 8005ad4:	f7ff fcec 	bl	80054b0 <chSchGoSleepTimeoutS>
 8005ad8:	4603      	mov	r3, r0
}
 8005ada:	4618      	mov	r0, r3
 8005adc:	b003      	add	sp, #12
 8005ade:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ae2:	bf00      	nop
 8005ae4:	20000958 	.word	0x20000958
 8005ae8:	f3af 8000 	nop.w
 8005aec:	f3af 8000 	nop.w

08005af0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8005af0:	b500      	push	{lr}
 8005af2:	b083      	sub	sp, #12
 8005af4:	9001      	str	r0, [sp, #4]
 8005af6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8005af8:	9801      	ldr	r0, [sp, #4]
 8005afa:	f7ff fdf9 	bl	80056f0 <queue_notempty.5026.4237>
 8005afe:	4603      	mov	r3, r0
 8005b00:	2b00      	cmp	r3, #0
 8005b02:	d003      	beq.n	8005b0c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8005b04:	9801      	ldr	r0, [sp, #4]
 8005b06:	9900      	ldr	r1, [sp, #0]
 8005b08:	f7ff fe7a 	bl	8005800 <chThdDoDequeueNextI.5061.4195>
  }
}
 8005b0c:	b003      	add	sp, #12
 8005b0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b12:	bf00      	nop
 8005b14:	f3af 8000 	nop.w
 8005b18:	f3af 8000 	nop.w
 8005b1c:	f3af 8000 	nop.w

08005b20 <port_rt_get_counter_value.5255>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005b20:	4b01      	ldr	r3, [pc, #4]	; (8005b28 <port_rt_get_counter_value.5255+0x8>)
 8005b22:	685b      	ldr	r3, [r3, #4]
}
 8005b24:	4618      	mov	r0, r3
 8005b26:	4770      	bx	lr
 8005b28:	e0001000 	.word	0xe0001000
 8005b2c:	f3af 8000 	nop.w

08005b30 <tm_stop.5261>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8005b30:	b084      	sub	sp, #16
 8005b32:	9003      	str	r0, [sp, #12]
 8005b34:	9102      	str	r1, [sp, #8]
 8005b36:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8005b38:	9b03      	ldr	r3, [sp, #12]
 8005b3a:	68db      	ldr	r3, [r3, #12]
 8005b3c:	1c5a      	adds	r2, r3, #1
 8005b3e:	9b03      	ldr	r3, [sp, #12]
 8005b40:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8005b42:	9b03      	ldr	r3, [sp, #12]
 8005b44:	689b      	ldr	r3, [r3, #8]
 8005b46:	9a02      	ldr	r2, [sp, #8]
 8005b48:	1ad2      	subs	r2, r2, r3
 8005b4a:	9b01      	ldr	r3, [sp, #4]
 8005b4c:	1ad2      	subs	r2, r2, r3
 8005b4e:	9b03      	ldr	r3, [sp, #12]
 8005b50:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8005b52:	9b03      	ldr	r3, [sp, #12]
 8005b54:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8005b58:	9b03      	ldr	r3, [sp, #12]
 8005b5a:	689b      	ldr	r3, [r3, #8]
 8005b5c:	461a      	mov	r2, r3
 8005b5e:	f04f 0300 	mov.w	r3, #0
 8005b62:	1812      	adds	r2, r2, r0
 8005b64:	eb43 0301 	adc.w	r3, r3, r1
 8005b68:	9903      	ldr	r1, [sp, #12]
 8005b6a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 8005b6e:	9b03      	ldr	r3, [sp, #12]
 8005b70:	689a      	ldr	r2, [r3, #8]
 8005b72:	9b03      	ldr	r3, [sp, #12]
 8005b74:	685b      	ldr	r3, [r3, #4]
 8005b76:	429a      	cmp	r2, r3
 8005b78:	d903      	bls.n	8005b82 <tm_stop.5261+0x52>
    tmp->worst = tmp->last;
 8005b7a:	9b03      	ldr	r3, [sp, #12]
 8005b7c:	689a      	ldr	r2, [r3, #8]
 8005b7e:	9b03      	ldr	r3, [sp, #12]
 8005b80:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8005b82:	9b03      	ldr	r3, [sp, #12]
 8005b84:	689a      	ldr	r2, [r3, #8]
 8005b86:	9b03      	ldr	r3, [sp, #12]
 8005b88:	681b      	ldr	r3, [r3, #0]
 8005b8a:	429a      	cmp	r2, r3
 8005b8c:	d203      	bcs.n	8005b96 <tm_stop.5261+0x66>
    tmp->best = tmp->last;
 8005b8e:	9b03      	ldr	r3, [sp, #12]
 8005b90:	689a      	ldr	r2, [r3, #8]
 8005b92:	9b03      	ldr	r3, [sp, #12]
 8005b94:	601a      	str	r2, [r3, #0]
  }
}
 8005b96:	b004      	add	sp, #16
 8005b98:	4770      	bx	lr
 8005b9a:	bf00      	nop
 8005b9c:	f3af 8000 	nop.w

08005ba0 <_tm_init.4013>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8005ba0:	b500      	push	{lr}
 8005ba2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8005ba4:	4b0a      	ldr	r3, [pc, #40]	; (8005bd0 <_tm_init.4013+0x30>)
 8005ba6:	2200      	movs	r2, #0
 8005ba8:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 8005baa:	466b      	mov	r3, sp
 8005bac:	4618      	mov	r0, r3
 8005bae:	f7fe fc77 	bl	80044a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8005bb2:	466b      	mov	r3, sp
 8005bb4:	4618      	mov	r0, r3
 8005bb6:	f7fe fc8b 	bl	80044d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8005bba:	466b      	mov	r3, sp
 8005bbc:	4618      	mov	r0, r3
 8005bbe:	f7fe fc97 	bl	80044f0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8005bc2:	9a02      	ldr	r2, [sp, #8]
 8005bc4:	4b02      	ldr	r3, [pc, #8]	; (8005bd0 <_tm_init.4013+0x30>)
 8005bc6:	675a      	str	r2, [r3, #116]	; 0x74
}
 8005bc8:	b007      	add	sp, #28
 8005bca:	f85d fb04 	ldr.w	pc, [sp], #4
 8005bce:	bf00      	nop
 8005bd0:	20000958 	.word	0x20000958
 8005bd4:	f3af 8000 	nop.w
 8005bd8:	f3af 8000 	nop.w
 8005bdc:	f3af 8000 	nop.w

08005be0 <strpbrk>:
 8005be0:	b4f0      	push	{r4, r5, r6, r7}
 8005be2:	7804      	ldrb	r4, [r0, #0]
 8005be4:	b30c      	cbz	r4, 8005c2a <strpbrk+0x4a>
 8005be6:	780e      	ldrb	r6, [r1, #0]
 8005be8:	4607      	mov	r7, r0
 8005bea:	b1c6      	cbz	r6, 8005c1e <strpbrk+0x3e>
 8005bec:	42a6      	cmp	r6, r4
 8005bee:	d010      	beq.n	8005c12 <strpbrk+0x32>
 8005bf0:	1c4b      	adds	r3, r1, #1
 8005bf2:	e001      	b.n	8005bf8 <strpbrk+0x18>
 8005bf4:	4294      	cmp	r4, r2
 8005bf6:	d00b      	beq.n	8005c10 <strpbrk+0x30>
 8005bf8:	461d      	mov	r5, r3
 8005bfa:	f813 2b01 	ldrb.w	r2, [r3], #1
 8005bfe:	2a00      	cmp	r2, #0
 8005c00:	d1f8      	bne.n	8005bf4 <strpbrk+0x14>
 8005c02:	7844      	ldrb	r4, [r0, #1]
 8005c04:	3001      	adds	r0, #1
 8005c06:	2c00      	cmp	r4, #0
 8005c08:	d1ee      	bne.n	8005be8 <strpbrk+0x8>
 8005c0a:	782e      	ldrb	r6, [r5, #0]
 8005c0c:	4607      	mov	r7, r0
 8005c0e:	e000      	b.n	8005c12 <strpbrk+0x32>
 8005c10:	4626      	mov	r6, r4
 8005c12:	2e00      	cmp	r6, #0
 8005c14:	bf14      	ite	ne
 8005c16:	4638      	movne	r0, r7
 8005c18:	2000      	moveq	r0, #0
 8005c1a:	bcf0      	pop	{r4, r5, r6, r7}
 8005c1c:	4770      	bx	lr
 8005c1e:	7844      	ldrb	r4, [r0, #1]
 8005c20:	460d      	mov	r5, r1
 8005c22:	3001      	adds	r0, #1
 8005c24:	2c00      	cmp	r4, #0
 8005c26:	d1df      	bne.n	8005be8 <strpbrk+0x8>
 8005c28:	e7ef      	b.n	8005c0a <strpbrk+0x2a>
 8005c2a:	4620      	mov	r0, r4
 8005c2c:	bcf0      	pop	{r4, r5, r6, r7}
 8005c2e:	4770      	bx	lr

08005c30 <strspn>:
 8005c30:	b4f0      	push	{r4, r5, r6, r7}
 8005c32:	7804      	ldrb	r4, [r0, #0]
 8005c34:	b1cc      	cbz	r4, 8005c6a <strspn+0x3a>
 8005c36:	780e      	ldrb	r6, [r1, #0]
 8005c38:	4607      	mov	r7, r0
 8005c3a:	b19e      	cbz	r6, 8005c64 <strspn+0x34>
 8005c3c:	4605      	mov	r5, r0
 8005c3e:	42b4      	cmp	r4, r6
 8005c40:	d00a      	beq.n	8005c58 <strspn+0x28>
 8005c42:	460a      	mov	r2, r1
 8005c44:	e001      	b.n	8005c4a <strspn+0x1a>
 8005c46:	429c      	cmp	r4, r3
 8005c48:	d006      	beq.n	8005c58 <strspn+0x28>
 8005c4a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8005c4e:	2b00      	cmp	r3, #0
 8005c50:	d1f9      	bne.n	8005c46 <strspn+0x16>
 8005c52:	1a28      	subs	r0, r5, r0
 8005c54:	bcf0      	pop	{r4, r5, r6, r7}
 8005c56:	4770      	bx	lr
 8005c58:	786c      	ldrb	r4, [r5, #1]
 8005c5a:	1c7d      	adds	r5, r7, #1
 8005c5c:	2c00      	cmp	r4, #0
 8005c5e:	d0f8      	beq.n	8005c52 <strspn+0x22>
 8005c60:	462f      	mov	r7, r5
 8005c62:	e7ec      	b.n	8005c3e <strspn+0xe>
 8005c64:	4630      	mov	r0, r6
 8005c66:	bcf0      	pop	{r4, r5, r6, r7}
 8005c68:	4770      	bx	lr
 8005c6a:	4620      	mov	r0, r4
 8005c6c:	e7f2      	b.n	8005c54 <strspn+0x24>
 8005c6e:	bf00      	nop
 8005c70:	65726854 	.word	0x65726854
 8005c74:	2c736461 	.word	0x2c736461
 8005c78:	716e6520 	.word	0x716e6520
 8005c7c:	69756575 	.word	0x69756575
 8005c80:	7420676e 	.word	0x7420676e
 8005c84:	20747365 	.word	0x20747365
 8005c88:	00003123 	.word	0x00003123
 8005c8c:	65726854 	.word	0x65726854
 8005c90:	2c736461 	.word	0x2c736461
 8005c94:	716e6520 	.word	0x716e6520
 8005c98:	69756575 	.word	0x69756575
 8005c9c:	7420676e 	.word	0x7420676e
 8005ca0:	20747365 	.word	0x20747365
 8005ca4:	00003223 	.word	0x00003223
 8005ca8:	65726854 	.word	0x65726854
 8005cac:	2c736461 	.word	0x2c736461
 8005cb0:	69727020 	.word	0x69727020
 8005cb4:	7469726f 	.word	0x7469726f
 8005cb8:	68632079 	.word	0x68632079
 8005cbc:	65676e61 	.word	0x65676e61
 8005cc0:	00000000 	.word	0x00000000
 8005cc4:	65726854 	.word	0x65726854
 8005cc8:	2c736461 	.word	0x2c736461
 8005ccc:	6c656420 	.word	0x6c656420
 8005cd0:	00737961 	.word	0x00737961
 8005cd4:	616d6553 	.word	0x616d6553
 8005cd8:	726f6870 	.word	0x726f6870
 8005cdc:	202c7365 	.word	0x202c7365
 8005ce0:	75716e65 	.word	0x75716e65
 8005ce4:	6e697565 	.word	0x6e697565
 8005ce8:	00000067 	.word	0x00000067
 8005cec:	616d6553 	.word	0x616d6553
 8005cf0:	726f6870 	.word	0x726f6870
 8005cf4:	202c7365 	.word	0x202c7365
 8005cf8:	656d6974 	.word	0x656d6974
 8005cfc:	0074756f 	.word	0x0074756f
 8005d00:	616d6553 	.word	0x616d6553
 8005d04:	726f6870 	.word	0x726f6870
 8005d08:	202c7365 	.word	0x202c7365
 8005d0c:	6d6f7461 	.word	0x6d6f7461
 8005d10:	73206369 	.word	0x73206369
 8005d14:	616e6769 	.word	0x616e6769
 8005d18:	61772d6c 	.word	0x61772d6c
 8005d1c:	00007469 	.word	0x00007469
 8005d20:	616e6942 	.word	0x616e6942
 8005d24:	53207972 	.word	0x53207972
 8005d28:	70616d65 	.word	0x70616d65
 8005d2c:	65726f68 	.word	0x65726f68
 8005d30:	66202c73 	.word	0x66202c73
 8005d34:	74636e75 	.word	0x74636e75
 8005d38:	616e6f69 	.word	0x616e6f69
 8005d3c:	7974696c 	.word	0x7974696c
 8005d40:	00000000 	.word	0x00000000
 8005d44:	6574754d 	.word	0x6574754d
 8005d48:	2c736578 	.word	0x2c736578
 8005d4c:	69727020 	.word	0x69727020
 8005d50:	7469726f 	.word	0x7469726f
 8005d54:	6e652079 	.word	0x6e652079
 8005d58:	75657571 	.word	0x75657571
 8005d5c:	20676e69 	.word	0x20676e69
 8005d60:	74736574 	.word	0x74736574
 8005d64:	00000000 	.word	0x00000000
 8005d68:	6574754d 	.word	0x6574754d
 8005d6c:	2c736578 	.word	0x2c736578
 8005d70:	69727020 	.word	0x69727020
 8005d74:	7469726f 	.word	0x7469726f
 8005d78:	65722079 	.word	0x65722079
 8005d7c:	6e727574 	.word	0x6e727574
 8005d80:	00000000 	.word	0x00000000
 8005d84:	6574754d 	.word	0x6574754d
 8005d88:	2c736578 	.word	0x2c736578
 8005d8c:	61747320 	.word	0x61747320
 8005d90:	00737574 	.word	0x00737574
 8005d94:	646e6f43 	.word	0x646e6f43
 8005d98:	2c726156 	.word	0x2c726156
 8005d9c:	67697320 	.word	0x67697320
 8005da0:	206c616e 	.word	0x206c616e
 8005da4:	74736574 	.word	0x74736574
 8005da8:	00000000 	.word	0x00000000
 8005dac:	646e6f43 	.word	0x646e6f43
 8005db0:	2c726156 	.word	0x2c726156
 8005db4:	6f726220 	.word	0x6f726220
 8005db8:	61636461 	.word	0x61636461
 8005dbc:	74207473 	.word	0x74207473
 8005dc0:	00747365 	.word	0x00747365
 8005dc4:	646e6f43 	.word	0x646e6f43
 8005dc8:	2c726156 	.word	0x2c726156
 8005dcc:	6f6f6220 	.word	0x6f6f6220
 8005dd0:	74207473 	.word	0x74207473
 8005dd4:	00747365 	.word	0x00747365
 8005dd8:	7373654d 	.word	0x7373654d
 8005ddc:	73656761 	.word	0x73656761
 8005de0:	6f6c202c 	.word	0x6f6c202c
 8005de4:	0000706f 	.word	0x0000706f
 8005de8:	6c69614d 	.word	0x6c69614d
 8005dec:	65786f62 	.word	0x65786f62
 8005df0:	71202c73 	.word	0x71202c73
 8005df4:	69756575 	.word	0x69756575
 8005df8:	6120676e 	.word	0x6120676e
 8005dfc:	7420646e 	.word	0x7420646e
 8005e00:	6f656d69 	.word	0x6f656d69
 8005e04:	00737475 	.word	0x00737475
 8005e08:	6e657645 	.word	0x6e657645
 8005e0c:	202c7374 	.word	0x202c7374
 8005e10:	69676572 	.word	0x69676572
 8005e14:	61727473 	.word	0x61727473
 8005e18:	6e6f6974 	.word	0x6e6f6974
 8005e1c:	646e6120 	.word	0x646e6120
 8005e20:	73696420 	.word	0x73696420
 8005e24:	63746170 	.word	0x63746170
 8005e28:	00000068 	.word	0x00000068
 8005e2c:	6e657645 	.word	0x6e657645
 8005e30:	202c7374 	.word	0x202c7374
 8005e34:	74696177 	.word	0x74696177
 8005e38:	646e6120 	.word	0x646e6120
 8005e3c:	6f726220 	.word	0x6f726220
 8005e40:	61636461 	.word	0x61636461
 8005e44:	00007473 	.word	0x00007473
 8005e48:	6e657645 	.word	0x6e657645
 8005e4c:	202c7374 	.word	0x202c7374
 8005e50:	656d6974 	.word	0x656d6974
 8005e54:	7374756f 	.word	0x7374756f
 8005e58:	00000000 	.word	0x00000000
 8005e5c:	70616548 	.word	0x70616548
 8005e60:	6c61202c 	.word	0x6c61202c
 8005e64:	61636f6c 	.word	0x61636f6c
 8005e68:	6e6f6974 	.word	0x6e6f6974
 8005e6c:	646e6120 	.word	0x646e6120
 8005e70:	61726620 	.word	0x61726620
 8005e74:	6e656d67 	.word	0x6e656d67
 8005e78:	69746174 	.word	0x69746174
 8005e7c:	74206e6f 	.word	0x74206e6f
 8005e80:	00747365 	.word	0x00747365
 8005e84:	6f6d654d 	.word	0x6f6d654d
 8005e88:	50207972 	.word	0x50207972
 8005e8c:	736c6f6f 	.word	0x736c6f6f
 8005e90:	7571202c 	.word	0x7571202c
 8005e94:	2f657565 	.word	0x2f657565
 8005e98:	75716564 	.word	0x75716564
 8005e9c:	00657565 	.word	0x00657565
 8005ea0:	616e7944 	.word	0x616e7944
 8005ea4:	2063696d 	.word	0x2063696d
 8005ea8:	73495041 	.word	0x73495041
 8005eac:	6874202c 	.word	0x6874202c
 8005eb0:	64616572 	.word	0x64616572
 8005eb4:	72632073 	.word	0x72632073
 8005eb8:	69746165 	.word	0x69746165
 8005ebc:	66206e6f 	.word	0x66206e6f
 8005ec0:	206d6f72 	.word	0x206d6f72
 8005ec4:	70616568 	.word	0x70616568
 8005ec8:	00000000 	.word	0x00000000
 8005ecc:	616e7944 	.word	0x616e7944
 8005ed0:	2063696d 	.word	0x2063696d
 8005ed4:	73495041 	.word	0x73495041
 8005ed8:	6874202c 	.word	0x6874202c
 8005edc:	64616572 	.word	0x64616572
 8005ee0:	72632073 	.word	0x72632073
 8005ee4:	69746165 	.word	0x69746165
 8005ee8:	66206e6f 	.word	0x66206e6f
 8005eec:	206d6f72 	.word	0x206d6f72
 8005ef0:	6f6d656d 	.word	0x6f6d656d
 8005ef4:	70207972 	.word	0x70207972
 8005ef8:	006c6f6f 	.word	0x006c6f6f
 8005efc:	616e7944 	.word	0x616e7944
 8005f00:	2063696d 	.word	0x2063696d
 8005f04:	73495041 	.word	0x73495041
 8005f08:	6572202c 	.word	0x6572202c
 8005f0c:	74736967 	.word	0x74736967
 8005f10:	61207972 	.word	0x61207972
 8005f14:	7220646e 	.word	0x7220646e
 8005f18:	72656665 	.word	0x72656665
 8005f1c:	65636e65 	.word	0x65636e65
 8005f20:	00000073 	.word	0x00000073
 8005f24:	75657551 	.word	0x75657551
 8005f28:	202c7365 	.word	0x202c7365
 8005f2c:	75706e69 	.word	0x75706e69
 8005f30:	75712074 	.word	0x75712074
 8005f34:	73657565 	.word	0x73657565
 8005f38:	00000000 	.word	0x00000000
 8005f3c:	75657551 	.word	0x75657551
 8005f40:	202c7365 	.word	0x202c7365
 8005f44:	7074756f 	.word	0x7074756f
 8005f48:	71207475 	.word	0x71207475
 8005f4c:	65756575 	.word	0x65756575
 8005f50:	00000073 	.word	0x00000073
 8005f54:	74737953 	.word	0x74737953
 8005f58:	202c6d65 	.word	0x202c6d65
 8005f5c:	74697263 	.word	0x74697263
 8005f60:	6c616369 	.word	0x6c616369
 8005f64:	6e6f7a20 	.word	0x6e6f7a20
 8005f68:	00007365 	.word	0x00007365
 8005f6c:	74737953 	.word	0x74737953
 8005f70:	202c6d65 	.word	0x202c6d65
 8005f74:	65746e69 	.word	0x65746e69
 8005f78:	70757272 	.word	0x70757272
 8005f7c:	68207374 	.word	0x68207374
 8005f80:	6c646e61 	.word	0x6c646e61
 8005f84:	00676e69 	.word	0x00676e69
 8005f88:	74737953 	.word	0x74737953
 8005f8c:	202c6d65 	.word	0x202c6d65
 8005f90:	65746e69 	.word	0x65746e69
 8005f94:	74697267 	.word	0x74697267
 8005f98:	00000079 	.word	0x00000079
 8005f9c:	636e6542 	.word	0x636e6542
 8005fa0:	72616d68 	.word	0x72616d68
 8005fa4:	6d202c6b 	.word	0x6d202c6b
 8005fa8:	61737365 	.word	0x61737365
 8005fac:	20736567 	.word	0x20736567
 8005fb0:	00003123 	.word	0x00003123
 8005fb4:	636e6542 	.word	0x636e6542
 8005fb8:	72616d68 	.word	0x72616d68
 8005fbc:	6d202c6b 	.word	0x6d202c6b
 8005fc0:	61737365 	.word	0x61737365
 8005fc4:	20736567 	.word	0x20736567
 8005fc8:	00003223 	.word	0x00003223
 8005fcc:	636e6542 	.word	0x636e6542
 8005fd0:	72616d68 	.word	0x72616d68
 8005fd4:	6d202c6b 	.word	0x6d202c6b
 8005fd8:	61737365 	.word	0x61737365
 8005fdc:	20736567 	.word	0x20736567
 8005fe0:	00003323 	.word	0x00003323
 8005fe4:	636e6542 	.word	0x636e6542
 8005fe8:	72616d68 	.word	0x72616d68
 8005fec:	63202c6b 	.word	0x63202c6b
 8005ff0:	65746e6f 	.word	0x65746e6f
 8005ff4:	73207478 	.word	0x73207478
 8005ff8:	63746977 	.word	0x63746977
 8005ffc:	00000068 	.word	0x00000068
 8006000:	636e6542 	.word	0x636e6542
 8006004:	72616d68 	.word	0x72616d68
 8006008:	74202c6b 	.word	0x74202c6b
 800600c:	61657268 	.word	0x61657268
 8006010:	202c7364 	.word	0x202c7364
 8006014:	6c6c7566 	.word	0x6c6c7566
 8006018:	63796320 	.word	0x63796320
 800601c:	0000656c 	.word	0x0000656c
 8006020:	636e6542 	.word	0x636e6542
 8006024:	72616d68 	.word	0x72616d68
 8006028:	74202c6b 	.word	0x74202c6b
 800602c:	61657268 	.word	0x61657268
 8006030:	202c7364 	.word	0x202c7364
 8006034:	61657263 	.word	0x61657263
 8006038:	6f206574 	.word	0x6f206574
 800603c:	00796c6e 	.word	0x00796c6e
 8006040:	636e6542 	.word	0x636e6542
 8006044:	72616d68 	.word	0x72616d68
 8006048:	6d202c6b 	.word	0x6d202c6b
 800604c:	20737361 	.word	0x20737361
 8006050:	63736572 	.word	0x63736572
 8006054:	75646568 	.word	0x75646568
 8006058:	202c656c 	.word	0x202c656c
 800605c:	68742035 	.word	0x68742035
 8006060:	64616572 	.word	0x64616572
 8006064:	00000073 	.word	0x00000073
 8006068:	636e6542 	.word	0x636e6542
 800606c:	72616d68 	.word	0x72616d68
 8006070:	72202c6b 	.word	0x72202c6b
 8006074:	646e756f 	.word	0x646e756f
 8006078:	626f7220 	.word	0x626f7220
 800607c:	63206e69 	.word	0x63206e69
 8006080:	65746e6f 	.word	0x65746e6f
 8006084:	73207478 	.word	0x73207478
 8006088:	63746977 	.word	0x63746977
 800608c:	676e6968 	.word	0x676e6968
 8006090:	00000000 	.word	0x00000000
 8006094:	636e6542 	.word	0x636e6542
 8006098:	72616d68 	.word	0x72616d68
 800609c:	49202c6b 	.word	0x49202c6b
 80060a0:	51204f2f 	.word	0x51204f2f
 80060a4:	65756575 	.word	0x65756575
 80060a8:	68742073 	.word	0x68742073
 80060ac:	67756f72 	.word	0x67756f72
 80060b0:	74757068 	.word	0x74757068
 80060b4:	00000000 	.word	0x00000000
 80060b8:	636e6542 	.word	0x636e6542
 80060bc:	72616d68 	.word	0x72616d68
 80060c0:	76202c6b 	.word	0x76202c6b
 80060c4:	75747269 	.word	0x75747269
 80060c8:	74206c61 	.word	0x74206c61
 80060cc:	72656d69 	.word	0x72656d69
 80060d0:	65732073 	.word	0x65732073
 80060d4:	65722f74 	.word	0x65722f74
 80060d8:	00746573 	.word	0x00746573
 80060dc:	636e6542 	.word	0x636e6542
 80060e0:	72616d68 	.word	0x72616d68
 80060e4:	73202c6b 	.word	0x73202c6b
 80060e8:	70616d65 	.word	0x70616d65
 80060ec:	65726f68 	.word	0x65726f68
 80060f0:	61772073 	.word	0x61772073
 80060f4:	732f7469 	.word	0x732f7469
 80060f8:	616e6769 	.word	0x616e6769
 80060fc:	0000006c 	.word	0x0000006c
 8006100:	636e6542 	.word	0x636e6542
 8006104:	72616d68 	.word	0x72616d68
 8006108:	6d202c6b 	.word	0x6d202c6b
 800610c:	78657475 	.word	0x78657475
 8006110:	6c207365 	.word	0x6c207365
 8006114:	2f6b636f 	.word	0x2f6b636f
 8006118:	6f6c6e75 	.word	0x6f6c6e75
 800611c:	00006b63 	.word	0x00006b63
 8006120:	636e6542 	.word	0x636e6542
 8006124:	72616d68 	.word	0x72616d68
 8006128:	52202c6b 	.word	0x52202c6b
 800612c:	66204d41 	.word	0x66204d41
 8006130:	70746f6f 	.word	0x70746f6f
 8006134:	746e6972 	.word	0x746e6972
 8006138:	00000000 	.word	0x00000000
 800613c:	6f666e69 	.word	0x6f666e69
 8006140:	00000000 	.word	0x00000000
 8006144:	74737973 	.word	0x74737973
 8006148:	00656d69 	.word	0x00656d69
 800614c:	00007350 	.word	0x00007350
 8006150:	65766441 	.word	0x65766441
 8006154:	73697472 	.word	0x73697472
 8006158:	20676e69 	.word	0x20676e69
 800615c:	72617453 	.word	0x72617453
 8006160:	0d646574 	.word	0x0d646574
 8006164:	0000000a 	.word	0x0000000a
 8006168:	6e6e6f43 	.word	0x6e6e6f43
 800616c:	65746365 	.word	0x65746365
 8006170:	000a0d64 	.word	0x000a0d64
 8006174:	63206f4e 	.word	0x63206f4e
 8006178:	656e6e6f 	.word	0x656e6e6f
 800617c:	6f697463 	.word	0x6f697463
 8006180:	41202c6e 	.word	0x41202c6e
 8006184:	72657664 	.word	0x72657664
 8006188:	69736974 	.word	0x69736974
 800618c:	5320676e 	.word	0x5320676e
 8006190:	70706f74 	.word	0x70706f74
 8006194:	0a0d6465 	.word	0x0a0d6465
 8006198:	00000000 	.word	0x00000000
 800619c:	74756853 	.word	0x74756853
 80061a0:	676e6974 	.word	0x676e6974
 80061a4:	66666f20 	.word	0x66666f20
 80061a8:	00000a0d 	.word	0x00000a0d
 80061ac:	44676942 	.word	0x44676942
 80061b0:	20617461 	.word	0x20617461
 80061b4:	746e6553 	.word	0x746e6553
 80061b8:	00000a0d 	.word	0x00000a0d
 80061bc:	63736944 	.word	0x63736944
 80061c0:	656e6e6f 	.word	0x656e6e6f
 80061c4:	53207463 	.word	0x53207463
 80061c8:	0d746e65 	.word	0x0d746e65
 80061cc:	0000000a 	.word	0x0000000a
 80061d0:	00646d63 	.word	0x00646d63
 80061d4:	746e6553 	.word	0x746e6553
 80061d8:	6425203a 	.word	0x6425203a
 80061dc:	20782520 	.word	0x20782520
 80061e0:	00000d0a 	.word	0x00000d0a
 80061e4:	65636552 	.word	0x65636552
 80061e8:	64657669 	.word	0x64657669
 80061ec:	0000003a 	.word	0x0000003a
 80061f0:	00632520 	.word	0x00632520
 80061f4:	00000d0a 	.word	0x00000d0a
 80061f8:	0d0a7325 	.word	0x0d0a7325
 80061fc:	00000000 	.word	0x00000000
 8006200:	6365796d 	.word	0x6365796d
 8006204:	00006f68 	.word	0x00006f68
 8006208:	00006662 	.word	0x00006662
 800620c:	6c656853 	.word	0x6c656853
 8006210:	6944206c 	.word	0x6944206c
 8006214:	0d0a6465 	.word	0x0d0a6465
 8006218:	00000000 	.word	0x00000000
 800621c:	74736552 	.word	0x74736552
 8006220:	69747261 	.word	0x69747261
 8006224:	6620676e 	.word	0x6620676e
 8006228:	206d6f72 	.word	0x206d6f72
 800622c:	6d726574 	.word	0x6d726574
 8006230:	74616e69 	.word	0x74616e69
 8006234:	206e6f69 	.word	0x206e6f69
 8006238:	646e6168 	.word	0x646e6168
 800623c:	0a72656c 	.word	0x0a72656c
 8006240:	0000000d 	.word	0x0000000d
 8006244:	70550d0a 	.word	0x70550d0a
 8006248:	646e6120 	.word	0x646e6120
 800624c:	6e755220 	.word	0x6e755220
 8006250:	676e696e 	.word	0x676e696e
 8006254:	00000d0a 	.word	0x00000d0a
	...
 8006260:	6c756e28 	.word	0x6c756e28
 8006264:	0000296c 	.word	0x0000296c
	...
 8006270:	202d2d2d 	.word	0x202d2d2d
 8006274:	726f6353 	.word	0x726f6353
 8006278:	203a2065 	.word	0x203a2065
 800627c:	00000000 	.word	0x00000000
 8006280:	67736d20 	.word	0x67736d20
 8006284:	2c532f73 	.word	0x2c532f73
 8006288:	00000020 	.word	0x00000020
 800628c:	78746320 	.word	0x78746320
 8006290:	2f637773 	.word	0x2f637773
 8006294:	00000053 	.word	0x00000053
 8006298:	72687420 	.word	0x72687420
 800629c:	73646165 	.word	0x73646165
 80062a0:	0000532f 	.word	0x0000532f
 80062a4:	73657220 	.word	0x73657220
 80062a8:	64656863 	.word	0x64656863
 80062ac:	73656c75 	.word	0x73656c75
 80062b0:	202c532f 	.word	0x202c532f
 80062b4:	00000000 	.word	0x00000000
 80062b8:	74796220 	.word	0x74796220
 80062bc:	532f7365 	.word	0x532f7365
 80062c0:	00000000 	.word	0x00000000
 80062c4:	6d697420 	.word	0x6d697420
 80062c8:	2f737265 	.word	0x2f737265
 80062cc:	00000053 	.word	0x00000053
 80062d0:	69617720 	.word	0x69617720
 80062d4:	69732b74 	.word	0x69732b74
 80062d8:	6c616e67 	.word	0x6c616e67
 80062dc:	0000532f 	.word	0x0000532f
 80062e0:	636f6c20 	.word	0x636f6c20
 80062e4:	6e752b6b 	.word	0x6e752b6b
 80062e8:	6b636f6c 	.word	0x6b636f6c
 80062ec:	0000532f 	.word	0x0000532f
 80062f0:	202d2d2d 	.word	0x202d2d2d
 80062f4:	74737953 	.word	0x74737953
 80062f8:	203a6d65 	.word	0x203a6d65
 80062fc:	00000000 	.word	0x00000000
 8006300:	74796220 	.word	0x74796220
 8006304:	00007365 	.word	0x00007365
 8006308:	202d2d2d 	.word	0x202d2d2d
 800630c:	65726854 	.word	0x65726854
 8006310:	203a6461 	.word	0x203a6461
 8006314:	00000000 	.word	0x00000000
 8006318:	202d2d2d 	.word	0x202d2d2d
 800631c:	656d6954 	.word	0x656d6954
 8006320:	203a2072 	.word	0x203a2072
 8006324:	00000000 	.word	0x00000000
 8006328:	202d2d2d 	.word	0x202d2d2d
 800632c:	616d6553 	.word	0x616d6553
 8006330:	203a6870 	.word	0x203a6870
 8006334:	00000000 	.word	0x00000000
 8006338:	202d2d2d 	.word	0x202d2d2d
 800633c:	6e657645 	.word	0x6e657645
 8006340:	203a5374 	.word	0x203a5374
 8006344:	00000000 	.word	0x00000000
 8006348:	202d2d2d 	.word	0x202d2d2d
 800634c:	6e657645 	.word	0x6e657645
 8006350:	203a4c74 	.word	0x203a4c74
 8006354:	00000000 	.word	0x00000000
 8006358:	202d2d2d 	.word	0x202d2d2d
 800635c:	6574754d 	.word	0x6574754d
 8006360:	203a2078 	.word	0x203a2078
 8006364:	00000000 	.word	0x00000000
 8006368:	202d2d2d 	.word	0x202d2d2d
 800636c:	646e6f43 	.word	0x646e6f43
 8006370:	203a2e56 	.word	0x203a2e56
 8006374:	00000000 	.word	0x00000000
 8006378:	202d2d2d 	.word	0x202d2d2d
 800637c:	75657551 	.word	0x75657551
 8006380:	203a2065 	.word	0x203a2065
 8006384:	00000000 	.word	0x00000000
 8006388:	202d2d2d 	.word	0x202d2d2d
 800638c:	6c69614d 	.word	0x6c69614d
 8006390:	203a2e42 	.word	0x203a2e42
 8006394:	00000000 	.word	0x00000000
 8006398:	67617355 	.word	0x67617355
 800639c:	25203a65 	.word	0x25203a65
 80063a0:	000a0d73 	.word	0x000a0d73
 80063a4:	00207325 	.word	0x00207325
 80063a8:	6f666e69 	.word	0x6f666e69
 80063ac:	00000000 	.word	0x00000000
 80063b0:	6e72654b 	.word	0x6e72654b
 80063b4:	203a6c65 	.word	0x203a6c65
 80063b8:	20202020 	.word	0x20202020
 80063bc:	73252020 	.word	0x73252020
 80063c0:	00000a0d 	.word	0x00000a0d
 80063c4:	2e322e33 	.word	0x2e322e33
 80063c8:	00000030 	.word	0x00000030
 80063cc:	706d6f43 	.word	0x706d6f43
 80063d0:	72656c69 	.word	0x72656c69
 80063d4:	2020203a 	.word	0x2020203a
 80063d8:	73252020 	.word	0x73252020
 80063dc:	00000a0d 	.word	0x00000a0d
 80063e0:	20434347 	.word	0x20434347
 80063e4:	2e382e34 	.word	0x2e382e34
 80063e8:	30322034 	.word	0x30322034
 80063ec:	35303431 	.word	0x35303431
 80063f0:	28203632 	.word	0x28203632
 80063f4:	656c6572 	.word	0x656c6572
 80063f8:	29657361 	.word	0x29657361
 80063fc:	52415b20 	.word	0x52415b20
 8006400:	6d652f4d 	.word	0x6d652f4d
 8006404:	64646562 	.word	0x64646562
 8006408:	342d6465 	.word	0x342d6465
 800640c:	622d385f 	.word	0x622d385f
 8006410:	636e6172 	.word	0x636e6172
 8006414:	65722068 	.word	0x65722068
 8006418:	69736976 	.word	0x69736976
 800641c:	32206e6f 	.word	0x32206e6f
 8006420:	35333131 	.word	0x35333131
 8006424:	00005d38 	.word	0x00005d38
 8006428:	68637241 	.word	0x68637241
 800642c:	63657469 	.word	0x63657469
 8006430:	65727574 	.word	0x65727574
 8006434:	7325203a 	.word	0x7325203a
 8006438:	00000a0d 	.word	0x00000a0d
 800643c:	764d5241 	.word	0x764d5241
 8006440:	4d2d4537 	.word	0x4d2d4537
 8006444:	00000000 	.word	0x00000000
 8006448:	65726f43 	.word	0x65726f43
 800644c:	72615620 	.word	0x72615620
 8006450:	746e6169 	.word	0x746e6169
 8006454:	7325203a 	.word	0x7325203a
 8006458:	00000a0d 	.word	0x00000a0d
 800645c:	74726f43 	.word	0x74726f43
 8006460:	4d2d7865 	.word	0x4d2d7865
 8006464:	00000034 	.word	0x00000034
 8006468:	74726f50 	.word	0x74726f50
 800646c:	666e4920 	.word	0x666e4920
 8006470:	20203a6f 	.word	0x20203a6f
 8006474:	73252020 	.word	0x73252020
 8006478:	00000a0d 	.word	0x00000a0d
 800647c:	61766441 	.word	0x61766441
 8006480:	6465636e 	.word	0x6465636e
 8006484:	72656b20 	.word	0x72656b20
 8006488:	206c656e 	.word	0x206c656e
 800648c:	65646f6d 	.word	0x65646f6d
 8006490:	00000000 	.word	0x00000000
 8006494:	74616c50 	.word	0x74616c50
 8006498:	6d726f66 	.word	0x6d726f66
 800649c:	2020203a 	.word	0x2020203a
 80064a0:	73252020 	.word	0x73252020
 80064a4:	00000a0d 	.word	0x00000a0d
 80064a8:	334d5453 	.word	0x334d5453
 80064ac:	30334632 	.word	0x30334632
 80064b0:	20437833 	.word	0x20437833
 80064b4:	6c616e41 	.word	0x6c616e41
 80064b8:	2620676f 	.word	0x2620676f
 80064bc:	50534420 	.word	0x50534420
 80064c0:	00000000 	.word	0x00000000
 80064c4:	72616f42 	.word	0x72616f42
 80064c8:	20203a64 	.word	0x20203a64
 80064cc:	20202020 	.word	0x20202020
 80064d0:	73252020 	.word	0x73252020
 80064d4:	00000a0d 	.word	0x00000a0d
 80064d8:	694d5453 	.word	0x694d5453
 80064dc:	656f7263 	.word	0x656f7263
 80064e0:	7463656c 	.word	0x7463656c
 80064e4:	696e6f72 	.word	0x696e6f72
 80064e8:	53207363 	.word	0x53207363
 80064ec:	32334d54 	.word	0x32334d54
 80064f0:	442d3346 	.word	0x442d3346
 80064f4:	6f637369 	.word	0x6f637369
 80064f8:	79726576 	.word	0x79726576
 80064fc:	00000000 	.word	0x00000000
 8006500:	6c697542 	.word	0x6c697542
 8006504:	69742064 	.word	0x69742064
 8006508:	203a656d 	.word	0x203a656d
 800650c:	73252020 	.word	0x73252020
 8006510:	73257325 	.word	0x73257325
 8006514:	00000a0d 	.word	0x00000a0d
 8006518:	2072614d 	.word	0x2072614d
 800651c:	32203133 	.word	0x32203133
 8006520:	00363130 	.word	0x00363130
 8006524:	00202d20 	.word	0x00202d20
 8006528:	333a3531 	.word	0x333a3531
 800652c:	35343a36 	.word	0x35343a36
 8006530:	00000000 	.word	0x00000000
 8006534:	74737973 	.word	0x74737973
 8006538:	00656d69 	.word	0x00656d69
 800653c:	0d756c25 	.word	0x0d756c25
 8006540:	0000000a 	.word	0x0000000a
 8006544:	6c656873 	.word	0x6c656873
 8006548:	0000006c 	.word	0x0000006c
 800654c:	68430a0d 	.word	0x68430a0d
 8006550:	4f696269 	.word	0x4f696269
 8006554:	54522f53 	.word	0x54522f53
 8006558:	65685320 	.word	0x65685320
 800655c:	0a0d6c6c 	.word	0x0a0d6c6c
 8006560:	00000000 	.word	0x00000000
 8006564:	203e6863 	.word	0x203e6863
 8006568:	00000000 	.word	0x00000000
 800656c:	6f6c0a0d 	.word	0x6f6c0a0d
 8006570:	74756f67 	.word	0x74756f67
 8006574:	00000000 	.word	0x00000000
 8006578:	00000920 	.word	0x00000920
 800657c:	206f6f74 	.word	0x206f6f74
 8006580:	796e616d 	.word	0x796e616d
 8006584:	67726120 	.word	0x67726120
 8006588:	6e656d75 	.word	0x6e656d75
 800658c:	0a0d7374 	.word	0x0a0d7374
 8006590:	00000000 	.word	0x00000000
 8006594:	74697865 	.word	0x74697865
 8006598:	00000000 	.word	0x00000000
 800659c:	706c6568 	.word	0x706c6568
 80065a0:	00000000 	.word	0x00000000
 80065a4:	6d6d6f43 	.word	0x6d6d6f43
 80065a8:	73646e61 	.word	0x73646e61
 80065ac:	6568203a 	.word	0x6568203a
 80065b0:	6520706c 	.word	0x6520706c
 80065b4:	20746978 	.word	0x20746978
 80065b8:	00000000 	.word	0x00000000
 80065bc:	00000a0d 	.word	0x00000a0d
 80065c0:	00007325 	.word	0x00007325
 80065c4:	0a0d3f20 	.word	0x0a0d3f20
 80065c8:	00000000 	.word	0x00000000
 80065cc:	0000445e 	.word	0x0000445e
 80065d0:	20414d44 	.word	0x20414d44
 80065d4:	6c696166 	.word	0x6c696166
 80065d8:	00657275 	.word	0x00657275
 80065dc:	00000a0d 	.word	0x00000a0d
 80065e0:	00000000 	.word	0x00000000
 80065e4:	202a2a2a 	.word	0x202a2a2a
 80065e8:	62696843 	.word	0x62696843
 80065ec:	2f534f69 	.word	0x2f534f69
 80065f0:	74205452 	.word	0x74205452
 80065f4:	20747365 	.word	0x20747365
 80065f8:	74697573 	.word	0x74697573
 80065fc:	00000065 	.word	0x00000065
 8006600:	002a2a2a 	.word	0x002a2a2a
 8006604:	202a2a2a 	.word	0x202a2a2a
 8006608:	6e72654b 	.word	0x6e72654b
 800660c:	203a6c65 	.word	0x203a6c65
 8006610:	20202020 	.word	0x20202020
 8006614:	00002020 	.word	0x00002020
 8006618:	2e322e33 	.word	0x2e322e33
 800661c:	00000030 	.word	0x00000030
 8006620:	202a2a2a 	.word	0x202a2a2a
 8006624:	706d6f43 	.word	0x706d6f43
 8006628:	64656c69 	.word	0x64656c69
 800662c:	2020203a 	.word	0x2020203a
 8006630:	00002020 	.word	0x00002020
 8006634:	2072614d 	.word	0x2072614d
 8006638:	32203133 	.word	0x32203133
 800663c:	20363130 	.word	0x20363130
 8006640:	3531202d 	.word	0x3531202d
 8006644:	3a36333a 	.word	0x3a36333a
 8006648:	00003134 	.word	0x00003134
 800664c:	202a2a2a 	.word	0x202a2a2a
 8006650:	706d6f43 	.word	0x706d6f43
 8006654:	72656c69 	.word	0x72656c69
 8006658:	2020203a 	.word	0x2020203a
 800665c:	00002020 	.word	0x00002020
 8006660:	20434347 	.word	0x20434347
 8006664:	2e382e34 	.word	0x2e382e34
 8006668:	30322034 	.word	0x30322034
 800666c:	35303431 	.word	0x35303431
 8006670:	28203632 	.word	0x28203632
 8006674:	656c6572 	.word	0x656c6572
 8006678:	29657361 	.word	0x29657361
 800667c:	52415b20 	.word	0x52415b20
 8006680:	6d652f4d 	.word	0x6d652f4d
 8006684:	64646562 	.word	0x64646562
 8006688:	342d6465 	.word	0x342d6465
 800668c:	622d385f 	.word	0x622d385f
 8006690:	636e6172 	.word	0x636e6172
 8006694:	65722068 	.word	0x65722068
 8006698:	69736976 	.word	0x69736976
 800669c:	32206e6f 	.word	0x32206e6f
 80066a0:	35333131 	.word	0x35333131
 80066a4:	00005d38 	.word	0x00005d38
 80066a8:	202a2a2a 	.word	0x202a2a2a
 80066ac:	68637241 	.word	0x68637241
 80066b0:	63657469 	.word	0x63657469
 80066b4:	65727574 	.word	0x65727574
 80066b8:	0000203a 	.word	0x0000203a
 80066bc:	764d5241 	.word	0x764d5241
 80066c0:	4d2d4537 	.word	0x4d2d4537
 80066c4:	00000000 	.word	0x00000000
 80066c8:	202a2a2a 	.word	0x202a2a2a
 80066cc:	65726f43 	.word	0x65726f43
 80066d0:	72615620 	.word	0x72615620
 80066d4:	746e6169 	.word	0x746e6169
 80066d8:	0000203a 	.word	0x0000203a
 80066dc:	74726f43 	.word	0x74726f43
 80066e0:	4d2d7865 	.word	0x4d2d7865
 80066e4:	00000034 	.word	0x00000034
 80066e8:	202a2a2a 	.word	0x202a2a2a
 80066ec:	74726f50 	.word	0x74726f50
 80066f0:	666e4920 	.word	0x666e4920
 80066f4:	20203a6f 	.word	0x20203a6f
 80066f8:	00002020 	.word	0x00002020
 80066fc:	61766441 	.word	0x61766441
 8006700:	6465636e 	.word	0x6465636e
 8006704:	72656b20 	.word	0x72656b20
 8006708:	206c656e 	.word	0x206c656e
 800670c:	65646f6d 	.word	0x65646f6d
 8006710:	00000000 	.word	0x00000000
 8006714:	202a2a2a 	.word	0x202a2a2a
 8006718:	74616c50 	.word	0x74616c50
 800671c:	6d726f66 	.word	0x6d726f66
 8006720:	2020203a 	.word	0x2020203a
 8006724:	00002020 	.word	0x00002020
 8006728:	334d5453 	.word	0x334d5453
 800672c:	30334632 	.word	0x30334632
 8006730:	20437833 	.word	0x20437833
 8006734:	6c616e41 	.word	0x6c616e41
 8006738:	2620676f 	.word	0x2620676f
 800673c:	50534420 	.word	0x50534420
 8006740:	00000000 	.word	0x00000000
 8006744:	202a2a2a 	.word	0x202a2a2a
 8006748:	74736554 	.word	0x74736554
 800674c:	616f4220 	.word	0x616f4220
 8006750:	203a6472 	.word	0x203a6472
 8006754:	00002020 	.word	0x00002020
 8006758:	694d5453 	.word	0x694d5453
 800675c:	656f7263 	.word	0x656f7263
 8006760:	7463656c 	.word	0x7463656c
 8006764:	696e6f72 	.word	0x696e6f72
 8006768:	53207363 	.word	0x53207363
 800676c:	32334d54 	.word	0x32334d54
 8006770:	442d3346 	.word	0x442d3346
 8006774:	6f637369 	.word	0x6f637369
 8006778:	79726576 	.word	0x79726576
 800677c:	00000000 	.word	0x00000000
 8006780:	202d2d2d 	.word	0x202d2d2d
 8006784:	74736554 	.word	0x74736554
 8006788:	73614320 	.word	0x73614320
 800678c:	00002065 	.word	0x00002065
 8006790:	0000002e 	.word	0x0000002e
 8006794:	00002820 	.word	0x00002820
 8006798:	00000029 	.word	0x00000029
 800679c:	202d2d2d 	.word	0x202d2d2d
 80067a0:	75736552 	.word	0x75736552
 80067a4:	203a746c 	.word	0x203a746c
 80067a8:	4c494146 	.word	0x4c494146
 80067ac:	20455255 	.word	0x20455255
 80067b0:	00002328 	.word	0x00002328
 80067b4:	00005b20 	.word	0x00005b20
 80067b8:	0000295d 	.word	0x0000295d
 80067bc:	202d2d2d 	.word	0x202d2d2d
 80067c0:	75736552 	.word	0x75736552
 80067c4:	203a746c 	.word	0x203a746c
 80067c8:	43435553 	.word	0x43435553
 80067cc:	00535345 	.word	0x00535345
 80067d0:	616e6946 	.word	0x616e6946
 80067d4:	6572206c 	.word	0x6572206c
 80067d8:	746c7573 	.word	0x746c7573
 80067dc:	0000203a 	.word	0x0000203a
 80067e0:	4c494146 	.word	0x4c494146
 80067e4:	00455255 	.word	0x00455255
 80067e8:	43435553 	.word	0x43435553
 80067ec:	00535345 	.word	0x00535345
 80067f0:	656c6469 	.word	0x656c6469
 80067f4:	00000000 	.word	0x00000000
 80067f8:	63617473 	.word	0x63617473
 80067fc:	766f206b 	.word	0x766f206b
 8006800:	6c667265 	.word	0x6c667265
 8006804:	0000776f 	.word	0x0000776f
	...

08006810 <ram_areas.4024>:
 8006810:	08006c0c 20001f58 20001f58 20001f58     .l..X.. X.. X.. 
 8006820:	08006c0c 00000000 00000000 00000000     .l..............
 8006830:	08006c0c 00000000 00000000 00000000     .l..............
 8006840:	08006c0c 00000000 00000000 00000000     .l..............
 8006850:	08006c0c 10000000 10000000 10000000     .l..............
 8006860:	08006c0c 00000000 00000000 00000000     .l..............
 8006870:	08006c0c 00000000 00000000 00000000     .l..............
 8006880:	08006c0c 00000000 00000000 00000000     .l..............

08006890 <ch_debug>:
 8006890:	6e69616d 18801600 08440404 1814100c     main......D.....
 80068a0:	2221201c 00000000 00000000 00000000     . !"............

080068b0 <vmt.8314>:
 80068b0:	08003481 080034b1 080034e1 08003511     .4...4...4...5..
 80068c0:	08003531 08003561 08003581 080035b1     15..a5...5...5..

080068d0 <_stm32_dma_streams>:
 80068d0:	40020000 40020008 00000001 00000000     ...@...@........
 80068e0:	000b0000 40020000 4002001c 00000002     .......@...@....
 80068f0:	00000000 000c0104 40020000 40020030     ...........@0..@
 8006900:	00000004 00000000 000d0208 40020000     ...............@
 8006910:	40020044 00000008 00000000 000e030c     D..@............
 8006920:	40020000 40020058 00000010 00000000     ...@X..@........
 8006930:	000f0410 40020000 4002006c 00000020     .......@l..@ ...
 8006940:	00000000 00100514 40020000 40020080     ...........@...@
 8006950:	00000040 00000000 00110618 40020400     @..............@
 8006960:	40020408 00000080 00000000 00380700     ...@..........8.
 8006970:	40020400 4002041c 00000100 00000000     ...@...@........
 8006980:	00390804 40020400 40020430 00000200     ..9....@0..@....
 8006990:	00000000 003a0908 40020400 40020444     ......:....@D..@
 80069a0:	00000400 00000000 003b0a0c 40020400     ..........;....@
 80069b0:	40020458 00000800 00000000 003c0b10     X..@..........<.

080069c0 <dummytx.9314>:
 80069c0:	0000ffff 00000000 00000000 00000000     ................

080069d0 <default_config.9541>:
 80069d0:	00009600 00000000 00004000 00000000     .........@......

080069e0 <pal_default_config>:
 80069e0:	2a80a800 00000000 3cc0fc00 64151154     ...*.......<T..d
 80069f0:	0000ffff 55500000 000ee000 0000a080     ......PU........
 8006a00:	000000c0 0000f0c0 55550515 0000ffff     ..........UU....
 8006a10:	44000000 00000000 00000000 00000000     ...D............
 8006a20:	f0000000 05555555 0000ffff 00000000     ....UUU.........
	...
 8006a40:	55555555 0000ffff 00000000 00000000     UUUU............
 8006a50:	55550040 00000000 ffff00c0 01155515     @.UU.........U..
 8006a60:	000000ff 00000000 00000000 00000000     ................
 8006a70:	00000000 0000000f 55555550 0000ffff     ........PUUU....
	...

08006a90 <commands.13664.4893>:
 8006a90:	08006200 08000cf1 08006208 08000ae1     .b.......b......
	...

08006ab0 <shell_cfg1.13663.4892>:
 8006ab0:	20000ba8 08006a90                       ... .j..
